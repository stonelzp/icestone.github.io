<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[UE4中的Casting]]></title>
    <url>%2F2018%2F10%2F09%2FUE4%E4%B8%AD%E7%9A%84Casting%2F</url>
    <content type="text"><![CDATA[关于Cast To节点在Blueprint中能够做什么的问题。下面是官方文档中的说明。 Casting in Blueprint 其中的一句话： By using the Get Player Charactor node, then using a Cast To MyCharactor node(the special Charactor Blueprint), you can say if the Player Charactor is MyCharactor, let me access the Variables, Functions, Events or any other special functionality contained within that Blueprint.]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Blueprint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-rebases使用方法]]></title>
    <url>%2F2018%2F08%2F30%2Fgit-rebases%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[git rebase的使用简介]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4:Error_Message整理]]></title>
    <url>%2F2018%2F08%2F16%2FUE4-Error-Message%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[整理在学习UE4的过程中遇到的一些BUG。 syntax error:missing ‘;’ before ‘*’参考链接： syntax error: missing ‘;’ before ‘*’ (First Person Shooter C++ Tutorial) 加了一个关键字class就解决了。虽然不知道是为什么。 LogMaterial: Warning: Material /Game/MagicCircle/Materials/MT_Smoke.MT_Smoke missing bUsedWithInstancedStaticMeshes=True! Default Material will be used in game.#]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>UE4Error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为Actor添加Input事件]]></title>
    <url>%2F2018%2F08%2F16%2F%E4%B8%BAActor%E6%B7%BB%E5%8A%A0Input%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在自己编写Actor的Component的时候想要加上input的事件，但是在UE4中加入这种事件不是那么简单的。这需要对Actor的层级关系有一些了解。 参考链接： C++Is there a way to get input from actor that isn a pawn/character ? Check Keyboard Event in code UE4-学习笔记之二 这篇文章感觉好厉害 &lt;&gt;GamePlay架构(四)Pawn 知乎文章，可以一看]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4-ConstructorHelpers::FObjectFinder]]></title>
    <url>%2F2018%2F08%2F10%2FUE4-ConstructorHelpers-FObjectFinder%2F</url>
    <content type="text"><![CDATA[先来说一说这个问题的起源吧。最近想做一个类似于火焰的特效，是由大量的烟雾粒子组成的那种类似于烟雾的火焰。在制作大量烟雾粒子之前首先要制作出第一个粒子。 制作一个粒子表现的话首先要先实例化一个Instance，这个实例首先依附在一个Acor上。当然，像Unity的脚本函数一样，在Scene中制作一个Actor然后把脚本当做一个ActorComponent的方案是可行的。然后在脚本中使用this-&gt;GetOwner()即可以获取到这个Actor。可以使用this-&gt;GetOwner()-&gt;GetName()来获取到Actor的名字。 参考链接： Get actor from component in c++? 在这里遇见了一个问题。就是在使用UE的UE_LOG打印输出的时候发生了类型错误。 在UE_LOG中使用的都是基础类型，%d,%s等等。 GetName()函数返回的变量类型则是UE的FString类型 解决例子：12// Actor component .cpp fileUE_LOG(LogTemp, Log, TEXT("show value: : %s", *(this-&gt;GetOwner()-&gt;GetName())); 解决案参考： Log issue (passing a FString) Logs, Printing Messages To Yourself During Runtime 能够获取到Parent的Actor就可以根据自身的Actor来制作InstanceStaticMeshComponent了。 InstanceStaticMeshComponent使用方法参照： Using Instanced Static Meshes in C++? 下一步就是发生问题的地方，为制作好的InstanceStaticMeshComponent添加StaticMesh。 上网查查资料就有，这篇文章就行 QUESTION Apply Static Mesh to StaticMesh component 照着做本来不会出错的但是我一运行，UE4肯定Crash。 原因就在于题目所提到的关于ContructorHelpers::FObjectFinder的使用上。总结来说就是这个函数只能运行在类的构造函数中，或者构造函数里调用的函数中。 解决文章： How to use ConstructorHelpers::FObjectFinder? 这个回答中有提到。之后再整理。]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH原理知识普及]]></title>
    <url>%2F2018%2F08%2F06%2FSSH%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A%2F</url>
    <content type="text"><![CDATA[SSH的原理与运用。 参考链接： SSH原理与运用（一）：远程登录 数字签名是什么？ What is a Digital Signature?]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中读取Texture2D的像素值]]></title>
    <url>%2F2018%2F08%2F03%2FUE4%E4%B8%AD%E8%AF%BB%E5%8F%96Texture2D%E7%9A%84%E5%83%8F%E7%B4%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[目的是在UE中获取到一张Texture2D图片的所有像素值，并将这些像素值进行某些处理并保存到另外一个Texture中。 第一步：获取到Texture2D资源Unreal Engine 4 Documentation Referencing Assets 对于高速化来说异步加载资源也是好的解决方案 Ureal Engine 4 Documentation Asynchronous Asset Loading 参考的文章 Accessing pixel values of Texture2D First you need to understand that a texture is normally, a sum of multiple images called MipMaps. MipMaps are down-scaled versions of your images, always in steps of power of 2, so the original image, is, say, 512x512 - this would be the MipMap “0”, then the engine generates the MipMap “1” which is 256x256 and then MipMap “2” which is 128x128, this continues on down to 16x16 I think. The farther away the texture is rendered, the smaller version of the image is used. This means that you need to access the mipmap 0 of your texture. 对上面的答案进行了非常好的总结的文章 UE4 – Reading the pixels from a UTexture2D Reading data from UTexture2D 之后附上完整的代码UE4中的资源管理 Asset Management 拓展知识在代码中看到了static_cast这个语句，竟然不知道是做什么的。查了一下 C++中static_cast, dynamic_cast, const_cast用法/使用情况及区别解析 之后要好好整理一下。]]></content>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4的函数库]]></title>
    <url>%2F2018%2F08%2F02%2FUE4%E7%9A%84%E5%87%BD%E6%95%B0%E5%BA%93%2F</url>
    <content type="text"><![CDATA[在UE4中总会遇见一些不知道是做什么的函数，这篇文章的目的是整理自己遇到的UE4的函数和类，和弄清函数和类的时候遇到的一些问题的解决。 UE4中的类UTexture2DTextureCompressionSettingsTextureMipGenSettingsUpdateResource() Functio作用UTextureRenderTaget2DUreal Engine 4 Documentation: UTextureRenderTarget2D 可以用来存储一个2DTexture数据的类，拥有着许多的成员，文件的位置： C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Classes\Engine\TextureRenderTarget2D.h C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Private\TextureRenderTarget2D.cpp 关于如何实例化这个类，我在网上并没有找到类似的实现，但是在UE4的Blueprint中可以找到一个名为Create Rendr Target 2D的node函数。试着找了一下这个节点的实现函数 C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Private\KismetRendngLibrary.cpp 其中有如下的实现代码：1234567891011121314151617UTextureRenderTarget3D* UKismetRenderingLibrary::CreateRenderTarget2D(UObject* WorldContextObject, int32 Width, int32 Height, ETextureRenderTargetFormat Format)&#123; UWorld* World = GEngine-&gt;GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull); if (Width &gt; 0 &amp;&amp; Height &gt; 0 &amp;&amp; World &amp;&amp; FApp::CanEverRender()) &#123; UTextureRenderTarget2D* NewRenderTarget2D = NewObject&lt;UTextureRenderTarget2D&gt;(WorldContextObject); check(NewRenderTarget2D); NewRenderTarget2D-&gt;RenderTargetFormat = Format; NewRenderTarget2D-&gt;InitAutoFormat(Width, Height); NewRenderTarget2D-&gt;UpdateResourceImmediate(true); return NewRenderTarget2D; &#125; return nullptr;&#125; 或许可以给与一些参照。 UMaterialInstanceDynamicUreal Engine 4 Documentation: UMaterialInstanceDynamic 这个类的作用按照字面意思来推测是用来创建一个动态的材质实例，在UE4的Blueprint中也有相应的节点函数：CreateDynamicMaterialInstance。函数位置 C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Private\KismetMaterialLibrary.cpp 其中的实现代码：1234567891011121314151617181920class UMaterialInstanceDynamic* UKismetMaterialLibrary::CreateDynamicMaterialInstance(UObject* WorldContextObject, class UMaterialInterface* Parent)&#123; UMaterialInstanceDynamic* NewMID = nullptr; if (Parent) &#123; // MIDs need to be created within a persistent object if in the construction script (or blutility) or else they will not be saved. // If this MID is created at runtime then put it in the transient package UWorld* World = GEngine-&gt;GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::ReturnNull); UObject* MIDOuter = (World &amp;&amp; (World-&gt;bIsRunningConstructionScript || !World-&gt;IsGameWorld()) ? WorldContextObject : nullptr); NewMID = UMaterialInstanceDynamic::Create(Parent, MIDOuter); if (MIDOuter == nullptr) &#123; NewMID-&gt;SetFlags(RF_Transient); &#125; &#125; return NewMID;&#125; 可以为该材质添加值的函数实现：1234567891011121314151617181920212223void UKismetMaterialLibrary::SetScalarParameterValue(UObject* WorldContextObject, UMaterialParameterCollection* Collection, FName ParameterName, float ParameterValue)&#123; if (Collection) &#123; if (UWorld* World = GEngine-&gt;GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull)) &#123; UMaterialParameterCollectionInstance* Instance = World-&gt;GetParameterCollectionInstance(Collection); const bool bFoundParameter = Instance-&gt;SetScalarParameterValue(ParameterName, ParameterValue); if (!bFoundParameter &amp;&amp; !Instance-&gt;bLoggedMissingParameterWarning) &#123; FFormatNamedArguments Arguments; Arguments.Add(TEXT("ParamName"), FText::FromName(ParameterName)); FMessageLog("PIE").Warning() -&gt;AddToken(FTextToken::Create(LOCTEXT("SetScalarParamOn", "SetScalarParameterValue called on"))) -&gt;AddToken(FUObjectToken::Create(Collection)) -&gt;AddToken(FTextToken::Create(FText::Format(LOCTEXT("WithInvalidParam", "with invalid ParameterName '&#123;ParamName&#125;'. This is likely due to a Blueprint error."), Arguments))); Instance-&gt;bLoggedMissingParameterWarning = true; &#125; &#125; &#125;&#125; 使用方法是在C++中声明一个材质1234567UMaterialInstanceDynamic* mMaterial;//将mMaterial的材质实例通过Blueprint传递过来mMaterial-&gt;SetScalarParamaterValue("TextureWidth",512);//这样便可以将换递过来的Blueprint中的名为`TextureWidth`(if exist)的Parameter赋值为512了 但还是有许多疑问。 UE4中的函数check()参考链接： When should I use Check()? AddInstance()UE4中的一些类型TextureAddress在Texture.h中看到了这个属性，不太清楚是什么属性，就查了一下。貌似是一种纹理寻址模式。因为有赋值为T_Clamp,Clamp让我有些回想起来在Unity中设置UV的时候有repeat跟clamp等等选项来着，需要调查一下。 D3D11_TEXTURE_ADDRESS_MODE(纹理寻址模式) TextureFilterSRGB是什么参考链接： sRGB - how to be? 【图形学】我理解的伽马校正（Gamma Correction）]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的static关键字]]></title>
    <url>%2F2018%2F08%2F02%2FC%2B%2B%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[static 关键字可用于声明变量、函数、类数据成员和类函数。 之后需要好好整理一下，static关键字的用法。 参考链接： C/C++ 中的static关键字 The static keyword and its various uses in C++]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4的Plugin使用]]></title>
    <url>%2F2018%2F08%2F02%2FUE4%E7%9A%84Plugin%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[制作UE4的插件相当于给UE4引擎添加新的功能模块。UE4的功能模块组成是由Module组成的，关于Module具体是什么，中文翻译就是模块，自己的理解中可以说是文件的单位了。 新建的插件代表着跟UE4本来的功能模块不是从属于一个Module，所以需要为自己制作的插件制作一个属性为Public的公开接口以供UE4引擎调用。 Plugin的Public公开权限一般一个Module中不想公开的源文件都会设置为Private权限，不允许外界的Module访问。要把权限公开，使得其他的模块能够访问的话需要以下两步。 头文件的位置 头文件(.h)放到[\Source\Public]文件夹中去 cpp实现文件放到[\Source\Private]文件夹中去 添加Export用的宏在类的声明中添加一个宏：&lt;大写字母的Module名字&gt;_API 例如：1234UCLASS()class SAYHELLO_API USayHelloFunction : public UBlueprintFunctionLibrary&#123; GENERATED_BODY()&#125; 这样一个名为SayHello的Module的class的权限就变成公开的了。 Tips： 上述的SAYHELLO_API的定义文件位置在Intermediate/Build/Win64/UE4Editor/Development/SayHello/Definitions.SayHello.h。里面定义了DLLEXPORT,DLLIMPORT。 UE会按照Module的单位生成DLL，&lt;ModuleName&gt;_API在自身的Module中会指定DLLEXPORT，在其他的Module中会指定DLLIMPORT。（啥意思？书上就写了这么多。。。） 参考资料： Unreal Engine 4 Documentation - Plugins Unreal Engine 4 C++ 插件介绍 ue4插件开发]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的const修饰符]]></title>
    <url>%2F2018%2F08%2F01%2FC%2B%2B%E4%B8%AD%E7%9A%84const%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[C++中经常会看到const关键字来修饰很多东西，在这里把自己遇到的一些情况收集并整理一下。 参考链接 C++ Const Usage Explanation 关于C++ const 的全面总结]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的静态库与动态库]]></title>
    <url>%2F2018%2F08%2F01%2FUE4%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[库(Library)是什么,库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。 本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种：静态库（.a、.lib）和动态库（.so、.dll）。所谓静态、动态是指链接。 需要知道的除了制作动态库与静态库，还要知道这两种库之间的区别。为什么要制作库。 参考链接： C++静态库与动态库]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的异步处理]]></title>
    <url>%2F2018%2F08%2F01%2FUE4%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[能够熟练的使用UE4中的异步处理应该能够很好的利用程序运行的资源，和计算。除此之外还有并行的处理。目的是要理清UE4中的线程的同步异步，并行操作和标准C++中的线程同步异步，并行操作。 时间有限，暂时记录下关键字： UE C++ ThreadPool 异步处理相关函数： Async Lambda记法 AsyncTask ParallelFor123//函数的位置Engine/Source/Runtme/Cre/Pblic/Async/Async.hEngine/Source/Runtme/Cre/Pblic/Async/ParallelFor.h 异步辅助API FScopeLock]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的C++]]></title>
    <url>%2F2018%2F08%2F01%2FUE4%E4%B8%AD%E7%9A%84C%2B%2B%2F</url>
    <content type="text"><![CDATA[UE C++拥有着自己的库，当然也可以使用C++的标准库(STL)，但是不同的地方还应该好好记载下来，同时也是对C++的一种复习。 值类型？指针？在标准C++中，类的声明可以12345ClassExample ObjName;/或者是ClassExample* ObjPtr; 而在UE4中为了统一值类型与指针的规则，想这种类的声明全部使用指针类型，不使用值类型。1UObject* o; UE4生成类对象实例(Instance)直接上例子：12345678//声明UMyClass* MyClass;//生成实例MyClass = NewObject&lt;UMyClass&gt;();//或者MyClass = NewObject&lt;UMyClass&gt;(Owner); Tips: 在构造函数中不能使用NewObject&lt;T&gt;生成其他的对实例。会使程序Crash。如果想生成其他的Object的话使用FObjectInitializer::CreateDefaultSubobject&lt;T&gt;函数 123ASomeActor::ASomeActor(const FObjectInitializer &amp; ObjectInitializer) : Super(ObjectInitializer)&#123; SampleActor = ObjectInitialize.CreateDefaultSubobject&lt;ASampleActor&gt;(this, TEXT("SampleActor"));&#125; Actor的实例化Actor的Component实例化从Content(Asset)中加载Object对象数据UE4中的容器]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的智能指针]]></title>
    <url>%2F2018%2F07%2F31%2FUE4%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[对于内存使用的了解，就不得不了解指针。UE4拥有跟C++类似的智能指针，在这里对虚幻4的智能指针库的内容进行一些总结跟提炼，同时也需要对C++的智能指针进行深入的了解。 UE4的智能指针智能指针并不能使用UPROPERTY()，TSharedRef,TSharedPtr,TWeakPtr等等。 参考链接： Unreal Smart Pointer Library C++的智能指针指针的使用伴随着内存泄漏(memory leak)的问题，可能会发生内存泄漏的情况有： new或者malloc出来的内存因为程序员的疏忽忘记释放 程序运行发生错误(throw)，未能执行内存释放程序 所以不是说只要程序员足够谨慎就能够避免指针造成的内存泄漏的问题。 C++11中的智能指针主要在用的智能指针有：unique_ptr, shared_ptr, weak_ptr。 这3种指针组件就是采用了boost里的智能指针方案。很多有用过boost智能指针的朋友，很容易地就能发现它们之间的关间：|std|boost|功能说明||—-|—-|—-||unique_ptr|scoped_ptr|独占指针对象，并保证指针所指对象生命周期与其一致||shared_ptr|shared_ptr|可共享指针对象，可以赋值给shared_ptr或weak_ptr。指针所指对象在所有的相关联的shared_ptr生命周期结束时结束，是强引用。||weak_ptr|weak_ptr|它不能决定所指对象的生命周期，引用所指对象时，需要lock()成shared_ptr才能使用。| 参考链接： C++11中的智能指针 三种智能指针的特性用法参考链接： C++11及C++14标准的智能指针 weak_ptrstd::weak_ptr是一个很好的解决悬空指针问题的方式。使用原生指针（raw pointers）的话不知道现在所引用的资源是否已经被释放。而使用std::shared_ptr来管理的话，std::weak_ptr只管使用，而不关心资源的使用情况，反正也不管理指向的资源。 因为本身std::weak_ptr并不能直接引用到对象，不会影响对象的自动释放，不会影响对象的引用计数，需要使用lock()来升级到std::shared_ptr来进行操作。 参考资料： C++ weak pointer When is std::weak_ptr useful? 比起直接使用new优先使用std::make_unique和std::make_shared参考链接： Item 21: 比起直接使用new优先使用std::make_unique和std::make_shared]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的函数回调实现]]></title>
    <url>%2F2018%2F07%2F31%2FUE4%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%9B%9E%E8%B0%83%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[回调函数的含义，实际上我也不太清楚，搜回调函数得到的关键字有很多：闭包，代理，委托，Wrapper，等等。但有一点我很清楚，这些我都不太懂。 说是在不同的语言中有不同的叫法。其本质上就是一个函数指针，而在汇编层面，就是子程序代码的首地址。每一段编译器先放一个占位符，最后放入实际的值。 上面的话是Unreal用到一些编程技巧里的内容。 UE4中的函数回调(CallBack)C++中应该有许多种方式的回调，UE C++(UnrealEngine中的C++)则是使用的DELEGATE和EVENT来实现。 关于UE C++的代理，存在着以下的几种方式： 静态的Single-cast Delegates Dynamic Single-cast Delegates 静态的Multi-cast Delegates Dynamic Multi-cast Delegates 这几种代理的实现有什么不同需要后续整理，可以参考： What difference betweens delegates? 有的时候需要很好的利用一下UE4的官方论坛，像是Stack Overflow一样。 Dynamic Multi-cast DelegatesDynamic Multi-cast Delegates是唯一的一种可以和UE4的Blueprint联动的代理实现方式。 Dynamic Multi-cast Delegates的UE C++中的声明12345678910//File: CallbackExample.h//Class: ACallbackExampleDECLARE_DYNAMIC_MULTICAST_DELEGATE(FZeroInputDelegate); //没有参数的声明方法UPROPERTY(BlueprintAssignable, Category="UE C++ Book") //BlueprintAssignable属性使得这个代理在Blueprint中也取得到。 -&gt;此处在真正的工程中不应该写注释，会出编译问题FZeroInputDelegate TheZeroInputDelegate;DECLEAR_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FTwoInputsDelegate, float, FloatVal, int32, IntVal); //两个参数的声明方法UPROPERTY(BlueprintAssignable, Category="UE C++ Book")FTwoInputsDelegate TheTwoInputsDelegate; Tips: 参数最大允许有8个。参数的声明类似上述两个参数的声明，先是类型后是参数名。 参数不同的代理声明只需要将上述的数字换成相应参数的英文就可以，比如说八个参数的情况声明代理的语句就会变成：DELEAR_DYNAMIC_MULTICAST_DELEGATE_EightParams 这样制作的代理，可以在UE的Blueprint中获得到这个代理（似乎是作为Event）并进行实现了。别忘了指定Event与Target。即把这个代理委托给一个类的实例(Instance)。在Blueprint中似乎是以Event而存在的，Blueprint中实现的操作是把这个调用的Event登录到这个代理上去。这样在UE C++中调用这个代理，也会调用Blueprint中的事件，执行这个事件的实现部分。 调用Blueprint中的代理实现1234567// File: CallbackExample.cpp// Class: ACallbackExampleauto ACallbackExample::ExecuteDelegate(const float FloatVal, const int32 IntVal) -&gt; void &#123; TheZeroInputDelegate.Broadcast(); TheTwoInputsDelegate.Broadcast(FloatVal, IntVal);&#125; 官方参考链接： Dynamic Delegates EventsBlueprint Event与Blueprint Function关于事件与函数的区别，没有返回值的被叫做事件，有返回值的叫做函数。是否真实需要验证。在UE C++中可以登录Blueprint的事件，通过给UPROPERTY宏添加属性来完成。话说回来这个是函数，应该使用UFUNCTION宏才对，不知道为什么书上这么说。 用于事件声明的属性有两种，区别的方式是是否在UE C++中有默认的实现。 BlueprintImplementableEvent:没有默认实现 BlueprintNativeEvent:拥有默认实现 Blueprint Event,Blueprint Function在UE C++中的声明12345678910111213141516// File: CallbackExample.h// Class: ACallbackExample// BP EventUFUNCTION(BlueprintImplementableEvent, Category="UE C++ Book")void FloatInputEvent(const float FloatVal);UFUNCTION(BlueprintNativeEvent, Category="UE C++ Book")void VectorInputEvent(const FVector&amp; VecValue);// BP FunctionUFUNCTION(BlueprintImplementableEvent, Category="UE C++ Book")float IntInputFunction(const int32 IntInput);UFUNCTION(BlueprintNativeEvent, Category="UE C++ Book")TArray&lt;float&gt; VecArrayInputFuncion(const TArray&lt;FVector&gt;&amp; VecValues); Event的默认实现12345678910111213141516// File: CallbackExample.cpp// Class: ACallbackExample//static FVector TheVector事先声明的属性auto ACallbackExample::VectorInputEvent_Implementation(const FVector&amp; VecValue)-&gt;void&#123; TheVector = VecValue;&#125;auto ACallbackExample::VecArrayInputFuncion_Implementation(const TArray&lt;FVector&gt;&amp; VecValues)-&gt; TArray&lt;float&gt;&#123; TArray&lt;float&gt; Result; for (const auto&amp; Val : VecValue) Result.Emplace(FVector::Dist(TheVector, Val)); return Result;&#125; 以上的代码实装完成之后，继承了上面的CallbackExample类的Blueprint就可以在Blueprint Editor中对上述UE C++中的事件与函数进行重写了。 以上，是对UE中的代理与事件，在可用范围内的总结与实现。但是对于在什么情况下使用这一点上仍然有许多疑问。 为什么要使用Delegate和Event？关于代理的实现，就算明白了也需要知道需要在什么情况下使用代理，否则没有意义。 关于Event在UE4中的Blueprint中应没有委托这一说，全部是以Event的名字来称呼的。 Delegate的使用情况推测1面向对象的说法只是一种理想的情况，总会有想要实现别人功能的情况。比如说ClassA想要实现一个功能，但是明显这个功能是由ClassB负责的部分，要是自己来实现的话不好，所以自己的话，声明一个Delegate，想用的时候就把这个广播出去(Broadcast)，实现了这接口的内容会被调用。 只言片语： 现在我要对一系列数据进行排序，而排序算法可能比较复杂，我不会自己写，我想调用Array.Sort方法，微软为我们提供了快速排序算法。但是这里有一个问题——我要实现自定义排序规则，比如对于字符串，默认的是按字母顺序，但现在我想这样排序： 按字符串长度排序，只有当长度不同时，再按字母排序。 显然，微软不可能提供这样“个性”的排序方法，那是不是说，就必须让我们自己去写快速排序算法呢？不需要！我们只需要使用委托，就能实现这个要求：string[]strs=”I like C# very much”.Split();Array.Sort(strs,Rule);int void Rule(string first,string second){return first.Length==second.Length?first.CompareTo(second):first.Length.CompareTo(second.Length);} 显然，我并不需要知道快速排序算法的逻辑，我只需要告之排序规则，就实现了我的个性排序。 试问：如果没有委托，你如何解决这个问题？ C++中的代理实现代理应该涉及了许多知识，完全理解需要后续的更新整理。 参考链接： C++中实现委托（Delegate） C++实现Delegate Event实例(例子、example、sample) C++委托实现(函数指针，function+bind，委托模式) 高效C++委托的原理]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGl学习内容整理]]></title>
    <url>%2F2018%2F07%2F25%2FOpenGl%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[主要是记录自己学习OpenGl内容。 OpenGL学习网站参考： Learn OpenGL Learn OpenGL中文翻译]]></content>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UnrealEngine着色器开发整理]]></title>
    <url>%2F2018%2F07%2F25%2FUnrealEngine%E7%9D%80%E8%89%B2%E5%99%A8%E5%BC%80%E5%8F%91%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[整理自己在学习Unreal Engine 4着色器过程中遇到的问题和知识点。 Unreal Engine 4设定1. UE4的内置材质Shader函数库位置UE4Shader的编写入门反而相对比较容易，使用自带的各种函数库拉拉线竟然就可以完成。函数库的位置都在: 位置： C:\Program Files\Epic Games\UE_4.19\Engine\Shaders\Private UE4的安装文件夹中 2. Material.cpp文件位置 C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Private\Materials]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的粒子特效]]></title>
    <url>%2F2018%2F07%2F24%2FUE4%E4%B8%AD%E7%9A%84%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[主要是用来记录学习虚幻引擎4的粒子的过程 Particles with Unreal Engine 4先是在UE4提供的官方教程中整理基础的知识点。官方Youtube视频。 Particle Particle Particle System Emitter Actor Particle System Component Cascade Emitter Emitter Module tips: 在Emitter(粒子发射器)的各个Module中，按住alt键拖动可以复制Module 按住shift可以共享Module，即只需要修改一个其他的都会被修改 Type Data Distributions]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Particles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于学习UE4的粒子系统过程中遇到的疑问]]></title>
    <url>%2F2018%2F07%2F20%2F%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0UE4%E7%9A%84%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E7%96%91%E9%97%AE%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[记录刚学UE的一些疑问]]></title>
    <url>%2F2018%2F07%2F18%2F%E8%AE%B0%E5%BD%95%E5%88%9A%E5%AD%A6UE%E7%9A%84%E4%B8%80%E4%BA%9B%E7%96%91%E9%97%AE%2F</url>
    <content type="text"><![CDATA[为了记录自己在学习UE引擎过程中遇到的一些疑问点。时间长了之后就会习惯，这是真的。但是为了避免忘记，记在某个位置是最好的。每个小的知识点写成一篇文章的话总觉得很乱。 C++与C#的不同之处时隔多年见到C++的第一个违和感是头文件，为什么需要写头文件这个问题我找了一些别人写的代码发现了一下几个规则： 在C++的头文件中SampleCode.h中一般都会预先定义一些东西 需要包含的其他头文件 123#include "Engine.h"#include "MyAppUtilities.h"... 定义需要使用的宏 预处理（C++的预处理器需要了解一下） 123//一般常量居多？#define PI 3.1415926... 定义类，类中包含该有的成员， 123456789class SampleClass&#123; //Attributes or functions public: protected: private:&#125; UE4中的C++不同的地方1.UCLASS()宏想要让类与UE4的类库联动的话，就需要这个宏。 UCLASS()大概的使用方法Sample Code:12345678910111213141516171819202122#include "Engine.h" //如果需要使用UE的library的话#include "MyAppUtilities.h"UCLASS()class UMyClass : public UObject&#123; GENERATED_BODY() public: //构造函数(公有的？) UMyClass(); UPROPERTY(BlueprintReadWrite, Category = "MyApp") int32 IntProp; UFUNCTION(BlueprintCallable, Category = "MyApp") float LengthOfSomething(const int32 index); private: TArray&lt;int&gt; IntArrayWork; //标准c++中的数组声明 //std::vector&lt;int&gt; IntArrayWork;&#125; 对于UCLASS()，如果需要继承UE的类库，则都要加上这个。最好声明的类名也以U开头为好？ 但是我觉得这种声明不是跟UE的类库搞混了吗，辨识度低我觉得应该没有这么智障的规则。好的，有这种规则好像。类似的其他的以E,F,I,T,S等等的字母作为变量名的开始。 关于在头文件中添加注释的问题，在UE4的执行中倘若添加了日语(应该中文也一样)的注释，有可能会发生问题。所以在头文件中尽可能的使用英文注释。还有应该避免在各种宏的后面直接追加注释。 就目前的问题来说在UFUNCTION宏的后面直接加入日文注释(UTF-8)的话，会有编译无法通过的问题。所以为了避免上述问题应该尽量： 头文件中使用英文注释 不要直接在各种UE4的宏后面(例如UFUNCTION后)直接添加注释。 UCLASS() 参数的含义CPPExampleActor.h123456789101112131415161718192021#pragma once#include "GameFramework/Actor.h"#include "CppExampleStruct.h"#include "CppExampleEnum.h"#include "CpExampleActor.generated.h"UCLASS(BlueprintType)class ACppExampleActor : public AActor&#123; GENERATED_BODY()public: UPROPERTY(BlueprintReadWrite, EdtAnywhere, Category="UE C++ Book") FCppExampleStruct MyStructProp; UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="UE C++ Book") ECppExampleEnum Type; UFUNCTION(BlueprintCallable, Category="UE C++ Book") float MyActorFunc(const float Input);&#125;; 通过指定UNCLASS()的参数，可以指定类的类型。 BlueprintType表示这个类可以作为Blueprint的变量来使用。 UPROPERTY()的声明，在这个Actor的Detail面板上可以看到该Category下有声明的MyStructProp和Type属性。 具体的BlueprintType的使用例子则仍需要调查。BlueprintType类型能做到的事情。 多个参数 1UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) ) 这个的使用含义现在还不清楚各自代表着什么意思。 USTRUCT()结构体CppExampleStruct.h1234567891011121314#pragma once#include "CppExampleStruct.generated.h"USTRUCT(BlueprintType)struct FCppExampleStruct &#123; GENERATED_BODY() UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="UE C++ Book") float Value; UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="UE C++ Book") int32 Index;&#125;; 构造体的声明名字最好以F开始。其他的基本上使用方法与类相同。 UENUM()枚举类型CppExampleEnum.h12345678#pragma onceUENUM(BlueprintType)enum class ECppExampleEnum : uint8 &#123; None = 0, Foo, Bar&#125;; 对于enum class ECppExampleEnum : uint8这种写法有些迷惑。 class是为了使枚举类型更安全。为什么安全，参考下面的链接。之后整理。 uint8是为了指定枚举器的基础类型。 参考链接: C++11的enum class &amp; enum struct和enum C\C++中的整形提升 C++标准文档-n2347 2.GENERAED_BODY()这一句话必须要写的原因需要调查 3.UPROPERTY() UFUNCTION()使用这个声明的属性跟方法UE的Blueprint可以使用。 UPROPERTY()宏UPROPERTY()的参数的含义 UPROPERTY()没有参数的情况，UE4的Blueprint和Level Editor都不能读取或者修改，但是却可以将这个变量纳入到UE4的GC对象中。比如： 12UPROPERTY()AActor* OwningActor; 这种情况，如果OwningActor拥有了实例化对象，不手动释放也是没有问题的。或者说注意别手动释放了，会出问题的。 UPROPERTY(EditAnywhere, Category=&quot;UE C++ Book&quot;,EditAnywhere属性表示在Level Editor中也可以操作这个属性。 那么Blueprint与Level Editor的差别在哪里，需要调查。 猜测的结果，Blueprint就是那个连来连去的蓝图，可以在那个蓝图的编辑器中取到属性。 Level Editor指的是操作的画面，在Level Editor中可以取到的意思应该是在Detail panel中直接设定或者读取值那样。 UPROPERTY(BlueprintReadWrite, Category=&quot;UE C++ Book&quot;),BlueprintReadWrite表示Blueprint可以读写。 其他的属性，还有meta属性可以查找下面的链接： Property Specifiers Metadata SpecifiersUFUNCTION宏12UFUNCTION(BlueprintCallable,Category = "UE C++")static float FunctionName(const float Variable); 像上面的使用方法，在函数的前面添加UNFUNCTION macro宏可以制作UE4的Blueprint编辑器的函数节点以供调用。在虚幻4的Blueprint编辑器中使用此函数。 4.TArray-UE4中的数组（重要）先上本家，官方文档TArray:Arrays in Unreal Engine。 再上中文翻译虚幻引擎中的数组–TArry:Arrays 5.C++中的静态函数static与UE C++(Unreal Engine C++)的静态函数在C++中的静态函数与非静态函数的执行确实是有差别的。 复习一下C++中的静态函数： static修饰变量 static修饰函数参考文章： C/C++ 中的static关键字 存储类 (C++) C++静态成员函数 C++ static静态成员变量 UE C++中关于静态函数的使用应该大同小异，但是也不排除有差别的可能性。 将来可能会派上用场的文章 クラスにスタティック変数を持たせたい 6.Blueprint函数node(节点)的输入与输出在UE C++中函数的参数对应Blueprint的node的输入pin，函数的返回值则对应着node的输出pin12UFUNCTION(BlueprintCallable,Category="classcategory")bool MyFunc(const int a,int b,const int&amp; c,int&amp; d) 上述的情况下a,b,c三个变量对应着node的三个输入pin，但是return value,d对应着node的输出pin。也就是说：没有const修饰的引用型参数会被分配到输出pin的阵营中。 这里便引申出几个问题 UE C++的函数参数为什么要使用const修饰，使用常量的必要性是什么 万一想要使用const修饰的引用型参数作为node的输入pin怎么办 想要增加node的输出pin的话，除此之外还有别的写法么 Blueprint支持的数据类型很有限 bool uint8 int32 float 7.UE4的Head FileUE4中的头文件有许多中，为了能够分清使用方法把遇到的头文件整理一下 Actor.h一般的写法是1#include "GameFramework/Actor.h" 一般是继承了UE4中的Actor类的话都需要包含这个头文件。 xxx.generated.h比如说1#include "CppGate.generated.h" 这个头文件是有UE4的UnrealHeaderTool自动生成的文件。如果类继承了UObject类并且想要在Blueprint中使用这个类的话，就需要include这个头文件。而且需要把这个头文件放到所有的头文件的最后才行。 8.UE4中的特殊容器1.FVector一个表示3D空间的向量。可以用来表示空间的一个点或者方向。 参考链接： FVector 9.类的初始值设定基础类型变量的初始化可以在声明的同时进行，以外的数据类型(FVector等)初始化需要在构造函数中进行。静态变量的初始化则需要在类外进行。123int ClassExample::static_var; //equle 0//or lik thisint ClassExample::static_var = 4; #pragma once vs include guard打开UE工程看到一些.h头文件的源码的时候看到了#pragma once有些困惑，不知道是做什么用的。于是调查了一下。 总体来说这两个命令都是为了避免同一个头文件被include多次 方式1：1234#ifndef __SOMEFILE_H_#define __SOMEFILE_H_...#endif 方式2：12#pragma once... #ifndef方式这种方式受C/C++语言标准支持，可以保证同一个文件不会被同时包含，也能保证内容完全相同的两个文件（或者代码片段）不会被同时包含。缺点是不同头文件中的宏的名字如果相同，会导致编译器找不到声明的问题。另外由于编译器每次需要打开头文件来判定是否有重复的定义，会导致编译的时间要长。 #progma once方式这种方式是保证“物理存在上”同一个文件不会被包含多次。而不是内容相同的两个文件。而且无法对一个头文件中一段代码做pragma once声明，只能针对文件。当然也不会发生第一种方式的宏名碰撞引发的问题。 使用哪一种方式见仁见智，有好处有坏处。根据情况使用。 附上别人的博客链接: #pragma once与#ifndef解析 时间线比较新的分析: インクルードガードとpragma once stackoverflow上关于上述两种方式的争论: #pragma once vs include guards? C++中的类与结构体参考链接： 详解C结构体、C++结构体 和 C++类的区别 开启HSLS语法高亮HLSL Tools for Visual Studio应该是HLSL的语法编辑器插件，有自动补全的功能，附上下载链接。但是并没有解语法高亮的问题。 下载链接： HLSL Tools for Visual Studio 在VS2017中开启语法高亮（syntax high lighting）虽然不是针对VS2017的解决方案，但是设定之后的确解决的这个问题： 设定顺序： 在VS2017中 Go to Tools -&gt; Options -&gt; Text Editor -&gt; Fie Extension 在这里选择编辑文件的扩展名与文法编辑器，然后添加保存。 这样设定应该里面有效果了。 参考链接： How to get syntax highlighting for alternate file extension for Visual Studio 2010 or 2013? UE4中使用的一些Tip1. 快速制作封闭空间快速挖空一个几何体的制作顺序： Modes panel -&gt; Geometry -&gt; Box -&gt; 设置尺寸 Details panel -&gt; Brush settings -&gt; Hollow 属性check 2.调整模型的模型坐标的原点根据模型的大小来调整模型坐标的原点，顺序： 双击UE4中导入的模型，打开材质编辑器(static mesh editor也叫Material Editor) 点击Show Pivot显示模型坐标，同时在左上角看见，模型的大小 在Detail panel中找到Transform，调整Import Tansiation的数值，移动坐标系 Tool bar -&gt; Asset -&gt; Reimport Model 之后就会发现模型坐标按照指示移动了 3.制作天空球(与雾)感觉要制作出天空的感觉同时还有雾的模糊的时候使用，可以看见太阳就是不知道能否模拟太阳的移动 顺序: 选定平行光源，开启Light -&gt; Atmosphere/Sun light 将Visual Effects -&gt; Atmospheric Fog 拖拽至场景中 Content Browser panel右下的View Options中开启Show Engine Content 在Engine Content中找到BP_Sky_Sphere并将其拖拽至场景中 在BP_Sky_Sphere的Details面板中的Directional Light Actor选定上面的平行光 4.UE4中的Volume应用在UE中使用Volume执行不同的任务可以解决很多问题，比如说： 给玩施加伤害 改变物理定律，在Volume中允许玩家悬浮等等 作为碰撞表面，不允许玩家进入 改变计算关卡光照和可见性方式 等等，出了直接使用Modes panel中的Volume工具之外，也可以直接将几何体笔刷(brush)转化为相应的Volume。Details -&gt; Actor -&gt; Convert Actor -&gt; Volume(that you want) 参考资料： Volume Reference 5.Z-FightingZ-Fighting又Depth Fighting，深冲突。就是贴图会出现闪烁的情况，与实际模型产生交叉融合 z-fighting的出现是的不同面上的像素在z-buffer中的值相近，导致前台取像素的时候一会去这个面的，一会取那个面的。改变照相机的near、far属性会涉及到z-buffer中的值的精度。因为在各个平台上z-buffer位数不同，因此改变near和far能给z-buffer中的值的浮点数部分尽量留出空间，消除z-fighting。 参考： z-fighting在unity中的解决方式 6.将选定的Actor合并为组使用Ctrl+G的快捷键可以快速把选定的Actor(场景的素材)合并为一组，下次选定的时候会选定为一组。便于移动或者复制。 使用Shift+G的快捷键会解除分组。当然这些操作都可以在选中Actor之后: Right Click -&gt; Group进行分组和分解 7.UE4中的Material和Material Function在UE4中偶然看到了这两个材质的声明，发现名字不太一样，需要调查一下。 UE C++中的需要注意的问题1.ConstructorHelpers类的使用就我的理解这个类可以在其他类的构造函数中实例化对象。自己的情况中多为获取在工程中的资源，并不是level中的Actor资源而是单纯的Content文件夹中的某个资源。123456789// 使用实例// SampleActorComponent.cpp中的构造函数USampleActorComponent::USampleActorComponent()&#123; PrimaryComponnetTick.bCanEverTick = true; static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; SampleAsset(TEXT("StaticMesh'/Game/StartrContent/Shapes/Shape_Plane.Shape_Plane'")); sample_mesh = SampleAsset.Object;&#125; 这样就能成功取到Content中的资源，当然不限于StaticMesh其他的类型UMaterial等等的类型都可以取到。需要注意的是 ConstructorHelpers类的使用必须是要在类的构造函数中进行（吃了不少苦头） SampleAsset的资源链接可以直接在UE4的Content文件夹右键资源copy reference中直接取到 关于更多的使用应该在另一篇博文中有拓展。 2.在C++类中为类添加用户输入响应在网上搜了一下如何给一个脚本添加键盘输入事件，也不是那么全，有价值的一个提问是这个 Check Keyboard Event in code 但是试了一下并不好用，就自己的理解来说，基本上想要键盘的输入的事件响应的基本上都应该去继承UE4的PawnActor类去了，而我自己就是想用键盘来调试而已。继承的类是ActorComponent，并不能实现他们的代码。后来找了一找还是有实现方法的。 首先要去UE4的Editor中的Project Settings中的input选项中将自己想要绑定的键位命名并登录。我起的名字就是PressedF等等。 然后就是在c++中实现绑定了：12345678910111213141516171819202122232425262728293031323334// SampleActorComponent.cppvoid USampleActorComponent::BeginPlay()&#123; // 因为要绑定一下键位的事件，所以需要在这里写 this-&gt;GetOwner()-&gt;EnableInput(this-&gt;GetWorld()-&gt;GetFirstPlayerController()); UInputComponent * myInputComp = this-&gt;GetOwner()-&gt;InputComponent; if(myInputComp) // check(myInputComp) &#123; SetupMyPlayerInput(myInputComponent); &#125;&#125;void USampeActorComponent::SetupMyPlayerInput(UInputComponent * myInputComponent)&#123; myInputComponent-&gt;BindAction("PressedF", IE_Pressed, this, &amp;USampleActorComponent::PressedMethod);&#125;void USampleActorComponent::PressedMethod()&#123; // 这里是按下键盘键位之后的动作内容&#125;// SampleActorCompoennt.hclass USampleActorComponent : public UActorComponent&#123; GENERATED_BODY()public: UFUNCTINN(BlueprintCallable, Category = "MyUE4Class") void PressedMethod(); // 这个在头文件的声明一定要使用UFUNCTION宏来修饰否则没有作用 void SetupMyPlayerInput(UInputComponent * myInputComponent);&#125; 完整的使用方法大概就是这样，应该有一篇文章介绍的很详细的但是关掉了页面不太好找了。 3.像Unity一样保存场景中的参照在Unity中把scene中的参照直接拖进脚本的声明公共变量以达到快速参照的目的，在UE4中也有类似的用法。123456789class USampleClass : public UActorComponent&#123; GENERATED_BODY()public: USampleClass(); UPROPERTY(EditAnywhere, Category = "Edit") AActor * targrtActor;&#125; 为属性添加UPROPERTY()宏让变量暴露给编辑器，然后在该脚本的Detail面板上wei该变量找到场景中的Actor参照。虽然不能拖拽了。 4.获取Actor上的Component不知道是不是UE4中获取Actor上的组件就这么麻烦还是我没找到，组件的获取并不是那么单纯的事情。12345// 获取名为targetActor身上的脚本组件（TArray&lt;USampleActorComponent*&gt; Comps;targetActor_p-&gt;GetComponents&lt;USampleActorComponent&gt;(Comps);// 这样Comps[0]的内容应该就是想要的组件的参照了 5.在UEC++中实现代理我在现实中都没怎么用到过得代理，我竟然一次用了这么多。在UE4中代理的制作感觉好简单好方便。之前有一个是在C++中声明代理，但是实现是在蓝图中的，叫Multi-Cast-Delegate好像。这次完全是在C++中声明在C++中实现代理。 再来复述一下代理的情况：一个类想要做一件事儿，但是这件事跟这个类的关系是只想知道这件事做了而已，具体做的内容完全不关心，这件事情的实现是另一个类的分工。这个时候只要在自己的类里面声明一个代理，当想要执行的时候通知那个类就行。就像是事件一样。 1.定义代理类型在UE4中引擎为我们做了大部分，而我们只要用就可以了。首先定义代理的类型。1234567891011#include "CoreMinimal.h"#include "SampleDelegateComponent.h" // 我们需要委托的类头文件声明#include "SampleActoomponent.generated.h" // 这个头文件是自动生成的，没有的话要手动补上去就是自己的文件名加上.generated.h，而且这个声明必须要在所有的声明的最后。原因不清楚DECLARE_DELEGATE(SampleDelegate)UCLASS()class USampleActorComponnet : UActorComponent&#123; // Class Contents&#125; 这样我们便声明了一个类型为SampleDelegate的代理了。 2.声明代理12// 在USampleActorComponent中的声明这个该类型的代理变量SampleDelegate sample_delegate; 3.绑定代理用上一条的方法获取到level中的Actor的参照，然后将代理绑定到这个想要代为我们执行的实例上去。123456789// 取得需要绑定的实例参照if(targetActor)&#123; // 获取到实例身上的脚本组件 TArray&lt;USampleDelegateComponent*&gt; Comps; targetActor-&gt;GetComponents&lt;USampleDelegateComponent&gt;(Comps); // 绑定代理 sample_delegate.BindUObject(Comp[0], &amp;USampleDelegateComponent::MethodWanted);&#125; 4.代理执行剩下的就是在想要的时候执行代理就好了。1sample_delegate.Execute(); 6.动态加载资源关于动态加载资源又是能说一箩筐的话题，这次只记录自己用到的。1UTexture2D * sampleTex = LoadObject&lt;UTexture2D&gt;(NULL, TEXT("Texture2D'/Game/Path..'"), NULL, LOAD_None, NULL); 参数啥的也不太清楚，用的时候按照这个方向查吧。之后的关于如何从零开始制作烟雾特效的教程里应该会出现。 7.动态改变物体材质参数关于UE4的材质，有好多的话要说，关于如何动态的改变一个物体材质的问题要是不是自己非要用C++写蓝图，估计也不会钻研的那么深。 首先是要动态的改变一个材质里面的参数需要我们创建一个动态的材质。也就是说我们需要得到场景中的物体的材质的实例参照，然后以这个参照为模板创建一个动态材质，再把这个修改了的动态材质赋给物体。 老规矩，上代码： .h文件1234// Class内，省略大部分框架代码// 头文件中声明材质UMaterial * target_material;UMaterialInstanceDynamic * target_material_dynamic; .cpp文件12345678910111213141516171819202122232425262728// 构造函数中使用ConstructorHelpers获取到物体的材质static ConstructorHelpers::FObjectFinder&lt;UMaterial&gt; targetMT(TEXT("PATH"));target_material = targetMT.Object;// 随后可以在BeginPlay函数中对动态材质进行初始化target_material_dynamic = UMaterialInstanceDynamic::Create(target_material, this-&gt;GetWorld());// 可以为材质中的变量赋值target_material_dynamic-&gt;SetScalarParameterValue("MaterialParaName",10);// 拓展复习~// 获取一个UStaticMesh上的组件的材质TArray&lt;UStaticMeshComponent*&gt;comps;this-&gt;GetOwner()-&gt;GetComponnets&lt;UStaticMeshComponent&gt;(comps);target_material = (UMaterial*)comps[0]-&gt;GetMaterial(0) // 指针类型强制转换这一步很重要// 更新材质结束之后要赋给物体mesh_comp = comps[0]mesh_comp-&gt;SetMaterial(0, target_material_dynamic);// 下面的是比较重要的一步// 在BeginPlay中实例化动态材质之后需要target_material_dynamic-&gt;AddToRoot();// 完后再EndPlay中将动态材质移除target_material_dynamic-&gt;RemoveFromRoot(); 这个也是吃了苦头的，因为自己非要用C++写，不用蓝图，这东西谁都不会告诉我啊。AddToRoot这个操作让UE的GC不会把我们创建的动态材质给回收掉。而使用的AddToRoot的东西在结束或者不想用的时候RemoveFromRoot，以便回收。哎呀没加的时候UE4崩的不要不要的。 8.UE_LOG输出奇奇怪怪的数据类型总是想输出些什么。使用UE_LOG可以在UE4的Editor输出运行的信息。但是C++嘛，你让它输出FString类型的东西，他不认识就不输出这个时候就像下面这样：1UE_LOG(LogTemp, Log, TEXT("output message %s"), *(FDateTime::Now().ToString())); 使用指针强制转换，我也不知道是个什么原理。 9.FTimerManager定时器定时器是个好东西。但是要怎么用呢？ 首先要获取到这个定时器，在世界中有这么一个定时器：12// 为什么要加 &amp; ，引用的作用应该就是我不知道，不加就报错。我也不知道我是怎么灵机一动加上就好用的。FTimeManager &amp;timer = this-&gt;GetOwner()-&gt;GetWorldTimerManager(); 然后声明一个Handle12// 在.h文件中声明一个Timer Handle供我们使用，一个Handle就是一个定时的名字应该FTimerHandle timer_handle; 最后开始定时：1timer.SetTimer(timer_handle, this, &amp;USampleActorComponent::TimerMethodWnted, 1.0, false); 参数的意思应该一目了然了。 道听途说1.关于C++中的资源释放一般在c++中应该是资源的获取与申请（new等等的操作）与资源的释放都是需要程序员手动操作的。但是如果使用了UE管理的资源，比如继承了UE中的类库等等的操作，那么释放这些资源的操作，在UE中会自动释放而不需要程序员的额外操作，反而要是操作了还会出问题。 当然这个问题只是道听途说，未能够验证。 当然需要仔细调查了啊 2.关于UE中UObject的派生对象的垃圾回收问题如果一个UObject的派生类对象中有一个UObject的派生类对象的指针变量，当这个指针变量经过NewObject&lt;&gt;()的操作实例化了之后，这个实例化对象就成为了GC对象（garbage collection）,但是仅仅如此还不足以达到自动回收的目的，像下面这样在声明之前加上UPROPERTY()宏，就不需要显式的delete垃圾回收了。12UPROPERTY()UObject* MyObjectReference; 总结来说，在C++中使用了new等等的方式来申请了一部分空间的话在使用结束的时候需要显式的释放掉，否则的话就会造成内存泄漏。然而上述的使用方式会使得这样声明的实例对象能够得到的资源自动回收。 参考来源: [Question]UObject Pointer References 关于C++好像发现了一个不得了的链接貌似可以在这个链接中找到C++的标准文档，英文文档。 Open Standards]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#中的单例模式-SingletonPattern]]></title>
    <url>%2F2018%2F07%2F15%2FC%23%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-SingletonPattern%2F</url>
    <content type="text"><![CDATA[这次来整理一下C的单例模式，参考的文章是Implementing the Singleton Pattern in C#。 曾经在做一个数据库管理类中经常多次使用了一个数据库管理的实例类对象，每次在新的不相关的类中需要使用数据库操作的时候都重新实例化一个数据库管理类对象，久而久之就觉得有些麻烦。便决定使用单例模式来管理，同时深究一下单例模式与C#中的使用。 算是这篇文章的汉化与总结吧。 –未完–]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Semaphore-信号量]]></title>
    <url>%2F2018%2F06%2F28%2FSemaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Semaphore,中文叫信号量，日语叫セマフォ（= .=）。经常会在多线程的编程中用到。信号量说简单点就是为了线程同步，或者说是为了限制线程能运行的数量。 仔细说明一下就是，信号量会在内部维护一个计数器，当一个线程调用了这个信号量，计数器就会减1，直到计数器减为0，调用这个信号量的线程将会被阻塞，直到有别的线程释放掉一个信号量使其计数器加1。 那么问题就来了，这个信号量维护的这个计数器应该是对线程的死锁有所防护的，也就是说同一时间只有一个线程能过获取这个信号量，而且当线程获取信号量的时候对信号量中的计数器进行减操作是具有原子性的操作。对于这个计数器的保存位置应该深入调查一下。 实例代码：12345678910111213141516171819202122232425262728293031323334353637383940414243using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading;namespace Semaphore1&#123; class Program &#123; //我设置一个最大允许5个线程允许的信号量 //并将它的计数器的初始值设为0 //这就是说除了调用该信号量的线程都将被阻塞 static Semaphore semaphore = new Semaphore(0, 5); static void Main(string[] args) &#123; for (int i = 1; i &lt;= 5; i++) &#123; Thread thread = new Thread(new ParameterizedThreadStart(work)); thread.Start(i); &#125; Thread.Sleep(1000); Console.WriteLine(&quot;Main thread over!&quot;); //释放信号量，将初始值设回5，你可以将 //将这个函数看成你给它传的是多少值，计数器 //就会加多少回去，Release()相当于是Release(1) semaphore.Release(5); &#125; static void work(object obj) &#123; semaphore.WaitOne(); Console.WriteLine(&quot;Thread &#123;0&#125; start!&quot;,obj); semaphore.Release(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS真机安装Build出错]]></title>
    <url>%2F2018%2F06%2F08%2FiOS%E7%9C%9F%E6%9C%BA%E5%AE%89%E8%A3%85Build%E5%87%BA%E9%94%99%2F</url>
    <content type="text"><![CDATA[为了面试，需要用尽一切手段了，把自己的毕业设计的时候做的2D游戏也拿出来了（捂脸）。找到了自己之前保存好的已经编译好的安装包，希望能够平安无事的安装到自己的系统高版本的iPhone7上。但是再次编译的时候果不其然还是要报错。1'__declspec' attributes are not enabled; use '-fdeclspec' or '-fms-extensions' to enable support for __declspec attributes 但是无论是Xcode还是Unity都已经升级的面目全非了，打开以前保存的Unity工程果不其然各种报错。想要解决出现的问题，第一个是NGUI的版本问题，代码中出现的一部分说是已经不支持Unity5.4+了…上网搜了一下，结果没有找到任何解答。 第一下就碰壁，只能再回去找已经编译好的文件的Build错误了。 问题解决继续搜关键词，看到了Unity社区中有一个这个提问：Error “unknown type name __declspec” after Xcode 7.3 upgrade 出问题的代码部分跟我的是一样的:1234567NORETURN static void il2cpp_codegen_raise_exception (Il2CppCodeGenException *ex)&#123; il2cpp::vm::Exception::Raise ((Il2CppException*)ex);#if __has_builtin(__builtin_unreachable) __builtin_unreachable();#endif&#125; 当然我是根本不知道这几行代码到底是干什么的。但是就是出错了…继续往下看，好像看到了一个解决方案: It has helped me: 1) Remove ‘NORETURN’2) Clean build3) Build it Like a hack:) XCode7.3, Unity5.2.2 UPD: XCode7.3, Unity5.3.4f1 - no issue 跟我的情况太像了，抱着试一试的态度，然后…Build通过了，游戏也成功的安装到了我的手机上了。 で？这个NORETURN到底是个什么？ 查了一下发现这个属性不光是Swift中的，C++中也有。所以说我已经厌倦了什么都学，什么都学对自己来说就是什么都学不会。自己之前一段时间看了Swift然后又去干别的，妥妥的全部忘光。 noreturn in Swiftnoreturn是一种属性，被这个属性修饰的函数表示没有任何返回值，函数可以被重写，但是重写之后也必须没有返回值。 具有代表性的函数有：exit(),abort()等等。 这里有一篇介绍Swift的Attributes的文章Swift - Attributes(@attribute) について 【編集中】介绍了Swift中的修饰属性。 noreturn in C++相比之下我更在意noreturn在C++中的作用。试着查了一下What is the point of noreturn? 字面意思看起来是:不返回函数的结果，没有返回值。但实际上跟void funtion还是有很大的区别。 void function运行会返回调用函数，只不过没有返回值。 被noreturn修饰的函数在运行结束之后并不会返回调用函数。 12345678910[[ noreturn ]] void f() &#123; throw "error"; // OK&#125;void g() &#123; f(); // unreachable: 在调用了`f()`之后，下面的代码永远不会执行 std::cout &lt;&lt; "No! That's impossible" &lt;&lt; std::endl;&#125; 别的事情不说，每次发现这种有关语言的语法的地方不明白的时候，就觉得特别打脸。]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>Bugs</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zsh找不到gulp工具包]]></title>
    <url>%2F2018%2F05%2F30%2Fzsh%E6%89%BE%E4%B8%8D%E5%88%B0gulp%E5%B7%A5%E5%85%B7%E5%8C%85%2F</url>
    <content type="text"><![CDATA[不能上网，一上网问题就接踵而来。今天突然看到了hexo博文压缩这个功能，就想着这个可以有，就按照教程安装了gult。安装完运行hexo g &amp;&amp; gulp之后准备舒舒服服的打包的时候，我一向视同己出的zsh弹出来了这个提示1zsh: command not found: gulp 刚装的你跟我说找不到？我信了你的邪。 自己解决应该是有点难度了，只能借用大家的智慧了。在网上搜到了这两篇博文COMMAND NOT FOUNDWITH A NODE MODULE (NPM) SOLUTION与【gulp】zsh: command not found: gulp!!!「急にgulpが壊れた!」と思ったら読む記事完美的解决了我的问题。 原因可以从下面的命令中看出来 1234➜ blog npm root/Users/stone/Documents/mynote/BLOG/blog/node_modules➜ blog npm root -g/Users/stone/node_modules gulp被安装到了个人文件夹中去而不是NPM命令的全局文件夹。 解决办法是运行下面的命令1npm config set prefix /usr/local 再运行一次npm root -g应该就会看到执行后的结果变化12➜ blog npm root -g/usr/local/lib/node_modules 然后再次安装gulp，应该是全局的安装1npm i -g gulp 确认gulp的版本123➜ blog gulp -v[23:25:50] CLI version 3.9.1[23:25:50] Local version 3.9.1 出现了一个CLI版本跟一个本地的版本。嘛，反正是好用了。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown文件转换为PDF文件]]></title>
    <url>%2F2018%2F05%2F29%2FMarkdown%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E4%B8%BAPDF%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近闲来无事(实际上由于跳槽面试的原因忙的要死)，在知乎上看到了一篇搭建博客的文章，看了一眼发现对于我这种WEB盲还挺友好，于是就自己搭建了这个博客。 就在ZH上捞鱼捞的正爽的时候，面试(未)公司发来了要看看我的作品的消息。我一看表现的时候到了，就掏出我刚学的Markdown来写了几篇我的作品的说明文。正当我想把刚build好的html文件打包压缩发送过去的时候，(自动脑补柯南的灵光一闪音效)我发觉事情并不是这么简单。 要是我作死直接发了一堆html过去，估计就别想见到人家了，就算见到了人家公司的HR，估计见面也有不小的概率会被锤。这个时候慌乱的我,手不由自主的打开了谷歌并输入了:How to convert markdown to pdf.然后发现正确的提问用法是:How to convert from markdown to pdf. (；´∀｀)嘛，英语不好这得批评，早晚得去考一次托福… 搜到的第一个是说用谷歌上的插件:Markdown Preview Plus - Chrome Webstore.ドラッグアンドドロップ就可以转换了。什么？ドラ…什么的，打开谷歌翻译:drag and drop.我… 但是利用网上的插件总感觉有些难受，还要上传文件什么的，万一上传到人家服务器上被人家看到了里面的内容就不好了(WEB盲)。于是看到了第二个方法：使用Node.js的工具markdown-pdf 1npm -g install markdown-pdf 安装好工具之后 1markdown-pdf 我的说明文.md 就能生成想要的PDF文件了。浏览生成的PDF文件的时候唯一在意的就是Markdown给隐藏起来的URL链接PDF文件也一并显示了出来。难不成是制作人有意这样，亦或者是机关在作祟，我就暂时不得而知了。因为现在的我得等人家的面试通知。 唉…寝よう]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Markdown</tag>
        <tag>碎碎念</tag>
      </tags>
  </entry>
</search>
