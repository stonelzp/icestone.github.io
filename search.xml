<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++编程思想-第一卷-第十五章-多态性和虚函数]]></title>
    <url>%2F2019%2F04%2F24%2FC%2B%2B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC%E4%B8%80%E5%8D%B7-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E5%A4%9A%E6%80%81%E6%80%A7%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[多态性（在C++中通过虚函数来实现）是面向对象程序设计中数据抽象和继承之外的第三个基本特征。 多态性和虚函数15.1 C++程序员的演变虚函数增强了类型概念，而不是只在结构内部隐蔽的封装代码，所以毫无疑问，对于新的C++程序员来说，这些概念是最困难的。然而它们是理解面向对象程序设计的转折点。如果不用虚函数，就等于还不懂得面向对象程序设计（OOP）。 15.2 向上类型转换在第14章中，我们已经看到对象如何能作为它自己的类或作为它的基类的对象使用。另外，还能通过基类的地址操作它。取一个对象的地址（指针或者引用），并将其作为基类的地址来处理，这被称为向上类型转换（upcasting），因为继承树的绘制方式是以基类为顶点的。 15.3 捆绑（binding）15.3.1 函数调用捆绑把函数体与函数调用相联系称为捆绑。当捆粄在程序运行之前（由编译器和连接器）完成时，称为早捆绑（early binding）。 晚捆绑（late bingding）根据对象的类型，发生在运行时。又称为动态捆绑（dynamic binding）或运行时捆绑（runtime binding）。 15.4 虚函数对于特定的函数，为了引起晚捆绑，C++要求在基类中声明这个函数的时候使用virtual关键字。晚捆绑只对virtual函数起作用，而且只在使用含有virtual函数的基类的地址时发生，尽管它们也可以在更早的基类中定义。 仅仅在声明的时候需要使用virtual关键字，定义时不需要。 如果一个函数在基类中被声明为virtual，那么在所有的派生类中它都是virtual。在派生类中virtual函数的重定义通常称为重写（overriding）。 注意，仅需要在基类中声明一个函数为virtual。调用所有匹配基类声明行为的派生类函数都将使用虚机制。虽然可以在派生类声明前使用关键字virtual（这也是无害的），但这样会使程序段显得冗余和混乱。 15.4.1 扩展性编译器保证对于虚函数总是有某种定义，所以绝不会出现最终调用不与函数体捆绑的情况（这种情况将导致灾难）。 这里我有相当大的疑问： 按照上面的说法，继承的基类中有虚函数的情况下，派生类都将使用虚机制 虚机制是什么 其次，按照上面的描述在派生类声明前加上virtual也可以，也就是说派生类中的函数也称为了虚函数？ 然后是在派生类中定义了一个名为FunctionA()的新的函数的话，这个函数尽管没有加入virtual关键字，实际上也是虚函数？ 然后假设从相同基类派生的派生类PAClass()和PBClass()两个同时新定义了一个名为FunctionA()的函数的话，这种情况下他们是相同的虚函数吗？ 按照书上说的意思（我的理解），出现上面情况的时候，将会自动的调用继承层次中“最近”的定义。 但我不太懂。还是得继续摸索下去。 15.5 C++如何实现晚捆绑当告诉编译器要晚捆绑时（通过创建虚函数来告诉），编译器安装必要的晚捆绑机制。 关键字virtual告诉编译器它不应当执行早捆绑，相反，它应当自动安装对于实现晚捆绑必须的所有机制。 为了达到这个目的，典型的编译器（通用的方法）对每个包含虚函数的类创建一个表（称为VTABLE）。在VTABLE中，编译器放置特定类的虚函数的地址。在每个带有虚函数的类中，编译器秘密的放置一个指针，称为vpointer（缩写为VPTR），指向这个对象的VTABLE。当通过基类指针做虚函数调用时（也就是做多态调用），编译器静态的插入能取得这个VPTR并在VTABLE表中查找函数地址的代码，这样就能调用正确的函数并引起晚捆绑的发生。 15.5.1 存放类型信息必须有一些类型信息放在对象中，否则类型将不能在运行时建立。但是类型信息被隐蔽了。 不带虚函数，对象的长度恰好就是所期望的长度。而带有单个或多个虚函数的对象，是所期望的长度加上一个void指针的长度。 它反映出，如果有一个或多个虚函数，编译器都只在这个结构中插入一个单个指针（VPTR）。这是因为VPTR指向一个存放函数地址的表。 15.5.2 虚函数功能图示上不了图了 每当创建一个包含有虚函数的类或从包含有虚函数的类派生一个类时，编译器就为这个类型创建一个唯一的VTABLE。在这个表中，编译器放置了在这个类中或在它的基类中所有已声明为virtual的函数的地址。如果在这个派生类中没有对基类中声明为virtual的函数进行重新定义，编译器就使用基类的这个函数的虚函数地址。 当使用简单继承时，对于每个对象只有一个VPTR。VPTR必须被初始化为指向VTABLE的起始地址。（这个在构造函数中发生，在稍后会看的更清楚） 一旦VPTR被初始化为指定相应的VPTR。对象就知道它自己是什么类型。但只有当虚函数被调用的时候这种自我认知才有用。 当通过基类地址调用一个虚函数时（此时编译器没有能完成早捆绑所需的所有信息），要特殊处理。它不是实现典型的函数调用，那样只是简单的用汇编语言CALL特定的地址，而是编译器为完成这个函数调用而产生不同的代码。 此处应有图但是上不了。 编译器从这个Instrument（基类）指针开始，这个指针指向这个对象的起始地址。对于所有的Instrument对象和由Instrument派生的对象，它们的VPTR都在对象的相同位置（常常在对象的开头），所以编译器就能取出这个对象的VPTR。VPTR指向VTABLE的起始地址。所有的VTABLE都具有相同的顺序，不管何种类型的对象。Play()是第一个， What()是第二个， Adjust()是第三个。所以无论是什么特殊的对象类型，编译器都知道Adjust()是必在VPTR+2处。这样就不是以“Instrument::Adjust”地址调用这个函数，而实际上是在“VPTR+2”处调用这个函数。因为获取VPTR和确定实际函数地址发生在运行时，所以这样就得到了所希望的晚捆绑。 15.5.3 揭开面纱看一下虚函数调用产生的汇编语言代码。下面是在函数f(Instrument&amp;i)内部调用 i.Adjust(1); 某个编译器所产生的输出：12345push 1push simov bx, word ptr [si]call word ptr [bx+4]add sp, 4 说实话我是看不懂汇编的。 C++函数调用的参数与C函数调用一样，是从右向左进栈的（这个顺序是为了支持C的变量参数表），所以参数1首先压栈。对于这个函数，寄存器si（Intel x86处理器的一部分）存放i的地址。因为它是被选中对象的首地址，它也被压进栈。记住，这个首地址对应this的值，正因为调用每个成员函数时this都必须作为参数压进栈，所以成员函数知道它工作在哪个特殊对象上。这样我们总能看到，在成员函数调用之前压栈的次数等于参数个数加1（除了static成员函数，因为它没有this）。 然后必须实现实际的虚函数调用。首先，必须产生VPTR，找到VTABLE。对于这个编译器，VPTR在对象的开头，所以this的内容对应于VPTR。1mov bx, word ptr [si] 取出si（即this）所指的字，它就是VPTR。将VPTR放入bx寄存器中。 在bx中这个VPTR指向VTABLE的首地址，调用的函数在VTABLE中的第二个位置（0，1，2,它是表中的第三个函数）。对于这种内存模式，每个函数指针是两个字节长，所以VPTR+4，计算相应的函数地址所在的地方。 幸好编译器仔细处理，并保证VTABLE中的所有函数指针都以相同的次序出现，而不论我们在派生类中是以什么样的顺序覆盖它们。 一旦VTABLE中相应函数指针的地址被计算出来，就调用这个函数。所以取出这个地址并马上在这个句子中调用。1call word ptr [bx+4] 最后栈指针移回去，以清除在调用之前压入栈的参数。在C和C++汇编代码中，将经常看到调用者清除这些参数，但这可能依据处理器和编译器的实现而有所不同。 15.5.4 安装vpointer因为VPTR决定了对象的虚函数的行为，所以我们看到VPTR总是指向相应的VTABLE是多么重要。在VPTR适当初始化之前绝不能调用虚函数。 15.5.5 对象是不同的认识到向上类型转换仅处理地址，这是重要的。 如果编译器有一个它知道确切类型的对象，那么（在C++中）对任何函数的额调用不再使用晚捆绑，或至少编译器不必使用晚捆绑。因为编译器知道对象的确切类型，为了提高效率，当调用这些对象的虚函数时，很多编译器使用早捆绑。 12345678910111213141516171819202122232425// Early binding &amp; virtual functions#include &lt;iostream&gt;#include &lt;stream&gt;using namespace std;class Pet&#123;public: virtual string speak() const &#123;return "";&#125;&#125;;class Dog : public Pet&#123;public: string speak() const &#123;return "Bark";&#125;&#125;;int main() &#123; Dog ralph; Pet* p1 = &amp;ralph; Pet&amp; p2 = ralph; Pet p3; p1-&gt;speak(); p2.speak(); p3.speak();&#125;; 使用地址就意味着不完全，p1,p2可能表示Pet的地址，也可能是其派生对象的地址，所以必须使用虚函数。而当调用p3的时候,不存在含糊，编译器知道确切的类型并且知道它是一个对象，这样可以使用早捆绑。 15.6 为什么需要虚函数virtual关键字可以改变程序的效率。 从前面的汇编语言输出可以看出，它并不是对于绝对地址的一个简单的CALL，而是为设置虚函数调用需要两条以上的复杂的汇编指令。这既需要代码空间，又需要执行时间。 15.7 抽象基类和纯虚函数在基类中加入至少一个纯虚函数（pure virtual function），来使基类称为抽象（abstract）类。纯虚函数使用virtual关键字，并且在后面加上=0.如果某人试着生成一个抽象类的对象，编译器就会制止他。 当继承一个抽象类时，必须实现所有的虚函，否则继承出的类也将是一个抽象类。 纯虚函数的声明语法：1virtual void f() = 0; 这样做，等于告诉编译器在VTABLE中为函数保留一个位置，但在这个特定位置中不放地址（或者说是放不了地址），只要有一个函数在类中被声明为纯虚函数，则VTABLE就是不完全的。编译器不能安全的创建一个纯抽象类的对象，保证了抽象类的纯洁性，就不会被误用了。 注意，纯虚函数禁止对抽象类的函数以传值方式调用。 这也是防止对象切片（object slicing）的一种方法。通过抽象类，可以保证在向上类型转换期间总是使用指针或引用。 纯虚函数防止产生完全的VTABLE，但这并不意味着我们不希望对其他一些函数产生函数体。我们常常希望调用一个函数的基类版本，即使它是虚拟的。把公共代码尽可能靠近我们的类层次根的地方，这是很好的想法。 也就是说下面的纯虚函数定义了 15.7.1 纯虚定义在基类中，对纯虚函数提供定义是可能的。我们仍然告诉编译器不允许产生抽象基类的对象，如果想要创建对象，则纯虚函数必须在派生类中定义。 好处一： 然而我们希望一段公共代码，使一些或所有派生类都能调用，而不必在每个函数中重复这段代码。 如下面的代码：12345678910111213141516171819202122232425262728293031// Pure virtual base definitions#include &lt;iostream&gt;using namespace std;class Pet&#123;public: virtual void speak() const = 0; virtual void eat() const =0; // Inline pure virtual definitions illegal: //! virtual void sleep() const = 0 &#123;&#125;&#125;;// OK, not defined inlinevoid Pet::eat() const&#123; // Do something&#125;void Pet::speak() const&#123; // Do something&#125;class Dog : public Pet &#123; void speak() const &#123; Pet::speak(); &#125; void eat() const &#123; Pet::eat(); &#125;&#125;;int main() &#123; Dog d; d.speak(); d.eat();&#125; Pet的VTABLE依然空着，但这个派生类中刚好有一个函数，可以通过名字调用它。 好处二： 这个特点的另一个好处是，它允许我们实现从常规函数到纯虚函数的改变，而无需打乱存在的代码。（这是一个处理不用重新定义虚函数的类的方法） 隐约觉得这个功能很强，让我联想到了静态函数，你看它直接通过类名调用就很厉害。这应该又涉及到另外的机制了吧。 15.8 继承和VTABLE当实现继承和重新定义一些虚函数时，编译器对新类创建一个新的VTABLE表，并且插入新函数的地址，对于没有重新定义的虚函数使用基类函数的地址。无论如何，对于被创建的每个对象（即它的类不含有纯虚函数），在VTABLE中总有一个函数地址的全集，所以绝对不能对不在其中的地址进行调用（否则结果将是灾难性的）。 当派生类继承了基类中的虚函数之后又增加了新的虚函数。可以知道VTABLE中增加了新的虚函数。 然而在这里，编译器只对指向基类对象的指针工作。即基类的虚函数是指向基类对象指针的编译器唯一允许调用的函数。 这跟我的理解是一致的，使用指向基类的指针并不能够调用子类新添加的函数时理所应当的。 只有基类对象的指针，那么编译器也不知道这个指针指向的内容是不是派生类，所以编译器通过防止我们对只存在于派生类中的函数做虚函数调用来完成工作。 但是当我们知道指针实际上指向哪一种特殊对象时，还想要去使用的少数情况时，则必须类型转换这个指针。 这就是运行时类型辨认（Run-Time Type Identification, RTTI） 问题。 RTTI是有关向下类型转换基类指针到派生类指针的问题（向上和向下是相对典型类图而言的，典型类图以基类为顶点）。向上类型转换是自动发生的，不需强制，因为它是绝对安全的。向下类型转换是不安全的，因为这里没有实际类型的编译时信息，所以必须准确的知道这个类实际上是什么类型。 15.8.1 对象切片对象切片实际上是当它拷贝到一个新的对象时，去掉原来对象的一部分，而不是使用指针或者引用那样简单的改变地址的内容。 15.9 重载和重新定义在第14章中，我们看到重新定义一个基类中的重载函数将会隐藏所有该函数的其他基类版本。 而当对虚函数进行这些操作时，情况会有点不同。 编译器不允许我们改变重新定义过的函数的返回值（如果该函数不是虚函数，则是允许的）。12345678910class Base &#123;public: virtual int f() const &#123;&#125;&#125;class Derived3 : public Base &#123;public: // Can not change return type: //! void f() const &#123; // do something&#125;&#125; 如果重新定义了基类中的一个重载成员函数，则在派生类中其它的重载函数将会被隐藏。 虚函数还写函数重载这个想法我还真没想到。 15.9.1 变量返回类型上面显示了我们不能重新定义过程中修改虚函数的返回类型。通常是这样的，但也有特例，我们可以稍稍修改返回值类型。如果返回一个指向基类的指针或引用，则该函数的重新定义版本将会从基类返回的内容中返回一个指向派生类的指针或引用。 返回确切类型更通用些，而且在自动进行向上类型转换时不丢失特定的信息。然而，返回基类类型通常会解决我们的问题，所以这是一个特殊的功能。 这个感觉就像是编译器会做返回值的类型检查，对于指针而言，返回基类类型指针的函数得到了一个派生类类型的指针，由于继承的特性，所以这是成立的。反过来应该就不行。 15.10 虚函数和构造函数编译器在构造函数的开头部分秘密地插入能初始化VPTR的代码。正如第14张所述，如果我们没有为一个类显式创造构造函数，则编译器会为我们生成构造函数。如果该类含有虚函数，则生成的构造函数将会包含相应的VPTR初始化代码。这有几个含义。 首先，这涉及效率。内联（inline）函数 的作用是对小函数减少调用代价。如果C++不提供内联函数，则预处理器就可能被用来创建这些“宏”。然而预处理器没有访问或类的概念。因此不能被用来创建成员函数宏。另外，有了由编译器插入的隐藏代码的构造函数，预处理宏根本不能工作。 上面这段话看得我不知所谓，事实来说C++提供了内联函数。我不太理解预处理宏是什么，最后一句为什么那种情况下预处理宏不能工作的具体原因是什么？ 当寻找效率漏洞时，我们必须明白，编译器正在插入隐藏代码到我们的构造函数中。这些隐藏代码不仅必须初始化VPTR，而且还必须检查this的值（以免operator new返回零）和调用基类构造函数。放在一起，这些代码可以影响我们认为是一个小内联函数的调用。特别是构造函数的规模会抵消函数调用代价的减少。如果做大量的内联函数调用，代码长度就会增长。而在速度上没有任何好处。 当然也许并不会立即把所有这些小构造函数都变成非内联，因为它们更容易写为内联构造函数。但是，当我们正在调整我们的代码时，记住，务必去掉这些内联构造函数。 所以这些内联构造函数是可以删除的？还是说变成非内联？ 15.10.1 构造函数调用次序所有基类构造函数总是在继承类构造函数中被调用。 15.10.2 虚函数在构造函数中的行为对于在构造函数中调用一个虚函数的情况，被调用的只是这个函数的本地版本。也就是说，虚机制在构造函数中不工作。 这种行为有两个理由。在概念上，构造函数的工作是构造一个对象。在构造函数中此时可能只是部分形成对象–我们只能知道基类已被初始化，但并不能知道是那个类从这个基类继承来的。然而，虚函数在继承层次上是“向前”和“向外”的进行调用。它可以调用在派生类中的函数。如果我们在构造函数中也这样做，那么我们所调用的函数可能操作尚未初始化的成员，导致灾难的发生。 第二个理由是机械的。当一个构造函数被调用的时候，它做的首要事情之一是初始化它的VPTR。然儿它知道它属于“当前”类，即构造函数所在的类。当编译器为这个构造函数产生代码时，它使用的VPTR必须是对于这个类的VTABLE。VPTR的状态是由最后被调用的构造函数确定的。 这就是为什么构造函数调用是按照从基类到最晚派生类的顺序的另一个理由。 另外，许多编译器认识到，如果在构造函数中进行虚函数调用，应该使用早捆绑，因为它们知道晚捆绑将只对本地函数产生调用。无论哪种情况，在构造函数中调用虚函数都不能得到预期的结果。 15.11 析构函数和虚拟析构函数构造函数是不能为虚函数的。但析构函数能够且常常必须是虚的。 构造函数有一项特殊的工作，就是一块一块的组合成一个对象。它首先调用基类构造函数，然后调用继承顺序中的更晚派生的构造函数（同样，它也必须按此方法调用成员对象构造函数）。类似的，析构函数也有一项特殊工作，即它必须拆卸属于某层次类的对象。为了做这些工作，编译器来生成代码来调用所有的析构函数，但它必须按照与构造函数调用相反的顺序。 应当记住，构造函数和析构函数是类层次进行调用的唯一地方（因此，编译器自动的生成适当的类层次）。在所有其它函数中，只有这个函数会被调用（非基类版本），而无论它是虚的还是非虚的。同一函数的基类版本在普通函数中被调用（无论是虚的还是非虚的）的唯一方法是显式的调用这个函数。 如果这个指针是指向基类的，在delete期间，编译器只能知道调用这个析构函数的基类版本。这听起来很耳熟，虚函数被创建恰恰是为了解决这个问题。幸运的是，就像除了构造函数以外的所有其他函数一样，析构函数可以是虚函数。 上面的指针指向基类的例子中，如果使用的delete，会依次调用自身的析构函数，然后调用基类的析构函数。前提是:基类的析构函数是虚函数。 这正是我们所期望的。不把析构函数设为虚函数是一个隐匿的错误，因为它常常不会对程序有直接的影响。 但要注意它不知不觉的引入存储器泄漏（关闭程序时内存未释放）。同样，这样的析构操作还有可能掩盖发生的问题。 我靠这到底想让我怎么写？！ 即使析构函数像构造函数一样，是“例外”函数，但是析构函数可以是虚的，这是因为这个对象已经知道它是什么类型（而在构造期间则不然）。一旦对象已被构造，它的VPTR就已被初始化，所以能发生虚函数调用。 15.11.1 纯虚析构函数尽管纯虚析构函数在标准C++中是合法的，但在使用的时候有一个限制:必须为纯虚析构函数提供一个函数体。 不像其他的纯虚函数，我们不要求派生类中提供纯虚函数的定义。 1virtual ~AbstractBase() = 0; 析构函数的纯虚性的唯一效果是阻止基类的实例化。如果有其他的纯虚函数，则它们会阻止，否则，纯虚析构函数会执行这项操作。所以当虚析构函数是十分必要时，则它是不是纯虚的就不是那么重要了。 15.11.2 析构函数中的虚机制在析构函数中，只有成员函数的“本地”版本被调用；虚机制被忽略。 在构造函数的情况下这样做是因为类型信息还不可用，然而在析构函数中，这样做是因为信息（也就是VPTR）虽存在，但不可靠。（可能派生的对象已被析构）。 15.11.3 创建基于对象的继承利用多态性，强制容器中的所有对象从一个基类中继承而来，随后调用虚函数（虚析构函数）来解决所有权问题。 这种解决方法使用单根继承（singly-rooted hierarchy）或基于对象的继承（object-based hierachy）。 事实上，除了C++，每种面向对象的语言都强制使用这样的体系，这个基类由该语言的创建者生成的。C++中认为，强制使用这个公共基类会引起太多的开销，所以便没有使用它。 这里需要警惕多重继承（multiple inheritance）。多重继承是非常复杂的，应尽量少用这一功能。 创建包容Object的容器是一种合理的方法–如果使用单根继承（由于语言本身或需要的缘故，强制每个类继承自Object）。这时，保证一切都是一个Object，因此使用容器的时候并不是十分复杂。然而在C++中不能期望这适用于每一个类，所以如果有多重继承就会出现问题。在第16章中会看到模板可以使用更简单更灵巧的方式处理这个问题。 15.2 运算符重载就像对成员函数那样，我们可以使用virtual运算符。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 对于一个处理矩阵向量标量的系统，这三个成分都是派生自Math类// Polymorphism with overload operators#include &lt;iostream&gt;using namespace std;class Matrix;class Scalar;class Vector;class Math&#123;piblic: virtual Math&amp; operator*(Math&amp; rv) = 0; virtual Math&amp; multiply(Matrix*) = 0; virtual Math&amp; multiply(Scalar*) = 0; virtual Math&amp; nultiply(Vector*) = 0; virtual ~Math() &#123;&#125;&#125;;class Matrix : public Math&#123;public: Math&amp; operator*(Math&amp; rv)&#123; return rv.multiply(this); // 2nd dispatch &#125; Math&amp; multiply(Matrix*)&#123; cout&lt;&lt; "Matrix*Matrix"&lt;&lt;endl; return *this; &#125; Math&amp; multiply(Scalar*)&#123; cout&lt;&lt;"Scalar*Matrix"&lt;&lt;endl; return *this; &#125; Math&amp; multiply(Vector*)&#123; cout&lt;&lt;"Vector*Matrix"&lt;&lt;endl; return *this; &#125;&#125;;class Scalar : public Math&#123;public: // 内容省略，跟Matrix类的实现基本一致&#125;;class Vector : public Math&#123;public: // 内容省略，跟Matrix类的实现基本一致&#125;;int main()&#123; Martix m;Vector v;Scalar s; Math* math[] = &#123;&amp;m, &amp;v, &amp;s&#125;; for (int i =0 ;i &lt; 3; i++)&#123; for (int j = 0;j&lt;3;j++)&#123; Math&amp; m1 = *math[i]; Math&amp; m2 = *math[j]; m1*m2; &#125; &#125;&#125; main()中的问题在于，表达式m1*m2包含了两个向上类型转换的Math引用，因此不知道这两个对象的类型。一个虚函数仅能进行单一指派–即判定一个未知对象的类型。 本例中使用的判定两个对象类型的技术称之为多重指派（multiple dispatching） ，一个单一虚函数调用引起了第二个虚函数的调用。在完成第二个调用的时候，已经得到了两个对象的类型，于是可以执行正确的操作。 15.13 向下类型转换（downcasting）C++提供了一个特殊的称为dynamic_cast的显式类型转换（explict cast），它就是一种安全型向下类型转换（type-safe downcasting）的操作。当使用dynamic_cast来试着向下类型转换一个特定的类型，仅当类型转换是正确的并且是成功的时，返回值会是一个指向所需类型的指针，否则它将返回0来表示这并不是正确的类型。 123456789101112131415#include &lt;iostream&gt;using namespace std;class Pet &#123; public: virtual ~Pet()&#123;&#125; &#125;;class Dog : public Pet &#123;&#125;;class Cat : public Pet &#123;&#125;;int main() &#123; Pet* b = new Cat; // Upcast Dog* d1 = dynamic_cast&lt;Dog*&gt;(b); Cat* d2 = dynamic_cast&lt;Cat*&gt;(b);&#125; 当使用dynamic_cast时，必须对一个真正多态的层次进行操作–它含有虚函数–这是因为dynamic_cast使用了存储在VTABLE中的信息来判断实际的类型。 这里基类含有一个虚析构函数，这就足够了。 无论何时进行向下类型转换，我们都有责任进行检验以确保类型转换的返回值不为0。 dynamic_cast运行时需要一点额外开销；不多，但如果大量执行（程序设计有问题），就会影响性能。有时在进行向下类型转换的时候，我们知道正在处理的是何种类型，这时使用dynamic_cast产生的额外开销就没有必要，可以通过static_cast来代替它。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;class Shape &#123;public: virtual ~Shape() &#123;&#125;;&#125;;class Circle : public Shape &#123;&#125;;class Square : public Shape &#123;&#125;;class Other &#123;&#125;;int main()&#123; Circle c; Shape * s =c; //Upcast: normal and ok // More explicit but unnecessary s = static_cast&lt;Shape*&gt;(&amp;c); // (Since upcating is such a safe and common operation, the cast becomes cluttering) Circle* cp = 0; Square* sp = 0; // Static Navigation of class hierarchies requires extra type information: if(typeid(s) == typeid(cp)) //C++ RTTI cp = static_cast&lt;Circle*&gt;(s); if(typeid(s) == typeid(sp)) sp = static_cast&lt;Circle*&gt;(s); if(cp != 0) cout&lt;&lt;"It is a Circle"&lt;&lt;endl; if(sp != 0) cout&lt;&lt;"It is a Square"&lt;&lt;endl; // Static navigation is ONLY an efficiency hack; // dynamic_cast is always safer.However: // Other* op = static_cast&lt;Other*&gt;(s); // Conveniently gives an error message,while Other *op2 = (Other*)s; // does not&#125; RTTI允许我们得到向上类型转换时丢失的类型信息。dynamic_cast实际上就是RTTI的一种形式。这里typeid关键字（在&lt;typeinfo&gt;中声明）用来检测指针类型。RTTI的内容远不止typeid，我们也可以想象它能通过虚函数简单合理的实现我们自己的类型信息系统。 RTTI用于判定类型，static_cast用于执行向下类型转换。但要注意，这个设计中，处理效率同dynamic_cast是一样的，并且必须检测那些实际成功的类型转换。 如果类层次中没有虚函数（这是一个有问题的设计），或者如果有其他的需要，要求我们安全的进行向下类型转换，与使用dynamic_cast相比静态的执行向下类型转换会稍微快一点。另外，static_cast不允许类型转换到该类层次的外面，而传统的类型转换是允许的，所以他们会更安全。但是静态的浏览类层次是有风险的，所以除非特殊情况我们一般使用dynamic_cast。]]></content>
      <categories>
        <category>C++编程思想</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4-SplineComponent学习]]></title>
    <url>%2F2019%2F04%2F22%2FUE4-SplineComponent%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[偶然发现了一个很有趣的控件，Spline Component，感觉会很有用就记下来了。 Spline Using Splines &amp; Spline Components | Live Training | Unreal Engine 这是四年前的视频你敢信？！ 记录一下这个视频里出现的常用的关于Spline的操作函数。 Functions1.GetNumSplinePoints Store number of Spline points. 在Spline的Component中输入Get就能看到好多和其相关的函数。 2.AddSplinePoint Spline Mesh在C++中使用Spline从Actor中获取SplineComponent12345AActor* Object;USplineComponent * comp = Object-&gt;FindComponentByClass&lt;USplineComponent&gt;();float splineLength = comp-&gt;GetSplineLength(); 原本我是把这个Spline控件放在了一个Actor上面，然后更新DistanceAlongSpline的变量值来控制Actor在Spline上的位置，但是我却忽视了Actor移动的时候这个Spline也在移动，所以没有按照预期的进行。只有将Actor和spline分开，放到另外一个Actor上了。]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4-Material学习]]></title>
    <url>%2F2019%2F04%2F11%2FUE4-Material%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[关于UE4中的材质，也有好多能说的，这里记录一些遇到的关于材质的知识点作为知识储备。 MaterialMaterial nodeShadowPassSwitchMaterial Parameter Collections Material Parameter Collections]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4-Performance提升]]></title>
    <url>%2F2019%2F03%2F19%2FUE4-Performance%E6%8F%90%E5%8D%87%2F</url>
    <content type="text"><![CDATA[主要记录一些能够查看UE4的性能工具和提升性能的一些手段记录。 我在知乎看见一篇文章整理的非常好： Performance and Profiling(UE4优化) Unreal 4 性能入门指南 根据这个再根据自己在工作中遇到的问题进行进一步细致的总结吧。 发现了BasePass的消耗很高，查一下。 Optimization关于一些渲染流程的说明： CEDEC2016: Unreal Engine 4 のレンダリングフロー総おさらい 上面的文章我之前有总结过一些，但是并没有完全理解。 Emulate HMD performance下面有提到VRSDK的设置（v-sync）会使得帧数锁在90fps那里，如果小于90fps就会直接降到45fps，不能够正确的测试处理时间。 我们可以模拟VR的绘制： Launch witch -emulatestereo Set resolution 2160x1200 Set r.screenpercentage 140 具体的做法如下： 在Editor Preferences &gt; Play &gt; Play in Standalone Game &gt; Additional Launch Parameters中填入 -emulatestereo Start with Standalone Mode and Set Resolution to r.SetRes 2160x1200 or r.SetRes 2160x1200f r.screenpercentage 140 Ready Profiling Play in Standalone Make sure the Editor is set to NOT update in realtime Minimize the Editor Make sure to turn off Frame Rate Smoothing[Project Settings] Turn off VSync[r.vsync 0] 使用r.ScreenPercentage 10命令，如果程序突然加速，说明性能瓶颈在GPU上。 引用来自下面的视频： UE4 Performance and Profiling VR Instanced Stereo这个可以在Edit &gt; Project Settings &gt; Rendering &gt; VR 中开启。 目的是为了让双眼的画面同时渲染。减少Draw Call。 于是我试了试，并没有变快..反而感觉慢了，因为瓶颈本来不是CPU么。使用应该有条件的。 VR Instanced Stereo 1.Base Pass关于base pass的总结： UNREAL ART OPTIMIZATION - Base Pass Responsible for • Rendering final attributes of Opaque or Masked materials to the G-Buffer • Reading static lighting and saving it to G-Buffer • Applying DBuffer decals • Applying fog • Calculating final velocity (from packed 3D velocity) • In forward renderer: dynamic lighting Cost affected for • Rendering resolution • Shader complexity • Number of objects • Number of decals • Triangle count 在basepass阶段做了许多工作，其中Shader Complexity 是影响性能的一个很重要的因素。 Optimization如何优化这个问题首先要知道那个地方需要优化。 Shader Complexity: 在view-mode下可以查看shader的复杂度。 Stat: 在Material Editor里面有stat window查看pass的数量 Rendering Resolution: 可以查看和影响G-Buffer和其他贴图的质量。 stat RHI: 查看G-Buffer的内存占用 英文文章读起来不如中文的快，那么容易理解，但是有些话翻译成中文的话不知道为什么就变了味道。还是多读几遍人家的文章吧。 GPU Visualizer1.BasePass-Dynamic BasePass 0 = Opaque Meshes. BasePass 1 = Alpha Masked Opaque Meshes for Z-depth. BasePass Dynamic = Animated Vertices such as Skeletal, GeoCache(Alembic),etc. 在上面我只看到了Dynamic，而其他的是Static EBassPassDrawListType=0和Static EBasePassDrawListType=1意思是不是一样的我也不确定。 于是我查了查EBasePassDrawListType12345678910// Source UnrealEngine4源码：Runtime\Render\Private\BasePassRendering.cppEBasePassDrawListType DrawType = EBasePass_Default;// The definition of the typeenum EBasePassDrawListType&#123; EBasePass_Default = 0, EBasePass_Masked, EBasePass_MAX&#125; 看这个声明貌似上面的是对的。 还有一个我有点在意的是在VR的模式下会出现两种 View0 View1 这两种处理，一开始我认为是两个摄像机的存在导致的，删了一个摄像机没啥影响。后来新建了一个新的VR项目试试发现原本就会有两个摄像机（Runtime），一个VR设备用另一个不知道干啥的，运行时会生成。查了一下也没找到，先写下来。 但是现在我有点明白了，VR眼镜不是有两个镜片么，就对应了两个摄像机不是么，我也是傻了。 所以Dynamic处理占用时间，是因为顶点动画比较多。 2.PrePass我看到的不是单单的PrePass，而是PrePass DDM_AllOpaque(Forced by DBuffer)。 这个Pass是用来先行计算Depth-Buffer的，在BasePass把数据写G-Buffer之前，把深度通过测试的像素留下，达到减少处理的目的，但是不是一定会减少。 这个可以ON/OFF，也可以开启之后指定物体经不过经过该处理。 所以说PrePass的目的是为了减少BasePass的处理负荷。 我在项目中发现的特点是：在所有的View0/View1中的处理中，还是Dynamic的时间最长。上面也有提到当动态的顶点，skeleton动画比较多的时候就会这样，可以试试关掉PrePass或者把顶点动画的物体不经过该Pass处理会不会减轻一些负担。但是在此之前，我应该学会如何使用Profile工具。 3.Translucency按照处理顺序的话透明处理绝对不是那么靠前，之后应该调整一下顺序。 Separate Translucency把半透明的处理写到其他的Buffer中。 Project Settings &gt; Engine &gt; Rendering &gt; Translucency 我似乎有看过一点这方面的文章。 r.SeparateTranslucencyScreenPercentage XX: 指定该buffer的解像度 r.SeparateTranslucencyAutoDownsample: 自动降低解像度 4.Shadow阴影这一部分的内容有很多，顺序也需要之后调整。 Fake Shadow多在角色模型中使用，比如人物脚下一团黑影代表着阴影那样。 Capsule Shadow SkeletalMesh: Capsule Direct(Indirect) Shadow 等等 Command Introduction记录一些常用的命令和里面的参数解读。 stat SceneRenderingRenderQueryResult关于这个参数，我也不太完全确定，在网上搜了也没有什么具体的答案。搜来搜去看到了OcclusionCulling感觉很像，但是按照这个方向去优化了一下试了试并不是很理想，貌似不是并不是一个概念，而且OcclusionCulling这个参数在另外一个命令，貌似是stat InitView中有貌似。 看到有人理解的是： RenderQueryResult是GPU完成整个一帧的渲染最后要做的事情。这个条目耗费时间很长说明GPU在这一帧内没有空闲，一直在工作。 感觉还说的过去。 Bluerint优化像Blueprint和C++是由CPU处理的Game阶段的处理。 Tick Event如果不需要的话，将Actor中的Tick Enable 设置为Off。亦或者调整Tick Interval的数值减少每一帧的调用。 SpawnSpawn处理不一定非要在一帧之内完成，可以分散到下下帧，由于间隔时间很短所以不会暴露什么。 但是分帧完成一个动作我还没见过这种操作，之后有时间找找看吧。 Nativizing Blueprint这个我也不太懂，真要用的时候再看吧。 Nativizing Blueprint Landscape Optimization自作大型的场景的时候就会用到Landscape，但是问题是在Statistics中查看的结果，这个东西的无论是顶点数还是资源大小还是光照贴图的大小都是场景里耗费最高的。 关于Landscape的制作也不是随意的。 Introduction to Landscapes - #6 Unreal Engine 4 Level Design Tutorial Series 这个视频涉及到了如何合理的制作Landscape，还有其他的系列视频关于如何使用Landscape的工具的。 再就是官方文档了： Landscape Technical Guide 解释了各种参数的意义和推荐设置。 还有就是一些具体细节的调整： Navigation不用的话关掉 Collision不用的话关掉 LOD设置调低 HTC ViveVive的刷新率只有90Hz。 这是什么概念？每秒刷新90帧的能力，这跟游戏能够达到的帧率有很大不同。 这里就有疑问了，如果游戏的帧率高于显示器（VR）的刷新率会怎么样。 会造成撕裂(tearing)。 GPU活儿干多了，比如说应该把一帧的图像交给显示器，结果交付了一帧还多的数据（显示器来取数据的速度慢了一拍，本应该取走的一帧数据被显卡二次更新中途，）。产生了画面撕裂。 V-Sync被用来解决这个问题，垂直同步(Vertical Synchronization)通过建立一个不让在显示器刷新前将后备缓冲中的画面拷贝到显示缓冲中的规定来解决这个问(有条件的双倍缓冲)。如果FPS高于刷新率的话没有问题，后备缓冲的更新完成后，系统处于等待状态。当显示器刷新后，后备缓存拷入显示缓存，显卡则可以在后备缓存中描画新的画面。 游戏的帧率低于显示器（VR）的刷新率会怎样 如果打开了垂直同步，那么帧数直接减半。理论上讲，双缓冲的VSync，FPS将是一组不连续的整数，其等于刷新率/n。 这就是为什么我总是看Vive的帧率被锁在45帧的原因。 那么进入正题，UE4中的Smoothed Frame Rate Range有什么用。 Smoothed Frame Rate Range What exactly does “Smooth Frame Rate” do? With Frame Rate Smoothing, the application is determining what range is acceptable for frame rate wandering,so you can cap your frame rate to between Min and Max allowable frame rates.Since this is application based,it will make these changes before any hardware vsync changes. 举例来说，如果设置了Max60f，Min40f的话，当超过60帧会保持在60帧，当低于60帧而高于40帧的时候会保持帧数，但是低于40帧的时候就会降到30帧。 得益于现在的显卡很多具有自适应的垂直同步功能。 当然上面的内容只是我看文章得到的，并没有实际试验过。 然后吧，我读到了一篇文章。 Unreal* Engine 4 VR应用的CPU性能优化和差异化：第一部分 这里面提到了另外，因为VR是强制开启垂直同步的，所以只要一帧的渲染时间超过11.1ms，即使只超过0.1ms，也会导致一帧需要花两个完整的垂直同步周期完成，使得VR应用很容易因为场景稍微改变而出现性能大降的情形。这时候可以用“–emulatestereo”指令，同时把分辨率(resolution)设为2160x1200，屏幕百分比(screenpercentage)设为140，就可以在没有接VR头显及关闭垂直同步的情况下分析性能。 好的。 UE4中的一些概念Instanced Static Mesh关于这个东西，我纠结了好久。我是从foliage这个东西接触到它的。因为foliage刷出来的东西就是这个类型，生成一些随机的树啊花啊草啊就很方便，但是同时带来了性能消耗。 Foliage Instanced Meshes 为什么说带来了性能消耗呢，其实除了方便之外还有其他的好处。 减少了Draw Call 据我的理解：一个Actor的渲染对于CPU来说就得生成一个draw call，所以庞大的Actor的数量会拖CPU的后腿，减少draw call是优化性能的方向之一。 但是与此同时，一个draw call的数据不充分就导致GPU做额外的工作。也就是我遇见的InstancedStaticMesh这个东西产生的影响。 剔除有两种剔除方式： Frustum Culling Occlusion Culling 对于InstancedStaticMesh来说，第一种视椎体剔除是可以降看不见的部分剔除的。而第二种遮挡剔除，对于它来说就完全不起作用了，反而加重了GPU的负担。 我这么认为的证据是，在我分析一个用满是foliage制作的大场景中，我试着： ToggleDebugCamera: 命令行打开Debug摄像机，找到想要看的位置 FreezeRendering: 我忘记上面的命令是在哪里看到的了，在我暂停了渲染之后移动摄影机之后发现，在摄像机之外的内容被剔除掉但是在摄像机之内的所有InstancedStaticMash都还在。即下面的文章中提到的： Unreal* Engine 4 Optimization Tutorial, Part 2 One thing to know about instanced static meshes is that if any part of the mesh is rendered, the whole of the collection is rendered. This wastes potential throughput if any part is drawn off camera. It’s recommended to keep a single set of instanced meshes in a smaller area; for example, a pile of stone or trash bags, a stack of boxes, and distant modular buildings. 如果将Foliage的部分做的很大，那么所有的内容都会被渲染，哪怕是一小部分进到了摄像机的视野里。 还要一种方式是在Editor中，不是运行的状态，输入命令： r.VisualOccludedPrimitives 可以实时的查看被遮挡的物体的轮廓，上面的例子中，并看不见InstancedStaticMesh被遮挡的轮廓，因为他们是一体的，只要一部分出现在了视野里就会被渲染。 这里我突然就产生了对遮挡这个功能的疑惑，遮挡剔除这个部分对Instanced类型的物体做的不是很好，或者说是根本无能为力。按照我之前的理解，对看不见的片元，CPU和GPU不会去渲染才对，但是结果是，遇见这种类型的，都会被渲染，看不见的片元被渲染浪费了大量的GPU的能力和处理时间。GPU并没有认为这是一个物体，把出现在视野内的片元渲染，看不见的片元舍弃，而是全部听从了CPU的命令进行全部的渲染。 这个是我之前的理解。 但是对于视野内的物体，遮挡剔除就完美的降被遮挡的非Instanced物体给剔除掉了，这是事实。 遮挡剔除究竟是CPU的工作还是GPU的工作？ 关于OcclusionCulling的一些问题 UE4のOcclusion Cullingで良く聞かれる質問1: Occlusion Culling自身の処理負荷を減らしたい - だらけ者だらけ UE4のOcclusion Cullingで良く聞かれる質問2 Occlusion Cullingによりオブジェクトが1フレーム消失することがある - だらけ者だらけ 上面是关于遮挡剔除的一些问题的文章。重点是在第二篇。 这里提到了一些遮挡剔除的特性： 当摄像机的移动超过了一定的阈值OcclusionCulling就会Off CameraRotaionThreshold(Default 45.0) CameraTranslationThreshold(Default 1000) 另外，r.AllowOcclusionQueries 的ON/OFF 可以手动切换。 也可以通过扩大Occlusion的Bound来提前渲染object OCCLUSIN_SLOP r.ExpandAllOcclusionTestedBBoxedAmount 进入摄像机视野的一瞬间扩大OcclusionBound： r.ExpandNewlyOcclusionTestedBBoxsAmount(Default=0.0f) 简单的Profiling stat SceneRendering stat InitView Stat SceneUpdate 命令应该别的地方有讲过。但是这里我注意到的是在stat InitView命令里，有一个处理占了我很多时间 Render Query Result查了也不是很明白 RenderQuery Result is when the render thread stalls waiting for the GPU to finish the Occlusion Query, and return the results to the render thread, so that it knows what to render. At the same time, the game thread is stalled waiting for the render thread. This can be turned on or off with the console command r.AllowOcclusionQueries 0 - off 1 - on 看了也不太懂系列。 什么是Occlusion Query? GPU Gems- Chapter 29. Efficient Occlusion Culling 我下了PDF，可以看。 如何正确的使用 UE4 Optimization : Instancing 我觉得这个人的每个视频都值得我刷几遍。 Culling Distance Foliage Culling Distance Culling Distance Volumn UE4 Performance and Profiling实际上准确的标题名字应该是 UE4 Performance and Profiling | Unreal Dev Day Montreal 2017 | Unreal Engine 这其实是一个视频，我尝试的边看边做笔记，结果足足整理了三页，虽然是就是抄的英文，等之后有时间再记录下来吧。 现在要将这些内容整理一下，同时也温习一下视频的内容。 1.CPU/GPU Profiler我觉得有必要区分这两种Profiler，因为我最近接触的总是GPUProfiler，搞得我都不知道CPU要怎么Profiling了。 2.Profiling in a Build算是准备优化之前的准备工作吧。 Minimize the noise that can interface with profiling Turn off everything you are not using Turn off v-sync r.vsync 0 Turn off Framerate Smoothing Make a Test build Testing in a Development build inflates the Draw thread with noise 尽可能的关闭噪声（noise），前两项是必须要做的，但是第三项，我也不太清楚我理解对不对，开发的时候使用的是Development mode，所以尽可能的减少噪音就直接build工程（即Shipping mode）来optimization。 但是吧，还能不能用stat一类的命令来debug了我还真没试过。 3.Profiling from within the Editor可能就是上面的补充吧，其实我也是这么做的。在Editor中Optimization肯定会有noise。 前面也有提到具体怎么做(虽然是VR的，但是应该都一样)这里就简单抄一下。 Play in Standalone Make sure the Editor is set to NOT update i realtime Minimize the Editor VR &gt; Editor Preference &gt; Play &gt; should minimize Editor on VRPIE Make sure to turn off Frame Rate Smoothing Turn off VSync 4.General Process Identify the bottleneck Game Thread Render Thread CPU GPU Often jumps back and forth as you optimize Use r.ScreenPercentage 10 to quickly check if you are GPU bound 最后一条很有用。 Game Thread Code or Blueprint CPU Render Object count,draw calls,culling GPU Render Shaders, overdraw,light 5.Measuring in Milliseconds Use stat unit,not just stat fps Largest number shows you the likely bottleneck Milliseconds per frame Frame: total time to finish each frame Game: C++ or BP gameplay operations Draw: CPU render time GPU: GPU render time You can also use stat unitGraph,whitch shows a line graph playback. Mostly useful for spotting repeating hitches ScreenPercentage前面有提到使用这个命令来模拟VR的性能，还有就是使用这个命令来快速确认游戏的性能瓶颈是不是GPU。 Mostly useful to measure problems unrelated to Game Thread Use stat unit to show milliseconds Use r.ScreenPercentage 10 Or any number smaller than 100 Reduces number od pixels sent to the GPU If things get faster,you were GPU bound If they dont get faster,you were CPU bound 6.Show FlagsOne of the simplest ways to look for problems is to turn off partsof your scene. Helps know when to look into reducing LODs Less translucency Adjust lighting show assetType or showFlag.assetType 0-1 Staticmeshes Skeletalmeshes Particles Lighting Transluncency Reflectionenvironment Many more listed in docs 7.Diagnostic Tools-Realtime stats and view modesStat commands stat fps stat unit stat scenerendering stat gpu stat engine stat streaming stat emitters stat lighting Stat SceneRendering Only place to see draw calls Draw call is a single request to GPU to draw something Prime candidate for CPU slowdown on lower-end machines and also on mobile(less of a concern with Metal and Vulkan) Also good palce to see time for: Shadows Decals Post Processing Lighting 这个命令挺重要的。 Stat GPU Relatively new 4.15 Realtime readout from GPU Gives highlights, but not details Makes i very good to quickly target trouble spots Use the full GPU profiler if you want to target individual things Example:if you want to find specific lights that are casting shadows Optimization View ModesShader Complexity Show how much your shhaders are costing on the GPU Good way to see overdraw issues Overdraw is when a pixel must be drawn multiple times One of the most common content issues for optimization Graph at the bottom shows where the pixel and vertex shaders are in terms of performance If you see a lot of red and white,reconsider your approach 下面的话来自于官方文档里的 View Modes Shader Complixty Mode is used to visualize the number of shader instructions being used t calculate each pixel ofour scene.It i a generally a good indicating of how performance-friendly your scene will be. In general, it is used to test overall performance for your base scene, as well as to optimize particle effects, which tend to cause performance spikes with a large amount of overdraw for a short period of time. Quad Overdraw Helps show how you are using your polygon count on the screen Can help show where meshes should be LOD-ed down Too much green shows areas that should be simplified Anything more than green is starting to get costly, commonly translucency overdraw Very useful for MSAA on Forward Rendering,as the number of poly edges dramatically affects performance Quad Overdraw in-depth Your GPU breaks the view up into quads 2*2 groups of pixels This is more efficient than performing all operations on all pixels Very small, or very long, thin geometry wastes pixels Regular, large polygons make the best use of pixel quads, best use of GPU Model with regular trangles and LDD aggressively When you are looking at an opaque object on the deferred render, and you see a lot of green ,that means all 4 pixels of that quad had to be recalculated over and over. you should probably be using lower LODs. Shader Complexity + Quad Overdraw Combines two powerful view modes into one USeful to get an idea of expensive shader anf geometry at a glance You will still need the individual settings to help diagnose specifics Liht Complexity Visualizes the cost of scene lighting As lights overlap, the colors shift from cool to warm to white Only shows cost of lighting, not shadowing Obviously, white is bad Great way to see where you should be lowing light radii By flipping this on and off, you can quickly see if the cost of any given light is “worth it” Lightmap Density Shows the density of texels for lightmap purposes Color shifts from cool to warm an density increases Most things can be blue Shadow maps don’t often need to be very high res Keep this as low as possible Cost adds up quickly Stationary Light Overlap Only a maxium of 4 stationary lights can affect any given object Beyound that,any other lights fall back to Movable(fully dynamic) This view mode helps track down where that might be happening Reminder to keep lighth radii as small as you can get it Do you have a stationary sun? Congratulations! That’s one of the four lights! LOD Coloration This mode shows the current mesh LODs in use by color coding them Very fast way to through ypur scene and verify that things are LODing when they should be Interestingly, mode clearly shows that the trees are not LODing at all in this project Was able to diagnose frame drop instantly using this mode 8.Profilling ToolsCPU Profiling Integrated tool to take apart a segment od your gameplay and see wat’s happening on each tick Very useful way to profile Blueprint performance Measures a segment of time Within that segment, can look a individual frames or averages Requires two special Stat Commands stat startfile &amp; stat stopfile Tese generate a log file between the interval of the commands Profiller allows deep analysis that log Step down into world tick and see individual Blueprint functions Can be used for CPU(Game and Draw) and GPU 捕获下来的日志可以在UE4的Session Frontend中展开分析。 GPU Profiling Three method to profile GPU functions stat GPU command in tne viewport Recorded file log in the Session Frontend GPU Profiler Can dump out to either the log or its own UI Great way to visualize the cost of: Base pass Lighting Shadows Post processing Tracking Slow Frame stat dumpHitches The command is used to dump any hitched over a given time in milliseconds out to the log Use command t.hitchThreshhold 0.xx to set value (0.05 is default) memReport -full Full breakdown of how memory is being used There’s a great blog post on how this works 虽然我还没有尝试过但是我可以使用上面的命令来找到游戏运行时候突然消耗非常高的那一帧究竟做了什么。 startFPSChart and stopFPSChart You can use the commands startFPSChart/span&gt; and stopFPSChart/span&gt; to create a diagram of framerates over time You can call these at start and end of a Level Sequence to automatically read out the frame rates along a given course, as defined by a cinematic 这里使用完这个命令之后会输出日志文件，需要使用别的软件把日志文件转化为图表。我用了GoogleDrive上的Excel做的。 9.Blueprint Optimizations - Or:Keeping the Kids from Eating the Crayons Blueprints make it easy for folks to assemble gamepaly logic Best results often come with engineer mentorship Common challenge Reliance on Tick functionlity Over-use of expensive functions(iterating on many objects) Abuse of hard reference Reliance on Ticking Blueprints Tick means should on every frame Blueprints should almost never need Tick Remember to uncheck Enable Actor Tick in Class Defaults! This is on by default so that the Tick event will work Alternatives to Tick Timers Timelines Manually enabling/disabling Tick on demand Make sure to adjust Tick Frequency 0.0= every frame Expensive Functionality Some functions are inherently expensive Get All Actors of Class Spawn Anything that needs to iterate over a large group of objects or properties Try not to use these if at all possiple If you are doing it to get a reference, consider having the referenced class pass itself up so the referencing object does not need to query Use TSets instead of arrays If you must use them, do so as seldom as possible Perferably only once,such as at Begin Play Heavy ConstructionScripts can murder spawn times. Consider placing in the level beforehand Hard References in Blueprint It is very easy for Blueprints to generate references to each other When you load a Blueprint, every other Blueprint it references must be loaded And the Blueprints referenced by those And so on,and so on.. This will not slow dowwn in-game performance, but it can eat away at memory and load times Some studios have thought the Editor just ran slow Turns out they were loading moost(ot all) of their game on startup Avoiding hard references: Avoiding casting operations unless you are certain you need them and know that it won’t cause issue For instance, if a Pickup class can only interact with the player, it might be fine to have it cast to Player But having the Player class references every other type of pickup and interactive object in the game, you will likely see problems Instead, use Blueprint Interfaces Try to get into the mentailty of not needin a very specific reference type Send your messages via an interface to a more generic class If they land on something inplementing the interface, grate! If not,no big deal Other Blueprint Optimizations Avoiding doing too much of any one thing(like with any scripting language) Too much functionality in a sngle class Break things up Use a class hierarchy But on that note, also avoid… Class hierarchies that are too deep Too many components within a class Too much high-end math Use the Math Expression node- it’s optimized to speed things up When all else fails for BP performance: GO NATIVE! At Epic, many of our Blueprints derive from generic C++ classes Yours should, too! Keep all the heavy functionality in code, leave the lighter stuff for Blueprint What Actors are Ticking? Did you lose track of what’s ticking? Use dumpticks Dumps a list of all ticking Actors out to the log, telling you how many tick functions are called Also shows how many enabled and disabled ticking Actors are in the scene 10.Draw Thread OptimizationCPU Rendering Considerations Bottlenecks at the Draw thread are often caused by doing too much: Too many draw calls Occlusion queries - see above Simulating too many particles Adding too many lights - often hits the GPU harder Generally the best way to speed up the Draw thread is to do less Find every way you can to put fewer things on the screen Generally this means either being very clever with content or using the integrated tools within UE4 start combining objects Actor Merge Tool Located under Window &gt; Developer Tools Combines selection of meshes in to new asset, replacing originals Can also combine Material via Simplygon Works best with many meshes having the same Material The Actor Merge tool works best with many meshed that have the same materials as possible.If you try to combine 20 meshed and each has its own Material every materail,you are not benefiting from the tool because every material is going to make a draw call anyway. Instanced Static Meshes Mechanism for generating multiple instances of a given mesh, with each considered part of the same mesh object. Can only be created throuth code or Blueprint at this time, often via the Construction Script Very easy to create a Blueprint set that helps generate this Placement Blueprint that is used to preview where mesh will be Radius based ISM Blueprint that gathers transforms from Preview BPs and populates the instances with itself. Be careful of Editor Utility class BPs-they’re Editor only! Also consider Hierarchical Instanced Static Meshes Handle their own occlusion/visibility Hierarchical LOD Hierarchical LODs allow multiple meshed to be combined and then reduced as a single mesh Will also combine textures into atlases. reducing overall Material demands Very useful for buildings and cities, groups of large meshes that need to be viewed at extreme distance Requires Simplygon implementation 11.GPU Optimizations - What to do about all those pixelsVertex Shader Optimizatin Be careful how much you make use of World Position Offset Often cheaper than the alternative methods of vertex animation Vertex color can eventually get costly On Paragon, we ended up stripping it and adding it back per instance Pixel Shader OptimizationsPixel Shader Don’ts Too much math Too many textures Too many procedural functions noise Too many Material layers Reliance on lfs(if statements) Both sides have to calculate Pixel Shader Dos Use textures for lookups instead of mesh Compress greyscale maps into single textures Minimize Layer usage Use Switch Parameters to turn off what you don’t need Material Instruction Counts Always pay attention to Material instruction counts Caution: the number indicated is not accurate until you click Apply Sometimes it’s best to re-compile the Material just to be safe Dealing with Overdraw Overdraw is one of the leading causes of GPU slogging Minimize the geometry area for overdraw Adding vertices is almost aways cheaper than relying in overdraw For example, on A Boy and His Kite,we ended up cutting the grass planes to almost exactly match the outline of the grass texture alpha Make use of Particle Cutout property This is found under the Cascade Required Moudle Feed it a texture, it automatically snips the spite Also works in subUVs,with a different cutout for every frame Managing Texture Resolution Author texture at whatever resolution you like,but keep in mind you may not always use full resolution Use the Texture Streaming view to see what level of mips you’re using for any given texture You can use the Statistics panel set to Texture Staticstics to see what levl of mips you are using at current levels Then use the Texture Editor to force mip bias Or better yet,reimport at lower resolution Lighting Considerations Dynamic lights are expensive (but somewhat cheaper in deferred) Small,unshadowed lights are the cheapest! You can have lots of these Minimize number of dynamic lights Minimize number of things dynamic lights have to effect Minimize dynamic light radii -tighter is better Cast shadows from as few dynamic lights as possible Dynamic shadow casting lights are the most expensive in UE Watch out for Stationary Light Overlap The fallback to dynamic lighting is extremely expensive Bake whenever you can Don’t assume you need dynamic lights Use Mesh Distance Field shadows at distance Watch out for dense shado cascades Many artifacts are cleaned up with Shadow Bias,but be gentle Keep Lightmap Res as low as you can Use the view mode,keep it blue as much as possible Avoid Light Function unless you really need them Consider IES profiles, but understand they also have a cost Lit translucency gets expensive, use with caution Cull shadows early (at close distance as possible) Cull dynamic lights as early as possible Spot lights are cheaper than Point lights Don’t be afraid to completely fake shadows We do this a lot, especially for VR Replication Optimization Common problems for networking: Doing too much Doing it too much Replicate as little as you can, as seldom as you can Use net.* commands to check what’s going on Must be run on the sever Use cheat net.* to run the command on the server from the client Use net.DumpRelevantActors to see what is currently replicating This command features some improvements as of 4.19 There are a lot of these net.* commands - check online for full list Network Relevancy View Mode(4.19)… 我已经不知道他在讲什么了。。 12.Content StreamingTexture Streaming Textures streaming into and out of your scene at inopportune times cause visible pops As of 4.15 we have some tools for texture streaming diagnostics Texture streaming view mode Primitive Distance Accuracy Mesh Densities Accuracy Material Texture Scales Accuracy Required Texture Resolution stat streaming Primitive Distance Accuracy Visialization system for texture streaming Enable users to see what mips the system things they should be using, allowing for intelligent mip limits Red = 2 or more mips too few Orange = 1 mip too few White = the right degree of mips Cyan = 1 mip too many Green = 2 or more mips too many This setting can be adjusted using the StreamingDistanceMultiplier property Mesh UV Densities Accuracy This uses the density of a mesh’s UVs Visualizes how those UV densities are distributing to densities are contributing to streaming data Use the same paradigm as Primitive Distance Accuracy Red = 2 or more mips too few Orange = 1 mip too few White = the right degree of mips Cyan = 1 mip too many Green = 2 or more mips too many Fixing this requires the UVs on each mesh to be adjuested Material Texture Scales Accuracy This view mode samples all textures and feeds back the worst culprits for over-streaming and under-streaming Data is based on streaming affected by textures that have had their UVs scaled Helps diagnose streaming errors caused by UV scaling Required Texture Resolution This mode shows te required resolution for the given texture, indicating how many mips under or over it is Helps show the delta between the ideal resolution for the texture-what the GPU wants to show-and what is the GPU wants to show- and what is currenrly avaliable Red = 2 or more mips too few Orange = 1 mip too few White = the right degree of mips Cyan = 1 mip too many Green = 2 or more mips too many Stat Streaming Realtime metrics on texture streaming memory usage Breaks down texure streaming memory into 3 pools Texture Streaming Wanted Level Streaming Level streaming is an ideal way to control what content is in use in your game What you currently need is streamed in, what you don’t is streamed out Be careful how much you stream at once! You may need negate some of the benefit if you have over-referenced your content within code or Blueprint Bonus: Level Streaming as Collaboration Level Streaming is also the primary way for level artists to work together Different aspects are separated into different levels Not just different physical zonesWorld Composition Specialized streaming system designed for large worlds Will not work with old-school level streaming volimes But WILL work with Blueprint streaming Pro Tips: You can very easily make a Blueprint that functions just like a Level Streaming volume and does exactly the same thing, only better. GPU Performance for Game Artists这是上面的视频里大力推荐的一篇文章。有时间我也得看一下，去理解一下整理一下。 GPU Performance for Game Artists Tech Art Aid videos on Youtube这个在油管上的视频我一直在看了，在这儿记录一下网址： UE4 Graphics Profiling]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Performance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4光照学习调查笔记]]></title>
    <url>%2F2019%2F03%2F15%2FUE4%E5%85%89%E7%85%A7%E5%AD%A6%E4%B9%A0%E8%B0%83%E6%9F%A5%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[提高VR帧数的工作，需要对各个流程有所了解。光照，渲染等等，这篇文章就是用来记录我在试图理解光照流程中遇到的知识点。 光照在UE4的官方文档中有很多说明，我只记录一些我可能会忘记的。 我在别的优化文章里面多少有提到关于光照的内容。 Light Mobility Light MobilityStationary lights这种光源是位置不变但是它的brightness和color等想要变化的那种光源。 However,it should be noted that runtime changes to brightness only affect the direct lighting.Indirect (bounced) lighting, since it is pre-calculated by lightmass, will not change. 这里有三个需要我理解的地方。 Direct Lighting ( √ ) Indirect (bounced) Light Lightmass 所有来自于Stationary Light的indirect lighting (应该是间接光照吧) 和间接阴影(indirect shadowing)会存储在Lightmap（光照贴图）中。直接光照阴影会存储在阴影贴图中(Shadowmap)。 All of the indirect lighting and shadowing from Stationary Lights is stored within the lightmap.Direct shadows are stored within the Shadowmap.These lights make use of Distance Field Shadows, meaning that their shadows can remain crisp even fairly low Lightmap Resolution on lit objects. 当使用了低质量lightmap解决方案的时候，因为Stationary lights直射光产生的直接阴影是存储在Shadowmap中的，所以仍然还可以产生比较清晰的阴影。 这里需要深入理解的是： Shadowmap Lightmap Direct Lighting The direct lighting of stationary lights is rendered dynamically using deferred shading.This allows the brightness and color tobe changeable at runtime, along with a light function or IES profile. 应该就是直接光源，stationary light的直接光照是使用延迟渲染。 这里我应该理解的是 Deferred shading(该回忆了) IES profile Direct Shadowing Realtime shadowing of light sources has a major performance cost. A fully dynamic light with shadows will often cost twenty times(20x) as much to render than a dynamic light without shadows. For this reason, stationary light have the ability to have static shadowing on static object, but with some limitations. 关于阴影，光照的实时阴影是影响性能的一个主要参数。stationary light能产生静态阴影，在静态物体上。但是有限制。 Static ShadowingOn Opaque Lightmass generate distance field shadow maps for stationary lights on static objects during the lighting rebuild. Distance field shadow maps provide very accurate shadow transition even at low resolution, and with very little runtime cost. Like lightmaps, distance field shadow maps require uniquely unwrapped UVs on all StaticMeshes using static lighting. 当stationary light对不透明静态物体生成阴影的时候，在lighting rebuild阶段生成distance field shadow maps 。 Lighting must be built to display distance field shadows, otherwise whole scene dynamic shadows will be used for previewing. 这里我并没有找到有能够显示distance field shadow的编译选项。 Only 4 or fewer overlaping stationary lights can have static shadowing, because the lights must be assigned to different channels of a shadowmap texture. This is a graph coloring problem, so there are often fewer than 4 overlapping allowed due to topology. Shadowing cannot affect the overlap test, so the sunlight typically requires a channel from the entire level it is in, even the underground areas.这一句话应该是说阴影不会影响overlap测试，所以即使是在地下世界里的场景，有sunlight的情况下都要给sunlight预留一个channel。 就像上面所说的，尽量避免stationary lighting的overlapping。在StationaryLightOverlap视图中，可以查看stationary lighting的重合程度。如果光源的图标变成了红色的X就表明它不能容纳更多的channel了。 On Translucency Translucency also receives shadowing very cheaply with Stationary lights - Lightmass precomputes a shadow depth map from static geometry which is applied to transluency at runtime. This form of shadowing is fairly coarse only captures shadowing on the scale of metres. 不透明的物体也可以接收来自Stationary Light的光照阴影，代价也不是很高。但是这种阴影很粗糙。 Shadow depth map The resolution of the static shadow depth map is controlled by StaticShadowDepthMapTransitionSampleDistanceX and StaticShadowDepthMapTransitionSampleDistanceY in BaseLightmass.ini, with a default setting of 100 meaning one texel every meter. Dynamic Shadowing Dynamic objects(like StaticMeshComponents and SkeletalMeshComponement with Mobility set to Movable) must integrate into the static shadowing of the world from distance field shadowmaps. This is accomplished with Per Object shadows. Each movable object creates two dynamic shadows from a stationary light : a shadow to handle the static world casting onto the object, and a shadow to handle the object casting onto the world. 动态物体（movable）必须整合到来自distance field shadowmap的世界静态阴影(The static shadowing of the world) 中去,这个经由Per Object shadows来完成(每一个物体的阴影计算？)。每一个标记为movable的物体会创建两个来自StationaryLight的动态阴影，一个用来处理静态世界在该物体上的阴影，另外一个用来处理该物体在世界里面的阴影。 这意味着当动态物体的数量很多的时候，使用动态光是更好的选择。 Per Object shadows used by movable components apply a shadowmap to the object’s bounds, therefore the bounds must be accurate. For Skeletal meshes this means they should have a physics assets. For partial systems, any fixed bounding box must be large enough to contain all particles. Direction light dynamic shadowing Directiong Stationary Lights比较特殊，因为它通过Cascaded Shadow Maps(级联阴影贴图)和static shadowing支持整个场景的阴影的生成。当场景中存在许多animating foliage会很有用；当在player的周围存在许多动态的阴影，但是并不想花费太大的代价去使用许多cascades覆盖很大的视野范围。动态阴影将会随着距离的提升一点点渐隐到静态阴影中，这样的过度通常难以区分。 可以改变 DirectionalLightStationary 的Dynamic Shadow Distance StationaryLight 的范围来控制过渡的距离范围。 这里我不理解的概念： Cascaded Shadow Maps Animating foliage Movable components will still create PerObjects shadows even when using Cascaded Shadow Maps on a directional light.This behavior is useful with small Dynamic Shadow Distance, but incurs unnecessary cost with larger distance. To disable PerObject shadows and save performance, disable Use Inset Shadows For Movable Objects on the light. Indirect Lighting和静态光照一样，StationaryLight将间接光照存储在光照贴图内（lightmap）。间接光照不能像直接光照那样运行中改变光照的brightness和color。这意味着即使在light build中将Visible取消，间接光照还是会被存储在光照贴图当中。 IndirectLightingIntensity的光照属性可以被用来控制大小和开关，在光照的编译阶段。 However there is a post process volumn setting called IndirectLightingIntensity which lets you scale the contribution of the lightmap for all light, which can be changed at runtime from a blueprint. 上面的很好理解就不解释了。 Use Area Shadows for Stationary LightsDirectional Light可以打开这个属性，但是要保证这个直射光照的Mobility是Stationary。 When the Use Area Shadows for Stationary Lights option is enabled,the Stationary Light will use area shadows for the precomputed shadow maps. Area shadows are shadows that get softer the further they are from caster. Note that Area Shadows will only work on Stationary Lights and you might have to increase some objects lightmap resolution to get the same shadow quality and sharpness. 总的来说就是这个属性会让阴影变得比较柔软，更贴近现实一些。 Movable Lights动态光照不会把数据烘焙到光照贴图里，并且没有任何间接关照（currently）。 阴影阴影是动态光照里最昂贵的花销之一，光照内的mesh的图元数量和三角形数量是影响性能的指标。 Movable lights setup to cast shadows use whole scene dynamic shadows, which have a significant performance cost.The performance cost comes primarily from the number meshes affected by the light,and the triangle count of those meshes. Shadow Map Caching 选中所有产生动态阴影的动态光 确保Mobility是Movable，并且Cast Shadows属性选中 Backtick( ` ) 打开console输入 Stat Shadowrendering 查看实时动态阴影的花销 再次打开console，键入 Sr.Shadow.CacheWholeSceneShadow 0关掉dynamic shadow caching 注意CallCount 和 InclusiveAug 再打开console，键入 r.Shadow.CacheWholeSceneShadow 1 打开dynamic shadow caching you can control the maximum amount memory used by the Shadow Map Cache using r.Shadow.WholeScenceShadowCacheMb Limitations关于使用限制： By default,caching can only happen when an object meets the following requirements: Primitives have their mobility Mobility set Static or Stationary. Materials used in the level do not use World Position Offset. Light need to be either a Point or Spot light, have its Mobility set to Movable, and have Shadow Casting enabled. Lights have to remain at one location. Material that use animated Tessellation or Pixel Depth Offset can cause artifacts as their shadow depths are cached. 最后一条不太理解，需要继续调查： Tessellation Pixel Depth Offset Actor Mobility这里插一条概念，关于Actor的Mobility属性。 Actor Mobility 文档上有写，所以我就少写一点。 当我知道了StationaryLight的属性的影响的时候，主要会让我产生混乱的是当StaticMesh的mobility属性是Stationary的话怎么办 For Static Mesh Actors,this means that they can be changed but not moved.They do not contribute to pre-calculated lightmaps using Lightmass and are lit like Movable Actor when lit by a Static or Stationary Light.However,when lit by a Movable Light, they will use a Cached Shadow Map to reuse for the next frame when the lighting is not moving. 大体上就是StationaryLight下的StationaryMobility的StaticMeshActor,没什么太大的意义。 Lightmass Lightmass Global Illumination Lightmass生成像区域阴影，漫反射交互等等的复杂光照交互的光照贴图。通常被用来预计算一部分的静态光照和StationaryLight的光照。 Feature for Static and Stationary lightsDiffuse InterreflectionDiffuse interreflection is by far the most visually important global illumination lighting effect.Light bounces by default with Lightmass,and the BaseColor term of your material controls how much light(and what color)bounces in all directions. This effect is sometimes called Color Bleeding.Diffse Interreflection is incoming light reflecting equally in all directions,which means that it is not affected by the viewing direction or position. Indirect Lighting CacheLightmass为静态物体生成间接光照的光照贴图，动态物体也同样需要，解决方案是使用Indirect Lighting Cache。但是从UE4 4.18版本之后默认实现就被Volumetric Lightmap 取代了。 Volumetic Lightmaps Volumetric Lightmaps 在光照的编译阶段所有的点预计算的光照会被存储在Volumetric Lightmap中，之后在实时运算中被用来dynamic objects的间接光照插值运算。 工作方式： 在光照的编译阶段，Lightmass会在整个场景中放置lighting samples 并且计算它们的间接光照。 当开始渲染动态物体的时候，Volumetric Lightmap会以插值的方式为每一个被渲染的像素提供预先计算好的间接光照。 if no built lighting is available(meaning the object is new or has moved too much), lighting is interpolated to each pixel from the Vloumetric Lightmap for Static objects until lighting is rebuild. 上面的那句话我不太理解就直接抄了英文。 Enabling Volumetric Lightmap Visualization在view视图中找到： Show &gt; Visualize &gt; Volumetric Lightmap 可以查看，貌似必须是编译好光照之后才能看的见。 有着越远离几何体密度越低的特点。 这里提到了Lightmass Important Volume这个蛮重要的东西。 Stationary Light的阴影 Stationary Light の影について 参照上面的文章进行的一些总结。 Static Mesh Shadow Stationary Light的阴影贴图是由各自的StaticMesh保持的 这个可以在Stat的NumSM/TextureSM条目里查看 ULightComponent::ReassignStationaryLightChannels Stationary Light的ShadowMap是经由G-Buffer之后的光照计算阶段生成的 再稍微具体一点来说就是：StaticMesh在LightBuilt之后，有了StationaryLight阴影贴图，然后在BasePass阶段，把这个ShadowMaps的值拷贝到G-Buffer中的一个PrecomputedShadowFactors的float4类型的值中去，在写进G-Buffer中之后，在光照计算阶段，光照通过读取自己持有的Index对应的PrecomputedShadowFactor的值来计算像素的阴影。 Movable Object动态物体在StationaryLight的阴影又是什么样子的？ 先是以点光源为例，DirectionalLight使用的是CascadeShadow，有一些不同。 StationaryLight为每一个MovableMesh计算阴影贴图，并把ShadowMap的数据存储到一张巨大的阴影贴图中。 之后逐个对其所有的Mesh的渲染进行阴影的计算。（实际的渲染阶段的阴影计算？） 总结为： Movable Mesh的Stationary Light阴影的计算Cost = 光照范围内的Movable Mesh数 * 每一个物体阴影的生成和渲染cost（PerObject？之前貌似在哪里见过） Stationary Light的阴影，每一个Movable Mesh都会被计算。 像是废话。 Stationary Light的阴影，对于Movable Mesh而言，它会一个一个的进行阴影贴图的计算，然后一个一个的进行渲染。 用实际的数据来展现就是： 在ProfileGPU命令打开的Profiler中的这一项： ShadowDepthFromOpaqueProjected 可以看到Movable Mesh在Stationary Light下的每一个阴影贴图计算的时间，一般都是0.01我感觉。 终于知道这个是什么意思了。 还有这一项： ShadowProjectionOnOpaque 可以看到对于每一个Movable Mesh，Stationary Light的实际的阴影计算所消耗的时间。 （我觉得我应该去复习一下渲染流程了。） 这就会在StationaryLight的光照范围内加入大量的动态物体会使得处理时间变长的原因。 而另一方面，Movable Light对于Movable Mesh阴影的处理不是以每一个动态物体为单位而是以光照为单位，对这个光照范围内的所有物体打包计算。 因此当Movable物体很多的时候，动态光照的方案要优于StationaryLight方案。 Directional Light的阴影上面的都是对点光源和聚光灯的光源来说的不包含直射光。 Directional Light基本上是用Cascade Shadow Map进行的。级联阴影贴图。 在ProfileGPU中的具体项目是： ShadowDepthFromOpaqueProjected WholeScene split1 WholeScene split2 WholeScene split3 ..(maybe) 有一个让处在Cascade Shadow以外的Object以点光源一样进行阴影计算的方式： Cascade Shadow Map &gt; Inset Shadow For Movable Objects 这意思是CascadeShadow是有范围的？ 通过调整 Dynamic Shadow Distance Stationary Light 的距离可以让物体不使用Cascade Shadow。 总结： Static Mesh：Stationary Light事先计算阴影，由各静态mesh保持，当开始渲染的时候直接读取值处理负荷很小。 Movable Mesh：Stationary Light对每一个动态Mesh计算阴影，当动态物体很多的时候，优先选择Movable Light。 Lighting needs to be rebuilt光照烘焙，一般的情况下这个提示是要烘焙光照，但是我遇到了烘焙光照之后还有这个提示的问题。是在我删除掉场景里的所有FoliageStaticMesh之后。 DumpUnbuildLightInteractions在Command Line中输入上述的命令，可以在OutputMessage里面输出需要烘焙的对象信息。 Light Map光照贴图这个部分能说的东西实在时候太多了，要理解的东西也非常多，LightMap具体是个什么东西，用来存储什么数据？搜LightMap的时候又会出现其他的概念，LightMass又是什么？ LightMass在上面也有提到一点。 Unwrapping UVs for Lightmaps当试着搜LightMap的时候，就会出现这篇官方文档-Unwrapping UVs for Lightmaps Lightmass这个有我下载的PDF，有时间总结一下。 Lightmassの仕組み ~Lightmap編~ (Epic Games Japan- 篠山範明) 这篇文章提到的： LightMap和ShadowMap是以Actor为单位各自保持的。 可以在Statistics中的StaticMeshLighting info中看到Actor的各自持有的TextureLM和TextureSM。 LightingTroubleshootingGuide LightTroubleshootingGuide]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的各种文件操作]]></title>
    <url>%2F2019%2F03%2F15%2FC%2B%2B%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[说到LOG的制作那么文件读写就肯定有大费周折了，当然不是我大费周折，我用的人家现成的东西。但是读起来其实挺费劲的，谁让我这么菜呢。 打开文件_sopen_s, _wsopen_s打开文件以供共享。 参考官方文档： _sopen_s,_wsopen_s 操作文件_lseek将文件指针移动到指定位置 官方文档： _lseek, _lseeki64 _write将数据写入文件 官方文档： _write 关闭文件_close关闭文件。 关于这些函数的用法在我最近读的plog里面都有，有空再仔细整理一下吧。 还有一些其他的用法调查一下就知道了，想了想花时间写一下也好但是收益不大，暂时先记下吧。 errno]]></content>
      <categories>
        <category>C++</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么要用size_t]]></title>
    <url>%2F2019%2F03%2F12%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8size-t%2F</url>
    <content type="text"><![CDATA[总的来说就是为了提高代码的可移植性，有效性或者可读性。 Why size_t matters 之后整理一下这篇文章的内容。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[new与malloc的区别]]></title>
    <url>%2F2019%2F03%2F12%2Fnew%E4%B8%8Emalloc%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[new/delete与malloc/free显而易见的区别是，前者会调用对象的构造/析构函数，而后者不会。 再仔细说明就是new的操作是新建对象 ，而malloc只是分配一块内存而已。 在Stack Overflow上有更为详尽的说明，有时间的话好好整理一下。 What is the difference between new/delete and malloc/free?]]></content>
      <categories>
        <category>C++</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的运算符重载]]></title>
    <url>%2F2019%2F03%2F05%2FC%2B%2B%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[运算符重载(operator overloading)只是一种”语法上的方便“（syntactic sugar).也就是说它只是另一种函数调用的方式。 运算符重载有成员与算符和非成员运算符之分，那么这个之间有什么区别呢，应该选择哪一种呢？ 总的来说，如果没有什么差异，它们应该是成员运算符。这样做强调了运算符和类的结合。当左操作数是当前类的对象时，运算符会工作的很好。 但有的时候左侧操作数是别的类对象。这种情况通常出现在输入输出流重载operator&lt;&lt;和&gt;&gt; 时。因为输入输出流是一个基本C++库。 这里就说到了关键了。为了应付各种数据类型的输出，输入输出流的重载就很重要了。 1// 代码之后贴 这里我先暂停一下，说一说为什么要认识运算符重载这个问题。 举例来说，cout这个类是我学C++最早接触的对象了之一了，但是却很不是理解。其实即就是cout对&lt;&lt;运算符进行了重载。 我自己创建了一个Record类，希望这个类能对接在&lt;&lt;后面的数据进行一些操作，比如说接收数据什么的。12Record &lt;&lt; 2;Record &lt;&lt; "str string"; 想这样把后面的数据接收保存在类内变量中。就这样我遇见了下面的代码:12345678// 在Record类内template&lt;typename T&gt;Record&amp; operator&lt;&lt;(const T&amp; data)&#123; m_message &lt;&lt; data; return *this;&#125; 代表着混沌势力的模板登场了（对我来说)。这里就涉及到了函数模板的问题。我看到上面的代码的时候第一反应是，这段代码能直接用？ 答案是肯定的，像类模板的使用那样，指定明确的模板参数类型来特化函数模板使用是可行的，也就是我觉得应该这样做的，但是让编译器从函数的参数中推断出它们的类型将会更方便。 后面的内容就更多了，在别的模板章节中展开更好。 回到上面的代码，m_message &lt;&lt; data 的m_message是什么类型合适呢？是ostringstream。是C++标准库的东西，这样就省得自己一个一个重载数据类型了。方法是个好方法，但是最后我没用上。因为要处理宽字符的问题，涉及到宽窄字符互相转换的问题，试来试去总是出问题，我就Pass掉了，全部交给UE4里的FString类型和TEXT（）来处理了。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++-制作一个静态的单一实例]]></title>
    <url>%2F2019%2F03%2F01%2FC%2B%2B-%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E7%9A%84%E5%8D%95%E4%B8%80%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[制作单一实例，就会想到Singleton，单例模式。在C++里面如何制作一个唯一的一个实例，我只是有一个想法，然后付诸实践。也许这个想法或许是错的。但是重要的是我将这个想法付诸实践的过程，这个过程中我明白了许多知识点，只是不想忘记而已。 指定需要单例化的类首先要选一个适合的类进行单一实例化。举例来说我现在正在制作一个日志系统，故而我希望有一个唯一的实例Logger来管理关于日志的一切。所以我声明了以下： 12345678910111213// Logger.hclass Logger&#123; Logger(); ~Logger();&#125;// Logger.cpp#include "Logger.h"Logger::Logger()&#123;&#125;Logger::~Logger()&#123;&#125; 像这样子。 制作一个单例模板关于这个单例模板其实我也不太清楚具体是为什么而制作的，只是我在学习plog这个日志库的时候看到就学了。首先它是一个模板，怎么用为什么要这么用，需要我理解模板的使用。 12345678910111213141516171819202122232425262728293031template&lt;class T&gt;class Singleton :NonCopyable&#123;public: Singleton() &#123; if(m_instance == NULL) &#123; m_instance = static_cast&lt;T*&gt;(this); &#125; &#125; ~Singleton() &#123; if(m_instance != NULL) &#123; m_instance = 0; &#125; &#125; static T* getInstance() &#123; return m_instance; &#125;private: static T* m_instance;&#125;template&lt;class T&gt;T* Singleton&lt;T&gt;::m_instance = NULL; 先把出现的NonCopyable类的出现放在一边，讨论一下这个模板。 这个模板有一个私有静态属性，类型为T，而且在构造函数里面进行了像下类型转换，使用`static_cast，这个算是骚操作么，我也不太清楚。还有注意取得这个属性的指针函数是静态的，也就是有准备把这个单一实例声明为静态的。 总结一句话来说就是我们得到使用了这个模板并实例化成功的静态实例的指针引用。 引用这里让我有些不舒服的是引用这个词，按照我所理解的，引用和指针并不是一样的： 引用（reference）（&amp;）就像能自动的被编译器间接引用的常量型指针。 关于这一部分我应该是需要用大量的时间去理解的。在C++编程思想第一卷第十一章的-引用和拷贝构造函数里面有较为详细的说明。之后也会有提到。 静态类成员关于静态类成员，Static Members of a C++ Class 里面的说明应该很详细了。 要点在于: 静态类成员只有一份拷贝，无论类被实例化了多少次。 静态类函数只能调用静态类成员。 可以使用类公开的静态成员和静态函数，甚至类没有被实例化。 类静态成员没有this指针，可以用&lt;类名&gt;::&lt;静态成员&gt;来获取。 静态类成员必须在类外初始化 这个是我制作的单例模式的关键理解部分。 关于NonCopyable类这个类可谓是突然出现在我的面前，一查却发现大有来历。就是一个防止类被复制的类。123456789class NonCopyable&#123;protected: NonCopyable()&#123;&#125;private: NonCopyable(const NonCopyable&amp;); NonCopyable&amp; operator=(const NonCopyable&amp;);&#125; 这个地方涉及了许多拷贝构造函数相关的东西，C++编程思想第一卷第十一章-引用和拷贝构造函数的内容，之后需要好好理解。 静态实例实装经过上面的洗礼，我试着写成下面这样：123456789101112class Logger : public Singleton&lt;Logger&gt;&#123;private: static Logger logger;private: Logger(); Logger(const Logger&amp;); ~Logger();&#125;Logger Logger::logger = Logger(); 我在类里面声明了一个自身类的静态实例。加上继承来的静态方法可以取到这个静态实例。然后定义了它。 这里有一个问题就是，当我在类外面定义logger的时候，Logger Logger::logger = Logger();,编译报错了，因为当时我没有加上Logger(const Logger&amp;);这句话。 这句话是什么呢，貌似就是所谓的拷贝构造函数。并且被设置成了私有的。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++编程思想-第16章-模板介绍]]></title>
    <url>%2F2019%2F02%2F22%2FC%2B%2B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC16%E7%AB%A0-%E6%A8%A1%E6%9D%BF%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[记下关于模板的知识与理解。 继承和组合提供了重用对象代码的方法，而C++的模板特征提供了重用源代码的方法。 截止到最近为止我对模板的理解也就之停留在表面:作为一种类型的容器。比如说实现一个可以存储任类型的Stack，有一些共同的操作，当你想使用的时候放入具体的类型进行实例化(instanation)。容器，貌似很好理解的样子。 这也是文章开头所提的到的部分，最最简单且易为理解的部分。 小tips： staic int a[100];这样的写法，编译器会将这个static数组初始化为0. 模板介绍(第十六章)16.3模板语法template这个关键字会告诉编译器，随后的类定义将操作一个或更多未指明的类型。当由这个模板产生实际类代码的时，必须指定这些类型以使编译器能够替换他们。123456789101112131415161718192021using namespace std;template&lt;class T&gt;class Array&#123; enum &#123; size = 100; &#125;; T A[size];public: T&amp; operator[]（int index)&#123; require（index &gt;= 0 &amp;&amp; index &lt; size, "Index out of range"); return A[index]; &#125;&#125;int main()&#123; Array&lt;int&gt; ia; Array&lt;float&gt; fa; // ......&#125; 这时，编译器两次扩展了Array模板【这被称为实例化(instantiation)】，创建两个新的生成类（generated class），可以把它们看做Arrray_int和Array_float（不同的编译器对名称有不同的修饰方法）。这些类就像是手工创建的一样，只是这里是当定义了对象ia和fa后由编译器来创建这些类。我们还会注意到，编译器避免了或者连接器合并了类的重复定义。 16.3.1非内联函数定义希望有非内联函数定义的时候，这时编译器需要在成员函数定义之前看到template声明。 1234567891011121314template&lt;class T&gt;class Array &#123; enum &#123; size = 100; &#125; T A[size];public： T &amp;operator(int index);&#125;;template&lt;class T&gt;T&amp; Array&lt;T&gt; ::operator[](int index)&#123; require（index &gt;=0 &amp;&amp; index &lt; size), "Index out of range"; return A[index];&#125; 关于内联函数和非内联函数的定义在别的章节会有提到。在此不赘述。 在引用模板的类名的地方，必须伴有该模板的参数列表，这样在按照模板生成实例的时候，因为模板参数中的参数修饰类名，以便为每一个模板实例产生唯一的类名标识符。 因此模板的参数列表在引用模板类名的时候，也要有一席之地。 模板的非内联函数定义之前一定要加上template声明。 16.3.1.1头文件 即使是在创建非内联函数定义时，我们还是把模板的所有声明和定义都放入一个头文件中。这似乎违背了通常的头文件规则：“不要放置分配存储空间的任何东西”（这条规则是为了防止在连接期间的多重定义错误），但模板定义很特殊。在template&lt;…&gt; 之后的任何东西都意味着编译器在当时不为他分配存储空间，而是一直处于等待状态直到被一个模板示例告知。在编译器和连接器中有机制能去掉统一模板的多重定义。所以为了使用方便，几乎总是在头文件中防止全部的模板声明和定义。 16.3.3模板中的常量 模板参数并不局限于类定义的类型，可以使用编译器内置类型。这些参数值在编译期间变成模板的特定示例的常量。我们甚至可以对这些参数使用默认值。 12345678910111213141516171819202122232425262728293031323334353637383940414243template&lt;class T, int size = 100&gt;class Array&#123; T array[size];public： T&amp; operator[](int index)&#123; require(index &gt;=0 &amp;&amp; index &lt; size, "Index out of rande"); return array[index]; &#125; int length() const &#123; return size; &#125;&#125;;class Number &#123; float f;public: Number(float ff = 0.0f) : f（ff) &#123;&#125; Number&amp; operator=（const Number&amp; n)&#123; f = n.f; return *this; &#125; operator float() const &#123; return f; &#125; // ???? friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Number&amp; x)&#123; return os &lt;&lt; x.f; &#125;&#125;;template&lt;class T, int size = 20&gt;class Holder&#123; Array&lt;T, size&gt;* np;public： Holder() : np(0) &#123;&#125; T&amp; operator[](int i) &#123; require(0 &lt;=i &amp;&amp; i &lt; size); if(!np) np = new Array&lt;T, size&gt;; return np-&gt;operator[](i）； &#125; intlength() const&#123; returnsize； &#125; ~Holder() &#123;delete np;&#125;&#125;;int main()&#123; Holder&lt;Number&gt; h; // ......&#125; 上面的例子中的size的值没有房放在类中，但是对他的使用就如同是成员函数中的数据成员。 我记录下来上面这段代码的原因还有一个就是懒惰初始化(lazy initialization).上面的Holder中有一个指向Array的指针，而不是指向类型Array的嵌入对象。该指针在构造函数中不被初始化，而是被推迟到了第一次访问的时候。还有等等的稀有的用法。 这个章节还有许多其他内容，但是貌似跟我现在急需要理解的内容相差甚远，暂时保留。 第二卷第五章 深入理解模板关于模板的使用问题，在真正的使用模板之前一定要先让编译器看到模板的声明和定义，比如说在同一个文件里写一个类继承一个模板的时候，模板的声明和定义不能在类的下方，应该先写模板再用。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的强制类型转换-cast]]></title>
    <url>%2F2019%2F02%2F18%2FC%2B%2B%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-cast%2F</url>
    <content type="text"><![CDATA[实在是遇见太多次了，遇见了还看不懂，再不整理就过分了。关于C++中的强制类型转换问题。这次的主角是:stati_cast,dynamic_cast,const_cast,reinterpret_cast。 static_cast提笔要写，先看别人的总结 When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used? 这里我遇见的情况就是static_cast的重要的用法。继承类型的向下类型转换。下面来看看我遇见的神仙代码：123456789101112131415161718192021222324252627template&lt;class T&gt;class Singleton : NonCopyable&#123;public: Singleton() &#123; assert(!m_instance); m_instance = static_cast&lt;T*&gt;(this); &#125; ~Singleton() &#123; assert(m_instance); m_instance = 0; &#125; static T* getInstance() &#123; return m_instance; &#125;private: static T* m_instance;&#125;;template&lt;class T&gt;T* Singleton&lt;T&gt;::m_instance = NULL; 一个单例模板类，读代码的时候，按照这个模板被实例化的是他的子类，顺便这个子类所具有的instance的引用就变成它自己了。我什么时候也能写出这么优秀的代码。 还有其他的强制类型转换，遇见的时候具体分析吧。 const_cast在做各种数据类型匹配的时候，遇到了这样的问题：123// UE4 C++FString text = "111";TCHAR* t_text = *text; 上面是想把FString类型转化为TCHAR*类型的数据。 但是上面的会报错，原因是无法将const THCAR*转化为TCHAR*。那就直接加上关键字const就解决了。但是问题是这个t_text是我设置的即将要传入另外一个函数的参数，它要是设置为常量类型的话就没法传参了。 把常量指针变成普通的指针，就是我接触到const_cast的起因。但是关于它的使用，可不是一句话就能总结的。 const_cast实现的原因在于C++对于指针的转换是任意的，它不会检查类型，任何指针之间都可以进行互相转换。 去const限定12const TCHAR* t_text = "1234";TCHAR* text = const_cast&lt;TCHAR*&gt;(t_text); 将常量指针转化为了正常指针，但是正常情况下不会做这种弱智操作。正常声明就行了，但是有的时候要传参的情况传的不是常量怎么办，那只好强制转换了。 去const限定的操作绝对不是为了修改它的内容，既然声明了常量还要修改那为什么还要声明为常量。既然声明了常量就要贯彻到底。绝对不对const数据进行重新赋值。 根据别人的文章内容，强行修改常量的值会产生未定义行为（Undefined Behavior）,这种行为由编译器决定如何处理。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的文字编码与文字存储类型]]></title>
    <url>%2F2019%2F02%2F14%2FC%2B%2B%E4%B8%AD%E7%9A%84%E6%96%87%E5%AD%97%E7%BC%96%E7%A0%81%E4%B8%8E%E6%96%87%E5%AD%97%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[在准备把函数名字输出的时候遇到了输出乱码的问题。12TCHAR* text = "DLL内容テスト。";UE_LOG(LogTemp, Log, TEXT("TEXT: %s"), text); 在我写这段代码之前我连TCHAR是什么类型都不知道，经过一番的调查，关于文字编码和文字的数据存储类型，了解到了很多。 源码的存储格式关于源码的存储格式，在我现在的地方，使用的大多是日语系统因此在什么都不动的情况下使用的是日语的默认 Japanese(Shift-JIS) 格式。至于怎么确认存储格式的话，在一些编辑器中应该就可以查看。 在Visual Studio 2017中改变文件存储格式 File -&gt; Save as -&gt; 下面Save旁边的箭头 -&gt; save with encoding -&gt; replace -&gt; Encoding 一般比较喜欢的就是Unicode(UTF-8) 就是了，毕竟兼容了英文字母之外的字符。 比如最前面把函数名字输出却遇到了乱码的的方，如果将源码存储为UTF-8格式，就不会出现乱码了。 C++中的字符存储类型关于字符的存储问题，首先要分清楚各种字符的存储类型。 char普通的8位字节类型。 wchar_t宽字符类型，表示范围要远大于char类型，表示类型有16位与32位，具体环境具体判断。Unicode编码字符一般以wchar_t类型存储。 为了让编译器识别Unicode字符串，必须在前面加一个L :1wchar_t * text = L"这是中文字符"; 看到这个L，让我想起了现在看的一个日志开源库里的一段糟心的代码：12345678910#ifdef _WIN32# define _PLOG_NSTR(x) L##x# define PLOG_NSTR(x) _PLOG_NSTR(x)#else# define PLOG_NSTR(x) x#endif// UsagePLOG_NSTR("context"); 简单来说就是一个把字符串添加L的宏，刚开始看到的时候糟心的不行。这段内容使用Unicode编码的意思，但是这里有一个问题： 添加了L也就是说是使用Unicode编码，使用wchar_t数据类型存储。接着上述例子，PLOG_NSTR宏接收的如果不是简单的英文字母而是汉字或者日语，简单地输出会正确的输出吗？ 此时源码的存储格式是否支持Unicode编码会产生影响吗？ Shift-JIS格式的源码配合英文字母是能够正确输出的(源码是DLL) 1234PLOG_NSTR("line@");// outputline@ Shift-JIS格式的源码配合日文内容也是能够正确输出的(源码是DLL) 1234PLOG_NSTR("line内容テスト@");// outputline内容テスト@ 当在UEEditor中实验的时候，Shift-JIS的格式源码没有正确输出。 结论：源码的存储格式应该存储为Unicode格式。在字符编码想要支持Unicode和ANSI两种格式的时候应该添加类似以下的宏123456#ifdef _UNICODE#define __T(x) L##x#define _T(x) __T(x)#else#define _T(x) x#endif 关于为什么不直接使用添加L的宏的原因是：防止数据变量声明和定义时的类型冲突。使用宏避免char与L的宽字符存储类型冲突。 在tchar.h文件中可以找到关于__T(x)宏的定义，貌似不包含这个文件的时候，自己定义也可以。 TCHARTHAR是对上述两种字符存储类型的统一，参考以下：12345#ifdef UNICODEtypedef wchar_t TCHAR;#elsetypedef char TCHAR;#endif 当程序定义了UNICODE的时候TCHAR就是宽字符存储类型即wchar_t，当未定义的时候就是普通的char数据类型。 UE4中的字符类型转换当对字符的存储类型有了一些了解，就来看看他们之间的转换吧。先列出一些参考文章： Charactor Encoding C++宽字符当我觉得我能理解并分别和使用C++中的宽字符的时候，现实告诉我还是太天真了。 先看看这篇文章： 彻底解密C++宽字符 写了很多我看不懂的，就是很复杂。我有照着别的示例程序试着写了一下宽窄字符转换，但是英文还好，没看出来什么变化，但是把日语从const char* 变成const wchar_t*的时候乱码还是乱码。 我使用的是mbstowcs函数来实现的，微软的官网文档也有介绍。官方推荐的是使用mbstowcs_s这个函数。有机会的话可以再试试。 应该有更深层次的原因，只不过我放弃了。借用4的FString和TEXT()宏来解决了。 我在plog中看到的宽窄字符转换跟下面的很像说不定好用：12345678910111213// Unicode字符集下可用//--------------------------------------------------------宽字符串转换到窄字符串char* pC = NULL; wchar_t wStr[20] = L"宽字符串"; int iLen = WideCharToMultiByte( CP_ACP,0,wStr,-1,NULL,0,NULL,NULL); if( iLen &gt; 0 )&#123; pC = ( char* )HeapAlloc( GetProcessHeap() ,0 ,iLen ); if( !pC ) return; WideCharToMultiByte( CP_ACP ,0 ,wStr ,-1 ,pC ,iLen ,NULL ,NULL ); printf( "%s \n", pC ); HeapFree( GetProcessHeap() ,0 ,pC );&#125; 123456789101112//--------------------------------------------------------窄字符串转换到宽字符串char cStr[20] = "这是窄字符串";wchar_t* pWideString = NULL;int iLenWide = MultiByteToWideChar( CP_ACP ,0 ,cStr ,-1 ,NULL ,0 ); if ( iLenWide &gt; 0 )&#123; pWideString = ( wchar_t* )malloc( iLenWide * sizeof(wchar_t) ); if( !pWideString ) return 0; MultiByteToWideChar( CP_ACP ,0 ,cStr ,-1 ,pWideString ,iLenWide ); MessageBox( NULL, pWideString , 0 , 0 ); free( pWideString ); &#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识DLL-在UE4与Unity中使用DLL]]></title>
    <url>%2F2019%2F01%2F28%2F%E5%88%9D%E8%AF%86DLL-%E5%9C%A8UE4%E4%B8%8EUnity%E4%B8%AD%E4%BD%BF%E7%94%A8DLL%2F</url>
    <content type="text"><![CDATA[记录自己逐步认识和掌握DLL的过程。包含了创建DLL，在UE4中使用DLL，在Unity中使用DLL。 新建DLL工程先新建一个简单的DLL工程，然后在里面添加内容，方法可以参照： Linking Dlls 导出函数添加了具体的库的功能之后，需要将函数导出供外部使用。1234567891011121314#pragma once#define DLL_EXPORT __declspec(dllexport)#ifdef __cplusplusextern "C"&#123;#endif int DLL_EXPORT ExportFuncName()&#123; return 0;&#125; // ......#ifdef __cplusplus&#125;#endif 像这样，上述的函数就被导出，能够被外部调用了。 导出函数的时候遇到的问题当我在UE4中使用inline这个关键字的时候，给我报错了。 我在DLL导出函数的时候，导出的函数前面加了inline关键字，所以把导出函数的定义跟声明都写在了头文件里。发生了什么呢？ 在UE4中我获取到了DLL Plugin中的dll库，得到了DLL的Handle，但是准备使用这个Handel取出里面的函数的时候，取出来的是空。函数名什么的都是正确的情况下。 发生上述的情况下我试着去掉DLL中的导出函数的inline声明，声明和定义分开在头文件和cpp文件，就解决了。 回归第一句的事实，貌似UE4C++中对于inline关键字是不支持的。哪怕是动态库中导出来的函数。 UE4Editor中调用DLL在文章最开始的地方提到的链接已经说明的很清楚了。 要点在于: 把制作好的DLL放到特定的文件夹中，一般是Plugin文件夹里面建立一个Plugin。 创建一个类继承BlueprintFunctionLibrary这样蓝图也能使用 声明的函数要是静态的（static） 调用DLL中的函数的步骤是: 定义一个函数指针用来接收DLL中导出的函数(Use typedef to declare a method to store the DLL method) 声明一个Handle来保持与DLL的连接（void* v_dllHandle) 都不为空的时候调用导出来的函数。 123456789101112131415161718192021222324typedef int(*_getFunc)(int a, int b);_getFunc m_getFuncFromDll;void * v_dllHandle;void ULOGBlueprintFunctionLibrary::DLLFunc(int a, int b）&#123; FString dllfilepath = FPaths::Combine(*FPaths::ProjectPluginsDir(), TEXT("DLLLibrary"), TEXT("DLLName.dll")); if(FPaths::FileExists(dllfilepath)) &#123; v_dllHandle = FPlatformProcess::GetDllHandle(*dllfilepath); if(v_dllHandle != NULL) &#123; FString procName = "FunctionName"; m_getFuncFromDll = (_getFunc)FPlatformProcess::GetDllExport(v_dllHandle, *procName); if(m_getFuncFromDll != NULL) &#123; m_getFuncFromDll(a,b); &#125; &#125; &#125;&#125; 使用的方法就像述。 DEBUG DLL关于DLL的DEBUG的问题，直接在工程里面DEBUG的方法我没有头绪。目前的方法是： 选中Build的模式为Release，x64然后编译。在工程文件夹中找到编译完毕的dll文件导入到调用的工程里面进行调用测试。 其他DLL中头文件的引入在使用plog 源码的时候尝试引入头文件的地方：12// for example#include &lt;plog/Util.h&gt; 上面的引入会出错，而把尖括号换成双引号后就好了。 关于这两者的区别： 用尖括号来指定文件时，预处理器是以特定的方式来寻找文件，一般是环境中或编译器命令行指定的某种寻找路径。这种设置寻找路径的机制随机器，操作系统，C++实现的不同而不同，要视具体的情况而定。 用双引号来指定文件时，预处理器是以“由实现定义的的方式”来寻找文件。它通常是从当前的目录开始寻找，如果没有找到，那么include命令就按与尖括号同样的方式开始寻找。 要说DLL不支持尖括号的查找也不是，内置的一些库还是可以使用尖括号来include的，难不成自己添加的文件就要使用双引号吗？ 另外关于头文件返回上一级路径的写法：1#include "../Util.h" 函数名字前面加上&amp; In C++, when the ref-sign(&amp;) is used before the function name in the declaration of a function it is associated with the return value of the function and means that the function will return by reference. Use of ‘&amp;’ operator before a function name in C++ C++类构造函数初始化列表 Constructor member initializer lists 可以参照以上的文章，主要是可以在声明的同时初始化，在构造函数里面的知只是赋值操作，不是所谓的初始化。 比如说类中想要拥有const类型的变量的话，可以利用构造函数的初始化函数列表来给类中常量赋初值。 C++中的函数指针C++运算符重载C++中的流要把流与字符串分开来看，流是对象，可以用来处理字符串。 stringstreamst(), c_str()函数深入理解char*与char[]的差别关于类中静态成员的理解这里需要强调理解的是，类中静态成员的存储位置是静态存储区，只有一个拷贝，无论类被实例化了多少个，静态成员只有一个，还有一些其他的重要的使用方式，之后整理。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中得到函数名字]]></title>
    <url>%2F2019%2F01%2F28%2FC%2B%2B%E4%B8%AD%E5%BE%97%E5%88%B0%E5%87%BD%E6%95%B0%E5%90%8D%E5%AD%97%2F</url>
    <content type="text"><![CDATA[应某个要求，需要在运行过程中打印出运行的信息，即所谓的LOG收集，此时希望一起打印出来的内容包含调用的函数信息。 在Python中就有这种库，直接能得到函数的调信息名字全部打印出来。但是在C++中就没有现成的库。 自己创建一个库？对我来说还是太早了。 在C++中得到函数名字 __func__可以得到函数名字。在函数里面调用输出就好。 123FString fun_name = FString(UTF8_TO_CHAR(__func__));UE_LOG(LogTemp, Log, TEXT("Function name is : %s), *fun_name); __FUNCTION__可以得到类名加函数名。 123FString func_name = FString(UTF8_TO_CHAR(__FUNCTION__));UE_LOG(LogTemp, Log, TEXT("Function name is : %s), *func_name); 以上是在UE4引擎中输出的结果，也有试过__PRETTY_FUNCTION__来输出但是出现了编译错误。 参考文章： 6.49 Function Name as Strings How to get function name in C++]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EffectiveC++-Chapter01-Accustoming-Yourself-to-C++]]></title>
    <url>%2F2019%2F01%2F10%2FEffectiveC%2B%2B-Chapter01-Accustoming-Yourself-to-C%2B%2B%2F</url>
    <content type="text"><![CDATA[Effective C++的第一章内容总结。 条款01：View C++ as a federation of languages.(视C++为一个语言联邦) C Object-Oriented C++ Templete C++ STL 例如对内置（也就是C-like）类型而言pass-by-value通常比pass-by-reference高效，但当你从C part of C++移往Object-Oriented C++，由于用户自定义的（user-defined)构造函数和析构函数的存在，pass-by-reference-to-const往往更好。运用Template C++时尤其如此，因为彼时你甚至不知道所处理的对象的类型。然而一旦跨入STL你就会了解，迭代器和函数对象都是在C指针之上塑造出来的，所以对STL的迭代器和函数对象而言，旧式的C pass-by-value守则再次适用（参数传递方式的选择细节请见条款20）。 条款02：Prefer consts,enums,and inlines to #define.(尽量以const,enum,inline替换#define)123456class GamePlayer &#123;private: enum &#123; NumTurns = 5&#125;; // "the enum hack"补偿作法。以保证NumTurns在编译期间有正确的值 int scores[NumTurns]; // 本是定义的地方，NumTurns未必会有初值，编译器也许会报错&#125; 基于数个理由enum hack值得我们认识。第一，enum hack的行为某方面说较像#define而不像const，有时候这正是你想要的。例如取一个const的地址是合法的，但取一个enum的地址就不合法而取一个#define的地址通常也不合法。 认识enum hack的第二个理由纯粹是为了实用主义。许多代码用了它，所以看到它是你必须认识它。事实上，“enum hack”是template metaprogramming(模板元编程)的基础技术。 12345678#define CALL_WITH_MAX(a, b) f((a) &gt; f(b) ? (a) : (b))// 推荐的写法template&lt;typename T&gt;inline void callwithmax(const T&amp; a, const T&amp; b)&#123; f(a &gt; b ? a : b);&#125; 使用template inline函数（见条款30）也可以获得类似宏带来的效率以及一般函数所有可预料行为和类型安全性（type safety）。 请记住： 对于单纯常量，最好以const对象或enums替换#define 对于形似函数的宏（macs），最好改用inline函数替换#define 条款03：Use const whenever possible(尽可能使用const)]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EffectC++-导读]]></title>
    <url>%2F2019%2F01%2F07%2FEffectiveC%2B%2B-%E5%AF%BC%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[Effective C++ 的导读章节的内容整理，知识点备忘吧。应该会将以后的章节归档到一起。 术语（Terminology)关于声明与定义应该有了初步的认识，在其他的C++学习章节有提到过这之间的区分。 定义式(definition)的任务是提供编译器一些声明式所遗漏的细节。对对象而言，定义式是编译器为此编译器拨内存的起点。 这里有一个对于初始化(initialization)的default构造函数的认知误区： default构造函数是一个可被调用而不带任何实参 这样的构造函数要不没有参数，要不就是每个参数都有缺省值 不是说构造函数就是没有参数的。 explicit关键字应用场景：123456789class B&#123;public: explicit B(int x = 0, bool b = true);&#125;;class C&#123;public: explicit C(inx x);&#125;; 在构造函数的前面加上explicit关键字可以防止被用来执行隐式类型转换(implicit type conversions)，但是仍可以被用来进行显式类型转换(explicit type cnversions). 比如说传参的时候，参数应该是一个类型B的对象1234567void doSomething(B bObject);B bObj1;doSomething(28); // 错误，int跟B之间没有隐式类型转换doSomething(B(28)); // 正确，有显式转型，即cast 虽然上述的使用是我之前知道的但是不知道为什么是正确的。为了防止构造函数被隐式类型转换，把构造函数声明为explicit是一个好的选择。 copy构造函数和copy assignment操作符 copy构造函数被用来“以同型对象初始化自我对象” copy assignment操作符被用来“从另一个同型对象中拷贝其值到自我对象” 1234567891011class Widget &#123;public: Widget(); // 默认构造函数 Widget(const Widget&amp; rhs); // copy构造函数 Widget&amp; operator=(const Widget&amp; rhs); // copy assignment操作符 ...&#125;;Widget w1; // 调用默认构造函数Widget w2 = w1; // 调用copy构造函数w1 = w2; // 调用copy assignment操作符 上述的代码应该足够说明用法，但是需要注意的是看见=的时候要注意：1Widget w3 = w2; // 调用copy构造函数 幸运的是“copy构造函数”很容易个“copy赋值”有所区别。如果一个对象被定义（例如以上语句中的w3)，一定会有一个构造函数被调用，不可能调用赋值操作。如果没有新对象被定义（例如前述的“w1=w2”语句），就不会有构造函数被调用，那么当然是赋值操作被调用。 STLTR1和BoostBoost]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++编程思想手抄]]></title>
    <url>%2F2018%2F11%2F01%2FC%2B%2B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E6%89%8B%E6%8A%84%2F</url>
    <content type="text"><![CDATA[好久没有看书了，最近重拾看书的习惯，放着一大本的全局光照技术不看，想看看C++的内容。因为最近在调查一个工具，看那个人写的源码，深入看下去发现这个人写的代码是真的很好，跟我之前所在现场的时候看见的那个架构十分相似，但是一个是C#，一个是C++。 想要把那份源码记在脑子里似的，希望能够多过几遍，之后肯定会用的上的。 所以言归正传，聊聊现在看的书，C++编程思想。我会记下来我觉得非常有意义的话语，多看多读，能够印在脑子里面是最好，因为有些东西知道了就想会在代码中潜移默化的表现出来。 第一章 对象导言 在面向对象的程序设计中，答案是非常新奇的：编译器不做传统意义上的函数调用。由非OOP编译器产生的函数调用会导致与被调用代码的早捆绑(early binding)，对于这一术语，读者可能还没有听说过，因为从来没有想到过它。早捆绑的意思是，编译器会对特定的函数名产生调用，而连接器将这个调用解析为要执行代码的绝对地址。在OOP中直到程序运行时，编译器才能确定执行代码的地。所以，当消息被发送给一般对象时，需要采用其他的方案。 为了解决这一问题，面向对象语言采用晚捆绑(late binding) 的思想。当给对象发送消息时，在程序运行的时候才去确定调用的代码。编译器保证这个被调用的函数存在，并执行参数和返回类型的检查【其中不采用这种处理方式的语言称为弱类型(weakly typed) 语言】，但是它并不知道将执行的确切代码。 为了执行晚捆绑，C++编译器在真正调用的地方插入一段特殊的代码。通过使用存放在对象自身中的信息，这段代码在运行时计算被调用函数函数体的地址（这一过程将在15章中详细介绍）。这样每个对象就能根据这段二进制的内容有不同的行为。当一个对象接收到消息时，它根据这个消息判断应该做什么。 我们可以用关键字virtual声明他希望某个函数有晚捆绑的灵活性。我们并不需要懂得virtual的使用机制，但是没有它，我们就不能用C++进行面向对象的程序设计。在C++中，必须记住添加virtual关键字，因为根据规定，默认情况下成员函数不能动态捆绑。virtual函数（虚函数）可用来表示出现在相同家族中的类具有不同的行为。这些不同是产生多态行为的原因。 上面的话对我从新理解C++的面向对象的程序的理解是有帮助的。 比如说这段话对于virtual的理解，不是说遇到这种情况的话需要使用virtual关键字，而是清楚地描述了这种情况下，virtual关键字可以帮助我们来实现。以前只是知道这个关键字是用来声明虚函数，但是为什么要声明虚函数呢，什么情况下声明虚函数却不清楚。 第二章 对象的创建与使用这一章虽然都是大白话，但是对于底层的描述说到底还是不是完全理解的，所以需要细致的去理解。 2.1 语言的翻译过程计算机语言转化为机器指令需要翻译器 通常，翻译器分为两类：解释器（interpreter）和编译器（compiler）。 为什么要录下这段话是因为我以为翻译器只有编译器一种呢。Python使用的就是解释器。而C++使用的就是编译器。虽然解释器与编译器之间的界限也很模糊（听说的）。 但是C++的重点在与编译器的理解上。我也有一个独立写一个编译器的梦想…… 2.1.3 编译过程关于编译的过程我看的是云里雾，所以详细了调查了一些文章。 Building C Projects - Alex Smith关于编译过程的详细说明 1.Configuration（配置） 用户系统环境配置的详细参数信息。以便编译器适应不同的用户环境配置。 2.Standard dircetor detection（确定标准库位置） 3.Source file dependency calculation（确定依赖关系） 4.Header file location（确定头文件位置） 5.Header precompilation（头文件的预编译） 6.Preprocessing（预处理） 7.Compilation and assembly（编译） 8.Object file dependency calculation 9.Linking（连接） 编译器把外部函数的代码添加到可执行文件中。静态连接 与 动态连接。 10.Installing（安装） 11.Resource linking 12.Package generation（生成安装包） 13.Dynamic linking（动态连接） 时间关系就直接把编译过程的大概列出来吧。 某些语言（特别是C/C++）编译时，首先要对源代码进行预处理，预处理器（preprocesser） 是一个简单的程序，它用程序员（利用预处理器指令）定义好的模式代替源代码中的模式。预处理指令用来节省输入，增加代码的可读性。（C++程序设计并不鼓励多使用预处理指令，因为他可能引起一些不易发现的错误，这些将在本书的后面分析。）预处理过的代码通常放在一个中间文件中。 编译一般分两遍进行。首先，对预处理过的代码进行语法分析。编译器把源代码分解成小的单元，并把它们按树形结构组织起来。表达式“A+B”中的“A”，“+”和“B”就是语法分析树的叶子节点。 有时会在编译的第一遍和第二遍之间使用全局优化器（global optimizer） 来生成更短，更快的代码。 编译的第二遍，由代码生成器（code generator） 遍历语法分析树，把树的每个节点转化成汇编语言或机器代码。如果代码生成器生成的是汇编语言，那么还必须用汇编器对其汇编。两种情况的最终结果都是生成目标模块（通常是一个以.o或.obj为扩展名的文件）。有时也会在第二遍中使用窥孔优化器（peephole optimizer） 从相邻一段代码中查找冗余语句。 上述内容大致描述了编译过程，应该还涉及到了许多之前尚未完全理解的内容吧。 2.2 分段编译工具 程序可由多个文件构成，一个文件中的函数可能要访问另一个文件中的函数和数据。编译一个文件时，C或C++编译器需要知道在另一个文件中的函数和数据，特别是它的名字和基本用法，编译器就是要确保函数和数据被正确的使用。”告知编译器“外部函数和数据的名称及它们的模样，这一过程就是声明（declaration） 。一旦声明了一个函数或变量，编译器知道怎样检查对它们的引用，以确保引用正确。 这一段话告知了声明这一概念，为什么需要声明，声明用来做什么的。声明就是像编译器告知外部自己的存在以及如何使用自己。 2.2.1 声明与定义之前从未对这两个概念进行细致的区分，或者说根本没有去注意。理解这两个概念会发现，这两个概念，还蛮重要的… 声明（declaration） 是向编译器介绍名字-标识符。它告诉编译器“这个函数或这个变量在某处可以找到，它的模样像什么”。而定义（definition） 是说：“在这里建立变量”或“在这里建立函数”。它为名字分配存储空间。无论定义的函数还是变量，编译器都要为它们在定义点分配存储空间。对于变量，编译器确定变量的大小。，然后在内存中开辟空间来保存量的数据。对于函数，编译器会产生代码，这些代码最终也要占用一些内存。 上面的内容说明了声明跟定义的区别。声明就好比开店之前的宣传，编译器拿着传单知道了这家店的信息，使用情报，而定义就是真正的开店开业，是在上述传单的描述中真实存在的一家店。 在C/C++中，可以在不同的地方声明相同的变量和函数，但是只能有一个定义【有时这称为ODR（one-defifition rule,单一定义规则）】。当连接器连接所有的目标模块时，如果发现一个函数或变量有多个定义，连接器将报告出错。 相同的变量或函数可以多次声明，但是定义只能有一次。 定义也可以是声明。如果定义int x;之前，编译器没有发现标识X，编译器则把这一标识符看成是声明并立即为它分配存储空间。 2.2.1.4变量声明的语法关于变量的声明，由于文章的说明有些多，直接写下自己的理解： 1int a; 这只是一个非常常见的变量声明，这是声明？还是定义？ 这段代码有足够的信息让编译器为整数a分配空间，而且编译器也确实给整数a分配了空间。要解决这个矛盾，对于C/C++需要一个关键字来说明“这只是一个声明，它的定义在别的地方”。这个关键字就是extern，它表示变量是在文件以外定义的，或在文件后面部分才定义。 1extern int a; //声明一个变量但是不定义它 结果就是，对于变量来说简单的声明所提供的情报足以让编译器为其定义。想要停止这种编译器自动的行为就需要使用extern关键字来告诉编译器说我要晚一点再定义这个变量，你先知道有这么个变量就行了。 对于函数来说又是什么样子的呢？1int func1(int length, int width); 1extern int func1(int length, int width); 这两种声明方式有区别吗？ 因为没有函数体，编译器必定把它作为声明而不是函数定义。extern关键字对函数来说是多余的，可选的。C语言的程序设计者并不要求函数声明使用extern，这可能有些令人遗憾； 无论加还是不加，编译器都认为这种定义方式都没有足够的信息去定义一个函数，因此都会被视为声明。通过理解声明与定义的区别，应该可以灵活运用函数与变量的出现位置。 关于extern关键字使用的拓展，目的是加深理解这个关键字的作用。参看文章 C/C++中的extern关键字详解 extern除了告诉编译器这只是一个声明之外，还有一个作用是跟&quot;C&quot;一起连用的时候，是告诉编译器按照C的规则来办事。比如说下面的例子: 1extern "C" void fun(int a, int b); //出于上述的文章中的描述 按照C的规则来翻译这个声明的函数，貌似按照C++的翻译规则，编译器会将函数名变得跟fun不一样，要看编译器的”脾气”。这个跟C++的函数重载特性有关。下面的内容全是选自上面的文章： extern变量 在一个源文件里定义了一个数组:char a[6];在另一个文件里声明extern char *a; 这种声明可以吗？ 答案是不可以。程序运行会告诉你非法访问。原因是类型不同，指向类型T的指针并不等价于类型T的数组，不难发现，这是指针与数组使用中经常出现的盲区知识，若是对于指针的理解只有半吊子的水平还喜欢炫耀的话就会在此栽跟头。正确的声明应该是: 1extern char a[]; 在使用extern的时候应该严格对应声明的格式。 extern常常被用作全局变量来使用，利用其这种特性，在.h文件中使用extern来声明。 extern “C” C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用`extern “C进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。 这应该是在C++环境中使用C函数的时候应该注意的问题。 extern函数声明 原文中举了一个例子，总的来说就是extern对于函数来说就像上文提到的可加可不加，没有明显的区别，仅仅就是一个暗示，可能这个函数会在别的源文件里面定义。 当把全局变量的声明跟定义放在一起的时候，会因为#include的存在而产生重复定义的链接错误。所以：只在头文件中做声明，真理就是这么简单。当然不使用#include语句，将想要提供给外部接口的函数和变量全部使用extern来修饰也是一种方法。你用么，反正我不用。 extern和static （1）extern表明该变量在别的地方已经定义过了，这里要使用那个变量。 （2）static表示静态的变量，分配内存的时候，存储在静态区，不存储在栈上面。 stati作用范围是内部连接的关系，跟extern一样，修饰的部分是跟对象分开存储的，但是却不能被其他对象引用，而extern可以。static修饰的变量只允许对象本身使用。具体差别首先：static跟extern是一对”水火不容”的家伙，也就是说，extern和static不能同时修饰一个变量；其次，static修饰的全局变量声明与定义同时进行，也就是说你在头文件中使用static声明了全局变量之后，它同时被定义了；最后，static修饰的全局变量的作用域只能是本事的编译单元，也就是说它的全局只对本编译单元有效，其他编译单元则看不到它。如： 1234567891011// test1.hstatic char g_str[] = "123456";void fun();// test1.cpp#include "test1.h"void func1()&#123; cout&lt;&lt;g_str&lt;&lt;endl; &#125;// test2.cpp#include "test1.h"void func2()&#123; cout&lt;&lt;g_str&lt;&lt;endl; &#125; 以上的两个编译单元可以连接成功，你可以在各自的.obj文件中找到字符串&quot;123456&quot;的存在。虽然它们有相同的内容，但是存储的物理地址并不一样，就像是两个不同的变量赋了相同的值一样，而这两个变量分别作用于它们各自的编译单元。 一般定义static全局变量的时候，都把它放在原文件中而不是头文件，这样就不会给其他模块造成不必要的信息污染。 extern和const C++中的const修饰的全局常量有跟static相同的特性，即它只能作用于本编译模块中，但是const可以和extern连用来声明该常量可以作用于其他编译模块中，如extern const char g_str[];,然后在原文件中别忘了定义：const char g_str[] = &quot;123456&quot;; 所以当单独使用的时候它就与static相同，而当与extern一起合作的时候，它的特性就跟extern一样了。最后是该作者的提醒：123456const char* g_str = "123456"; // const修饰的是char*而不是g_str// 与下面的写法const char g_str[] = "123456";// const char* const g_str = "123456";` 上面算是对extern关联的一些拓展内容吧。 2.2.1.5包含头文件 #include预处理指令有两种方式来指定文件：尖括号（&lt; &gt;）或双引号。 #include &lt;header&gt;用尖括号来指定文件时，预处理器是以特定的方式来寻找文件，一般是环境中或编译器命令行指定的某种寻找路径。这种设置寻找路径的机制随机器，操作系统，C++实现的不同而不同，视具体的情况而定。 #include &quot;local.h&quot;用双引号时，预处理器以”由实现定义的方式“来寻找文件。它通常是从当前目录开始寻找，如果文件没有找到，那么include命令就按与尖括号同样的方式重新开始寻找。 包含iostream头文件要用如下语句 #include &lt;iostream&gt; 包含头文件的两种方式的区别。 2.2.2 连接 连接器把由编译器生成的目标模块（一般是带.o或.obj扩展名的文件）连接成为操作系统可以加载和执行的程序。它是编译过程的最后阶段。 2.2.3 使用库文件2.2.3.1连接器如何查找库当C或者C++要对函数或变量进行外部引用时，根据引用的情况会选择两种处理方式。 一是如果未遇到过这个函数或者这个变量的定义，就把它的标识符加到未解析的引用列表中，如果连接器遇到过他们的定义，就是已解决的引用。 二是如果连接器没有在目标模块中找到它们的定义，就去查找库。 库有某种索引方式，连接器不会去浏览库中的所有目标模块，而是浏览索引。如果找到了就把函数或变量定义所在的目标模块连接到可执行程序。 这里需要注意的是连接的是目标模块而不是整个库，因此在构造自己的库的时候，一个源码文件只有一个函数，可以减少程序包的大小。 2.2.3.2秘密的附加模块 当创建一个C/C++的可执行程序的时候，连接器会秘密连接某些模块。其中之一是启动模块，它包含了对程序的初始化例程。初始化例程是开始执行C/C++程序时必须首先执行一段程序。初始化例程建立堆栈，并初始化程序中的某变量。 连接器总是从标准库中查找程序中调用的经过编译的标准函数。由于标准库总可以被找到，所以只要在程序中包含所需的头文件，就可以使用库中的任何模块，并且不必告诉连接器去找标准库。 如果使用附加的库，必须把该库文件名添加到由连接器处理的文件列表中。 上面的内容给我揭示了一个盲区，貌似我之前的水平都没有接触到，标准库以外的内容。如果有一天我发现标准库的内容满足不了，我需要别的库的实现，除了在代码中引用之外，我还应该修改连接器维护的一个文件列表，把库的名字加进去。至于应该怎么做，不太清楚了。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的Casting]]></title>
    <url>%2F2018%2F10%2F09%2FUE4%E4%B8%AD%E7%9A%84Casting%2F</url>
    <content type="text"><![CDATA[关于Cast To节点在Blueprint中能够做什么的问题。下面是官方文档中的说明。 Casting in Blueprint 其中的一句话： By using the Get Player Charactor node, then using a Cast To MyCharactor node(the special Charactor Blueprint), you can say if the Player Charactor is MyCharactor, let me access the Variables, Functions, Events or any other special functionality contained within that Blueprint.]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Blueprint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-rebases使用方法]]></title>
    <url>%2F2018%2F08%2F30%2Fgit-rebases%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[git rebase的使用简介]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4:Error_Message整理]]></title>
    <url>%2F2018%2F08%2F16%2FUE4-Error-Message%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[整理在学习UE4的过程中遇到的一些BUG。 syntax error:missing ‘;’ before ‘*’参考链接： syntax error: missing ‘;’ before ‘*’ (First Person Shooter C++ Tutorial) 加了一个关键字class就解决了。虽然不知道是为什么。 LogMaterial: Warning: Material /Game/MagicCircle/Materials/MT_Smoke.MT_Smoke missing bUsedWithInstancedStaticMeshes=True! Default Material will be used in game.#]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>UE4Error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为Actor添加Input事件]]></title>
    <url>%2F2018%2F08%2F16%2F%E4%B8%BAActor%E6%B7%BB%E5%8A%A0Input%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在自己编写Actor的Component的时候想要加上input的事件，但是在UE4中加入这种事件不是那么简单的。这需要对Actor的层级关系有一些了解。 参考链接： C++Is there a way to get input from actor that isn a pawn/character ? Check Keyboard Event in code UE4-学习笔记之二 这篇文章感觉好厉害 &lt;&gt;GamePlay架构(四)Pawn 知乎文章，可以一看]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4-ConstructorHelpers::FObjectFinder]]></title>
    <url>%2F2018%2F08%2F10%2FUE4-ConstructorHelpers-FObjectFinder%2F</url>
    <content type="text"><![CDATA[先来说一说这个问题的起源吧。最近想做一个类似于火焰的特效，是由大量的烟雾粒子组成的那种类似于烟雾的火焰。在制作大量烟雾粒子之前首先要制作出第一个粒子。 制作一个粒子表现的话首先要先实例化一个Instance，这个实例首先依附在一个Acor上。当然，像Unity的脚本函数一样，在Scene中制作一个Actor然后把脚本当做一个ActorComponent的方案是可行的。然后在脚本中使用this-&gt;GetOwner()即可以获取到这个Actor。可以使用this-&gt;GetOwner()-&gt;GetName()来获取到Actor的名字。 参考链接： Get actor from component in c++? 在这里遇见了一个问题。就是在使用UE的UE_LOG打印输出的时候发生了类型错误。 在UE_LOG中使用的都是基础类型，%d,%s等等。 GetName()函数返回的变量类型则是UE的FString类型 解决例子：12// Actor component .cpp fileUE_LOG(LogTemp, Log, TEXT("show value: : %s", *(this-&gt;GetOwner()-&gt;GetName())); 解决案参考： Log issue (passing a FString) Logs, Printing Messages To Yourself During Runtime 能够获取到Parent的Actor就可以根据自身的Actor来制作InstanceStaticMeshComponent了。 InstanceStaticMeshComponent使用方法参照： Using Instanced Static Meshes in C++? 下一步就是发生问题的地方，为制作好的InstanceStaticMeshComponent添加StaticMesh。 上网查查资料就有，这篇文章就行 QUESTION Apply Static Mesh to StaticMesh component 照着做本来不会出错的但是我一运行，UE4肯定Crash。 原因就在于题目所提到的关于ContructorHelpers::FObjectFinder的使用上。总结来说就是这个函数只能运行在类的构造函数中，或者构造函数里调用的函数中。 解决文章： How to use ConstructorHelpers::FObjectFinder? 这个回答中有提到。之后再整理。]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH原理知识普及]]></title>
    <url>%2F2018%2F08%2F06%2FSSH%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A%2F</url>
    <content type="text"><![CDATA[SSH的原理与运用。 参考链接： SSH原理与运用（一）：远程登录 数字签名是什么？ What is a Digital Signature?]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中读取Texture2D的像素值]]></title>
    <url>%2F2018%2F08%2F03%2FUE4%E4%B8%AD%E8%AF%BB%E5%8F%96Texture2D%E7%9A%84%E5%83%8F%E7%B4%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[目的是在UE中获取到一张Texture2D图片的所有像素值，并将这些像素值进行某些处理并保存到另外一个Texture中。 第一步：获取到Texture2D资源Unreal Engine 4 Documentation Referencing Assets 对于高速化来说异步加载资源也是好的解决方案 Ureal Engine 4 Documentation Asynchronous Asset Loading 参考的文章 Accessing pixel values of Texture2D First you need to understand that a texture is normally, a sum of multiple images called MipMaps. MipMaps are down-scaled versions of your images, always in steps of power of 2, so the original image, is, say, 512x512 - this would be the MipMap “0”, then the engine generates the MipMap “1” which is 256x256 and then MipMap “2” which is 128x128, this continues on down to 16x16 I think. The farther away the texture is rendered, the smaller version of the image is used. This means that you need to access the mipmap 0 of your texture. 对上面的答案进行了非常好的总结的文章 UE4 – Reading the pixels from a UTexture2D Reading data from UTexture2D 之后附上完整的代码UE4中的资源管理 Asset Management 拓展知识在代码中看到了static_cast这个语句，竟然不知道是做什么的。查了一下 C++中static_cast, dynamic_cast, const_cast用法/使用情况及区别解析 之后要好好整理一下。]]></content>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4的函数库]]></title>
    <url>%2F2018%2F08%2F02%2FUE4%E7%9A%84%E5%87%BD%E6%95%B0%E5%BA%93%2F</url>
    <content type="text"><![CDATA[在UE4中总会遇见一些不知道是做什么的函数，这篇文章的目的是整理自己遇到的UE4的函数和类，和弄清函数和类的时候遇到的一些问题的解决。 UE4中的类UTexture2DTextureCompressionSettingsTextureMipGenSettingsUpdateResource() Functio作用UTextureRenderTaget2DUreal Engine 4 Documentation: UTextureRenderTarget2D 可以用来存储一个2DTexture数据的类，拥有着许多的成员，文件的位置： C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Classes\Engine\TextureRenderTarget2D.h C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Private\TextureRenderTarget2D.cpp 关于如何实例化这个类，我在网上并没有找到类似的实现，但是在UE4的Blueprint中可以找到一个名为Create Rendr Target 2D的node函数。试着找了一下这个节点的实现函数 C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Private\KismetRendngLibrary.cpp 其中有如下的实现代码：1234567891011121314151617UTextureRenderTarget3D* UKismetRenderingLibrary::CreateRenderTarget2D(UObject* WorldContextObject, int32 Width, int32 Height, ETextureRenderTargetFormat Format)&#123; UWorld* World = GEngine-&gt;GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull); if (Width &gt; 0 &amp;&amp; Height &gt; 0 &amp;&amp; World &amp;&amp; FApp::CanEverRender()) &#123; UTextureRenderTarget2D* NewRenderTarget2D = NewObject&lt;UTextureRenderTarget2D&gt;(WorldContextObject); check(NewRenderTarget2D); NewRenderTarget2D-&gt;RenderTargetFormat = Format; NewRenderTarget2D-&gt;InitAutoFormat(Width, Height); NewRenderTarget2D-&gt;UpdateResourceImmediate(true); return NewRenderTarget2D; &#125; return nullptr;&#125; 或许可以给与一些参照。 UMaterialInstanceDynamicUreal Engine 4 Documentation: UMaterialInstanceDynamic 这个类的作用按照字面意思来推测是用来创建一个动态的材质实例，在UE4的Blueprint中也有相应的节点函数：CreateDynamicMaterialInstance。函数位置 C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Private\KismetMaterialLibrary.cpp 其中的实现代码：1234567891011121314151617181920class UMaterialInstanceDynamic* UKismetMaterialLibrary::CreateDynamicMaterialInstance(UObject* WorldContextObject, class UMaterialInterface* Parent)&#123; UMaterialInstanceDynamic* NewMID = nullptr; if (Parent) &#123; // MIDs need to be created within a persistent object if in the construction script (or blutility) or else they will not be saved. // If this MID is created at runtime then put it in the transient package UWorld* World = GEngine-&gt;GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::ReturnNull); UObject* MIDOuter = (World &amp;&amp; (World-&gt;bIsRunningConstructionScript || !World-&gt;IsGameWorld()) ? WorldContextObject : nullptr); NewMID = UMaterialInstanceDynamic::Create(Parent, MIDOuter); if (MIDOuter == nullptr) &#123; NewMID-&gt;SetFlags(RF_Transient); &#125; &#125; return NewMID;&#125; 可以为该材质添加值的函数实现：1234567891011121314151617181920212223void UKismetMaterialLibrary::SetScalarParameterValue(UObject* WorldContextObject, UMaterialParameterCollection* Collection, FName ParameterName, float ParameterValue)&#123; if (Collection) &#123; if (UWorld* World = GEngine-&gt;GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull)) &#123; UMaterialParameterCollectionInstance* Instance = World-&gt;GetParameterCollectionInstance(Collection); const bool bFoundParameter = Instance-&gt;SetScalarParameterValue(ParameterName, ParameterValue); if (!bFoundParameter &amp;&amp; !Instance-&gt;bLoggedMissingParameterWarning) &#123; FFormatNamedArguments Arguments; Arguments.Add(TEXT("ParamName"), FText::FromName(ParameterName)); FMessageLog("PIE").Warning() -&gt;AddToken(FTextToken::Create(LOCTEXT("SetScalarParamOn", "SetScalarParameterValue called on"))) -&gt;AddToken(FUObjectToken::Create(Collection)) -&gt;AddToken(FTextToken::Create(FText::Format(LOCTEXT("WithInvalidParam", "with invalid ParameterName '&#123;ParamName&#125;'. This is likely due to a Blueprint error."), Arguments))); Instance-&gt;bLoggedMissingParameterWarning = true; &#125; &#125; &#125;&#125; 使用方法是在C++中声明一个材质1234567UMaterialInstanceDynamic* mMaterial;//将mMaterial的材质实例通过Blueprint传递过来mMaterial-&gt;SetScalarParamaterValue("TextureWidth",512);//这样便可以将换递过来的Blueprint中的名为`TextureWidth`(if exist)的Parameter赋值为512了 但还是有许多疑问。 UE4中的函数check()参考链接： When should I use Check()? AddInstance()UE4中的一些类型TextureAddress在Texture.h中看到了这个属性，不太清楚是什么属性，就查了一下。貌似是一种纹理寻址模式。因为有赋值为T_Clamp,Clamp让我有些回想起来在Unity中设置UV的时候有repeat跟clamp等等选项来着，需要调查一下。 D3D11_TEXTURE_ADDRESS_MODE(纹理寻址模式) TextureFilterSRGB是什么参考链接： sRGB - how to be? 【图形学】我理解的伽马校正（Gamma Correction）]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的static关键字]]></title>
    <url>%2F2018%2F08%2F02%2FC%2B%2B%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[static 关键字可用于声明变量、函数、类数据成员和类函数。 之后需要好好整理一下，static关键字的用法。 参考链接： C/C++ 中的static关键字 The static keyword and its various uses in C++]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4的Plugin使用]]></title>
    <url>%2F2018%2F08%2F02%2FUE4%E7%9A%84Plugin%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[制作UE4的插件相当于给UE4引擎添加新的功能模块。UE4的功能模块组成是由Module组成的，关于Module具体是什么，中文翻译就是模块，自己的理解中可以说是文件的单位了。 新建的插件代表着跟UE4本来的功能模块不是从属于一个Module，所以需要为自己制作的插件制作一个属性为Public的公开接口以供UE4引擎调用。 Plugin的Public公开权限一般一个Module中不想公开的源文件都会设置为Private权限，不允许外界的Module访问。要把权限公开，使得其他的模块能够访问的话需要以下两步。 头文件的位置 头文件(.h)放到[\Source\Public]文件夹中去 cpp实现文件放到[\Source\Private]文件夹中去 添加Export用的宏在类的声明中添加一个宏：&lt;大写字母的Module名字&gt;_API 例如：1234UCLASS()class SAYHELLO_API USayHelloFunction : public UBlueprintFunctionLibrary&#123; GENERATED_BODY()&#125; 这样一个名为SayHello的Module的class的权限就变成公开的了。 Tips： 上述的SAYHELLO_API的定义文件位置在Intermediate/Build/Win64/UE4Editor/Development/SayHello/Definitions.SayHello.h。里面定义了DLLEXPORT,DLLIMPORT。 UE会按照Module的单位生成DLL，&lt;ModuleName&gt;_API在自身的Module中会指定DLLEXPORT，在其他的Module中会指定DLLIMPORT。（啥意思？书上就写了这么多。。。） 参考资料： Unreal Engine 4 Documentation - Plugins Unreal Engine 4 C++ 插件介绍 ue4插件开发]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的const修饰符]]></title>
    <url>%2F2018%2F08%2F01%2FC%2B%2B%E4%B8%AD%E7%9A%84const%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[C++中经常会看到const关键字来修饰很多东西，在这里把自己遇到的一些情况收集并整理一下。 参考链接 C++ Const Usage Explanation 关于C++ const 的全面总结]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的静态库与动态库]]></title>
    <url>%2F2018%2F08%2F01%2FUE4%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[库(Library)是什么,库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。 本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种：静态库（.a、.lib）和动态库（.so、.dll）。所谓静态、动态是指链接。 需要知道的除了制作动态库与静态库，还要知道这两种库之间的区别。为什么要制作库。 参考链接： C++静态库与动态库]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的异步处理]]></title>
    <url>%2F2018%2F08%2F01%2FUE4%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[能够熟练的使用UE4中的异步处理应该能够很好的利用程序运行的资源，和计算。除此之外还有并行的处理。目的是要理清UE4中的线程的同步异步，并行操作和标准C++中的线程同步异步，并行操作。 时间有限，暂时记录下关键字： UE C++ ThreadPool 异步处理相关函数： Async Lambda记法 AsyncTask ParallelFor123//函数的位置Engine/Source/Runtme/Cre/Pblic/Async/Async.hEngine/Source/Runtme/Cre/Pblic/Async/ParallelFor.h 异步辅助API FScopeLock]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的C++]]></title>
    <url>%2F2018%2F08%2F01%2FUE4%E4%B8%AD%E7%9A%84C%2B%2B%2F</url>
    <content type="text"><![CDATA[UE C++拥有着自己的库，当然也可以使用C++的标准库(STL)，但是不同的地方还应该好好记载下来，同时也是对C++的一种复习。 1.值类型？指针？在标准C++中，类的声明可以12345ClassExample ObjName;/或者是ClassExample* ObjPtr; 而在UE4中为了统一值类型与指针的规则，想这种类的声明全部使用指针类型，不使用值类型。1UObject* o; 2.UE4生成类对象实例(Instance)直接上例子：12345678//声明UMyClass* MyClass;//生成实例MyClass = NewObject&lt;UMyClass&gt;();//或者MyClass = NewObject&lt;UMyClass&gt;(Owner); Tips: 在构造函数中不能使用NewObject&lt;T&gt;生成其他的对实例。会使程序Crash。如果想生成其他的Object的话使用FObjectInitializer::CreateDefaultSubobject&lt;T&gt;函数 123ASomeActor::ASomeActor(const FObjectInitializer &amp; ObjectInitializer) : Super(ObjectInitializer)&#123; SampleActor = ObjectInitialize.CreateDefaultSubobject&lt;ASampleActor&gt;(this, TEXT("SampleActor"));&#125; 3.Actor的实例化4.Actor的Component实例化1.在UE4C++中试着添加component1.添加SkeletalMeshComponent或许有一天我会再次遇见这个问题，就是想要用C++来写全部的东西。比如说在C++中为一个Actor添加ActorComponent（这个ActorComponent就是要写的C++本体了），这是很顺利。然后再为这个Actor添加一个SkeletalMeshComponent组件。 问题就出现在这里。 我天真的以为在这个ActorComponent中使用this-&gt;GetOwner()-&gt;GetRootComponent()然后创建组件就能成功了。 12// 其他的省略this-&gt;GetOwner()-&gt;GetRootComponent()-&gt;CreateDefaultSubject&lt;USkeletalMeshComponent&gt;(TEXT("SkeletalMeshName")); 然后UE4Editor就驾崩了。 CreateDefaultSubject直接用就行，不用加前面的一串限定，我还不知原因。把前面删了之后就不会崩溃了。而且去View试图中找Actor下面也确实有生成的SkeletalMeshComponent了。 于是我就SetSkeletalMesh之后发现，明明SkeletalMesh上面有值，也就是正确赋值了，Mesh不显示。 对比了一下终于发现这种方法生成的SkeletalMeshComponent，后面带了一个inherited的标识。 去搜了一下inherited skeletal mesh component doesnt show mesh 天杀的这种UE4程序级别的BUG也能被我碰到。都2019年了还没解决么。看样子是15年提的问题。 也许会有别的方式来为一个Actor在C++中创建SkeletalMeshComponent，但是我没有找到。想了想，还是直接用Blueprint吧，当然直接让Actor直接Add一个Component就能解决然后在C++中保留这个组件的ref就行，但是这样的话不是纯C++的话，为什么直接效率一些直接用BP吧。 为什么我C++中创建就是inherited的对象？是创建的姿势不对么… 我也试过用NewObject&lt;USkeletalMeshComponent&gt;来创建过，但可能是因为代码在构造函数里，还没运行，只是编译一下 UE4Editor就驾崩了。 5.从Content(Asset)中加载Object对象数据6.UE4中的容器7.UE4C++中的一些小知识点1.从SkeletalMeshComponent得到AnimationBlueprint123456789// USkeletalMeshComponent::GetAnimInstance()USkeletalMeshComponent * SkeMC = SkeMC_ptr;UAnimInstance* animIns = SkeMC-&gt;GetAnimInstance();// 拓展// Copy one anim instance to another charactorACharactor* ch = /*...*/;UAnimInstance * mi = GetMesh()-&gt;GetAnimInstance();ch-&gt;GetMesh()-&gt;SetAnimInstanceClass(mi-&gt;GetClass()); 8.UE4C++中遇到的一些问题调查1.Pointer to incomplete class type is not allowed在我使用一些组件指针的时候，想要得到组件的名称，使用-&gt;来调用函数的时候就出现了这个问题。 Pointer to incomplete class type is not allowed 上面的链接有解释。 An “incomplete class” is one declared but not defined.E.g. 最终的解决是，好好的把相应的头文件包含进去。不是说可以声明指针就代表这个指针就能调用这个指针代表的类中所有公开函数了。话说，没有好好的包含人家的头文件却能在文件中没问题的声明这个类型的指针，对我来说真是邪门了。UE4真是搞不懂了。 2.C++ Cross Reference头文件的交叉引用，我觉得我本来是遇不见的，或者说遇见了也会不屑一顾，不会去使用的。 但是凡事都有例外不是。 基本来说，程序中出现使用交叉引用的话，就是程序设计出现了重大的问题，基本上需要重新设计了。但是我非要用这种交叉引用是有原因的…当然因为我水平不行是最大的原因。 要怎么解决这个问题呢？ C++交叉引用问题 Resolve build errors due to circular dependency amongst classes 上面的两个文章链接，告诉我怎么解决交叉引用的问题。总结来说就是使用Forward Declaration。 我的解决方案就是对于相互引用的两个类A，B。分别置于不同文件A.h,A.cpp,B.h,B.cpp。我们的希望A中包含B的实例，但同时B中包含A的指针引用。 则此时对B来说，我就是在头文件中引用了A的指针，但是不实际使用A的内容（指针调用），于是就在B.h中添加class A的声明，但是不导入A的头文件。在B.cpp中引入A的头文件对指针加以使用。这样编译器就明白我到底在捣鼓什么了。 C++中前置声明的应用与陷阱 上面的文章解释了前置声明的原理，感觉讲的非常好。]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的智能指针]]></title>
    <url>%2F2018%2F07%2F31%2FUE4%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[对于内存使用的了解，就不得不了解指针。UE4拥有跟C++类似的智能指针，在这里对虚幻4的智能指针库的内容进行一些总结跟提炼，同时也需要对C++的智能指针进行深入的了解。 UE4的智能指针智能指针并不能使用UPROPERTY()，TSharedRef,TSharedPtr,TWeakPtr等等。 参考链接： Unreal Smart Pointer Library C++的智能指针指针的使用伴随着内存泄漏(memory leak)的问题，可能会发生内存泄漏的情况有： new或者malloc出来的内存因为程序员的疏忽忘记释放 程序运行发生错误(throw)，未能执行内存释放程序 所以不是说只要程序员足够谨慎就能够避免指针造成的内存泄漏的问题。 C++11中的智能指针主要在用的智能指针有：unique_ptr, shared_ptr, weak_ptr。 这3种指针组件就是采用了boost里的智能指针方案。很多有用过boost智能指针的朋友，很容易地就能发现它们之间的关间：|std|boost|功能说明||—-|—-|—-||unique_ptr|scoped_ptr|独占指针对象，并保证指针所指对象生命周期与其一致||shared_ptr|shared_ptr|可共享指针对象，可以赋值给shared_ptr或weak_ptr。指针所指对象在所有的相关联的shared_ptr生命周期结束时结束，是强引用。||weak_ptr|weak_ptr|它不能决定所指对象的生命周期，引用所指对象时，需要lock()成shared_ptr才能使用。| 参考链接： C++11中的智能指针 三种智能指针的特性用法参考链接： C++11及C++14标准的智能指针 weak_ptrstd::weak_ptr是一个很好的解决悬空指针问题的方式。使用原生指针（raw pointers）的话不知道现在所引用的资源是否已经被释放。而使用std::shared_ptr来管理的话，std::weak_ptr只管使用，而不关心资源的使用情况，反正也不管理指向的资源。 因为本身std::weak_ptr并不能直接引用到对象，不会影响对象的自动释放，不会影响对象的引用计数，需要使用lock()来升级到std::shared_ptr来进行操作。 参考资料： C++ weak pointer When is std::weak_ptr useful? 比起直接使用new优先使用std::make_unique和std::make_shared参考链接： Item 21: 比起直接使用new优先使用std::make_unique和std::make_shared]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的函数回调实现]]></title>
    <url>%2F2018%2F07%2F31%2FUE4%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%9B%9E%E8%B0%83%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[回调函数的含义，实际上我也不太清楚，搜回调函数得到的关键字有很多：闭包，代理，委托，Wrapper，等等。但有一点我很清楚，这些我都不太懂。 说是在不同的语言中有不同的叫法。其本质上就是一个函数指针，而在汇编层面，就是子程序代码的首地址。每一段编译器先放一个占位符，最后放入实际的值。 上面的话是Unreal用到一些编程技巧里的内容。 UE4中的函数回调(CallBack)C++中应该有许多种方式的回调，UE C++(UnrealEngine中的C++)则是使用的DELEGATE和EVENT来实现。 关于UE C++的代理，存在着以下的几种方式： 静态的Single-cast Delegates Dynamic Single-cast Delegates 静态的Multi-cast Delegates Dynamic Multi-cast Delegates 这几种代理的实现有什么不同需要后续整理，可以参考： What difference betweens delegates? 有的时候需要很好的利用一下UE4的官方论坛，像是Stack Overflow一样。 Dynamic Multi-cast DelegatesDynamic Multi-cast Delegates是唯一的一种可以和UE4的Blueprint联动的代理实现方式。 Dynamic Multi-cast Delegates的UE C++中的声明12345678910//File: CallbackExample.h//Class: ACallbackExampleDECLARE_DYNAMIC_MULTICAST_DELEGATE(FZeroInputDelegate); //没有参数的声明方法UPROPERTY(BlueprintAssignable, Category="UE C++ Book") //BlueprintAssignable属性使得这个代理在Blueprint中也取得到。 -&gt;此处在真正的工程中不应该写注释，会出编译问题FZeroInputDelegate TheZeroInputDelegate;DECLEAR_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FTwoInputsDelegate, float, FloatVal, int32, IntVal); //两个参数的声明方法UPROPERTY(BlueprintAssignable, Category="UE C++ Book")FTwoInputsDelegate TheTwoInputsDelegate; Tips: 参数最大允许有8个。参数的声明类似上述两个参数的声明，先是类型后是参数名。 参数不同的代理声明只需要将上述的数字换成相应参数的英文就可以，比如说八个参数的情况声明代理的语句就会变成：DELEAR_DYNAMIC_MULTICAST_DELEGATE_EightParams 这样制作的代理，可以在UE的Blueprint中获得到这个代理（似乎是作为Event）并进行实现了。别忘了指定Event与Target。即把这个代理委托给一个类的实例(Instance)。在Blueprint中似乎是以Event而存在的，Blueprint中实现的操作是把这个调用的Event登录到这个代理上去。这样在UE C++中调用这个代理，也会调用Blueprint中的事件，执行这个事件的实现部分。 调用Blueprint中的代理实现1234567// File: CallbackExample.cpp// Class: ACallbackExampleauto ACallbackExample::ExecuteDelegate(const float FloatVal, const int32 IntVal) -&gt; void &#123; TheZeroInputDelegate.Broadcast(); TheTwoInputsDelegate.Broadcast(FloatVal, IntVal);&#125; 官方参考链接： Dynamic Delegates EventsBlueprint Event与Blueprint Function关于事件与函数的区别，没有返回值的被叫做事件，有返回值的叫做函数。是否真实需要验证。在UE C++中可以登录Blueprint的事件，通过给UPROPERTY宏添加属性来完成。话说回来这个是函数，应该使用UFUNCTION宏才对，不知道为什么书上这么说。 用于事件声明的属性有两种，区别的方式是是否在UE C++中有默认的实现。 BlueprintImplementableEvent:没有默认实现 BlueprintNativeEvent:拥有默认实现 Blueprint Event,Blueprint Function在UE C++中的声明12345678910111213141516// File: CallbackExample.h// Class: ACallbackExample// BP EventUFUNCTION(BlueprintImplementableEvent, Category="UE C++ Book")void FloatInputEvent(const float FloatVal);UFUNCTION(BlueprintNativeEvent, Category="UE C++ Book")void VectorInputEvent(const FVector&amp; VecValue);// BP FunctionUFUNCTION(BlueprintImplementableEvent, Category="UE C++ Book")float IntInputFunction(const int32 IntInput);UFUNCTION(BlueprintNativeEvent, Category="UE C++ Book")TArray&lt;float&gt; VecArrayInputFuncion(const TArray&lt;FVector&gt;&amp; VecValues); Event的默认实现12345678910111213141516// File: CallbackExample.cpp// Class: ACallbackExample//static FVector TheVector事先声明的属性auto ACallbackExample::VectorInputEvent_Implementation(const FVector&amp; VecValue)-&gt;void&#123; TheVector = VecValue;&#125;auto ACallbackExample::VecArrayInputFuncion_Implementation(const TArray&lt;FVector&gt;&amp; VecValues)-&gt; TArray&lt;float&gt;&#123; TArray&lt;float&gt; Result; for (const auto&amp; Val : VecValue) Result.Emplace(FVector::Dist(TheVector, Val)); return Result;&#125; 以上的代码实装完成之后，继承了上面的CallbackExample类的Blueprint就可以在Blueprint Editor中对上述UE C++中的事件与函数进行重写了。 以上，是对UE中的代理与事件，在可用范围内的总结与实现。但是对于在什么情况下使用这一点上仍然有许多疑问。 为什么要使用Delegate和Event？关于代理的实现，就算明白了也需要知道需要在什么情况下使用代理，否则没有意义。 关于Event在UE4中的Blueprint中应没有委托这一说，全部是以Event的名字来称呼的。 Delegate的使用情况推测1面向对象的说法只是一种理想的情况，总会有想要实现别人功能的情况。比如说ClassA想要实现一个功能，但是明显这个功能是由ClassB负责的部分，要是自己来实现的话不好，所以自己的话，声明一个Delegate，想用的时候就把这个广播出去(Broadcast)，实现了这接口的内容会被调用。 只言片语： 现在我要对一系列数据进行排序，而排序算法可能比较复杂，我不会自己写，我想调用Array.Sort方法，微软为我们提供了快速排序算法。但是这里有一个问题——我要实现自定义排序规则，比如对于字符串，默认的是按字母顺序，但现在我想这样排序： 按字符串长度排序，只有当长度不同时，再按字母排序。 显然，微软不可能提供这样“个性”的排序方法，那是不是说，就必须让我们自己去写快速排序算法呢？不需要！我们只需要使用委托，就能实现这个要求：string[]strs=”I like C# very much”.Split();Array.Sort(strs,Rule);int void Rule(string first,string second){return first.Length==second.Length?first.CompareTo(second):first.Length.CompareTo(second.Length);} 显然，我并不需要知道快速排序算法的逻辑，我只需要告之排序规则，就实现了我的个性排序。 试问：如果没有委托，你如何解决这个问题？ C++中的代理实现代理应该涉及了许多知识，完全理解需要后续的更新整理。 参考链接： C++中实现委托（Delegate） C++实现Delegate Event实例(例子、example、sample) C++委托实现(函数指针，function+bind，委托模式) 高效C++委托的原理]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGl学习内容整理]]></title>
    <url>%2F2018%2F07%2F25%2FOpenGl%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[主要是记录自己学习OpenGl内容。 OpenGL学习网站参考： Learn OpenGL Learn OpenGL中文翻译]]></content>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UnrealEngine着色器开发整理]]></title>
    <url>%2F2018%2F07%2F25%2FUnrealEngine%E7%9D%80%E8%89%B2%E5%99%A8%E5%BC%80%E5%8F%91%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[整理自己在学习Unreal Engine 4着色器过程中遇到的问题和知识点。 Unreal Engine 4设定1. UE4的内置材质Shader函数库位置UE4Shader的编写入门反而相对比较容易，使用自带的各种函数库拉拉线竟然就可以完成。函数库的位置都在: 位置： C:\Program Files\Epic Games\UE_4.19\Engine\Shaders\Private UE4的安装文件夹中 2. Material.cpp文件位置 C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Private\Materials]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的粒子特效]]></title>
    <url>%2F2018%2F07%2F24%2FUE4%E4%B8%AD%E7%9A%84%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[主要是用来记录学习虚幻引擎4的粒子的过程 Particles with Unreal Engine 4先是在UE4提供的官方教程中整理基础的知识点。官方Youtube视频。 Particle Particle Particle System Emitter Actor Particle System Component Cascade Emitter Emitter Module tips: 在Emitter(粒子发射器)的各个Module中，按住alt键拖动可以复制Module 按住shift可以共享Module，即只需要修改一个其他的都会被修改 Type Data Distributions]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Particles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于学习UE4的粒子系统过程中遇到的疑问]]></title>
    <url>%2F2018%2F07%2F20%2F%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0UE4%E7%9A%84%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E7%96%91%E9%97%AE%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[记录刚学UE的一些疑问]]></title>
    <url>%2F2018%2F07%2F18%2FUE4%E4%B8%AD%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[为了记录自己在学习UE引擎过程中遇到的一些疑问点。时间长了之后就会习惯，这是真的。但是为了避免忘记，记在某个位置是最好的。每个小的知识点写成一篇文章的话总觉得很乱。 UE4中常见的知识点C++与C#的不同之处时隔多年见到C++的第一个违和感是头文件，为什么需要写头文件这个问题我找了一些别人写的代码发现了一下几个规则： 在C++的头文件中SampleCode.h中一般都会预先定义一些东西 需要包含的其他头文件 123#include "Engine.h"#include "MyAppUtilities.h"... 定义需要使用的宏 预处理（C++的预处理器需要了解一下） 123//一般常量居多？#define PI 3.1415926... 定义类，类中包含该有的成员， 123456789class SampleClass&#123; //Attributes or functions public: protected: private:&#125; UE4中的C++不同的地方1.UCLASS()宏想要让类与UE4的类库联动的话，就需要这个宏。 UCLASS()大概的使用方法Sample Code:12345678910111213141516171819202122#include "Engine.h" //如果需要使用UE的library的话#include "MyAppUtilities.h"UCLASS()class UMyClass : public UObject&#123; GENERATED_BODY() public: //构造函数(公有的？) UMyClass(); UPROPERTY(BlueprintReadWrite, Category = "MyApp") int32 IntProp; UFUNCTION(BlueprintCallable, Category = "MyApp") float LengthOfSomething(const int32 index); private: TArray&lt;int&gt; IntArrayWork; //标准c++中的数组声明 //std::vector&lt;int&gt; IntArrayWork;&#125; 对于UCLASS()，如果需要继承UE的类库，则都要加上这个。最好声明的类名也以U开头为好？ 但是我觉得这种声明不是跟UE的类库搞混了吗，辨识度低我觉得应该没有这么智障的规则。好的，有这种规则好像。类似的其他的以E,F,I,T,S等等的字母作为变量名的开始。 关于在头文件中添加注释的问题，在UE4的执行中倘若添加了日语(应该中文也一样)的注释，有可能会发生问题。所以在头文件中尽可能的使用英文注释。还有应该避免在各种宏的后面直接追加注释。 就目前的问题来说在UFUNCTION宏的后面直接加入日文注释(UTF-8)的话，会有编译无法通过的问题。所以为了避免上述问题应该尽量： 头文件中使用英文注释 不要直接在各种UE4的宏后面(例如UFUNCTION后)直接添加注释。 UCLASS() 参数的含义CPPExampleActor.h123456789101112131415161718192021#pragma once#include "GameFramework/Actor.h"#include "CppExampleStruct.h"#include "CppExampleEnum.h"#include "CpExampleActor.generated.h"UCLASS(BlueprintType)class ACppExampleActor : public AActor&#123; GENERATED_BODY()public: UPROPERTY(BlueprintReadWrite, EdtAnywhere, Category="UE C++ Book") FCppExampleStruct MyStructProp; UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="UE C++ Book") ECppExampleEnum Type; UFUNCTION(BlueprintCallable, Category="UE C++ Book") float MyActorFunc(const float Input);&#125;; 通过指定UNCLASS()的参数，可以指定类的类型。 BlueprintType表示这个类可以作为Blueprint的变量来使用。 UPROPERTY()的声明，在这个Actor的Detail面板上可以看到该Category下有声明的MyStructProp和Type属性。 具体的BlueprintType的使用例子则仍需要调查。BlueprintType类型能做到的事情。 多个参数 1UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) ) 这个的使用含义现在还不清楚各自代表着什么意思。 USTRUCT()结构体CppExampleStruct.h1234567891011121314#pragma once#include "CppExampleStruct.generated.h"USTRUCT(BlueprintType)struct FCppExampleStruct &#123; GENERATED_BODY() UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="UE C++ Book") float Value; UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="UE C++ Book") int32 Index;&#125;; 构造体的声明名字最好以F开始。其他的基本上使用方法与类相同。 UENUM()枚举类型CppExampleEnum.h12345678#pragma onceUENUM(BlueprintType)enum class ECppExampleEnum : uint8 &#123; None = 0, Foo, Bar&#125;; 对于enum class ECppExampleEnum : uint8这种写法有些迷惑。 class是为了使枚举类型更安全。为什么安全，参考下面的链接。之后整理。 uint8是为了指定枚举器的基础类型。 参考链接: C++11的enum class &amp; enum struct和enum C\C++中的整形提升 C++标准文档-n2347 2.GENERAED_BODY()这一句话必须要写的原因需要调查 3.UPROPERTY() UFUNCTION()使用这个声明的属性跟方法UE的Blueprint可以使用。 UPROPERTY()宏UPROPERTY()的参数的含义 UPROPERTY()没有参数的情况，UE4的Blueprint和Level Editor都不能读取或者修改，但是却可以将这个变量纳入到UE4的GC对象中。比如： 12UPROPERTY()AActor* OwningActor; 这种情况，如果OwningActor拥有了实例化对象，不手动释放也是没有问题的。或者说注意别手动释放了，会出问题的。 UPROPERTY(EditAnywhere, Category=&quot;UE C++ Book&quot;,EditAnywhere属性表示在Level Editor中也可以操作这个属性。 那么Blueprint与Level Editor的差别在哪里，需要调查。 猜测的结果，Blueprint就是那个连来连去的蓝图，可以在那个蓝图的编辑器中取到属性。 Level Editor指的是操作的画面，在Level Editor中可以取到的意思应该是在Detail panel中直接设定或者读取值那样。 UPROPERTY(BlueprintReadWrite, Category=&quot;UE C++ Book&quot;),BlueprintReadWrite表示Blueprint可以读写。 其他的属性，还有meta属性可以查找下面的链接： Property Specifiers Metadata SpecifiersUFUNCTION宏12UFUNCTION(BlueprintCallable,Category = "UE C++")static float FunctionName(const float Variable); 像上面的使用方法，在函数的前面添加UNFUNCTION macro宏可以制作UE4的Blueprint编辑器的函数节点以供调用。在虚幻4的Blueprint编辑器中使用此函数。 4.TArray-UE4中的数组（重要）先上本家，官方文档TArray:Arrays in Unreal Engine。 再上中文翻译虚幻引擎中的数组–TArry:Arrays 5.C++中的静态函数static与UE C++(Unreal Engine C++)的静态函数在C++中的静态函数与非静态函数的执行确实是有差别的。 复习一下C++中的静态函数： static修饰变量 static修饰函数参考文章： C/C++ 中的static关键字 存储类 (C++) C++静态成员函数 C++ static静态成员变量 UE C++中关于静态函数的使用应该大同小异，但是也不排除有差别的可能性。 将来可能会派上用场的文章 クラスにスタティック変数を持たせたい 6.Blueprint函数node(节点)的输入与输出在UE C++中函数的参数对应Blueprint的node的输入pin，函数的返回值则对应着node的输出pin12UFUNCTION(BlueprintCallable,Category="classcategory")bool MyFunc(const int a,int b,const int&amp; c,int&amp; d) 上述的情况下a,b,c三个变量对应着node的三个输入pin，但是return value,d对应着node的输出pin。也就是说：没有const修饰的引用型参数会被分配到输出pin的阵营中。 这里便引申出几个问题 UE C++的函数参数为什么要使用const修饰，使用常量的必要性是什么 万一想要使用const修饰的引用型参数作为node的输入pin怎么办 想要增加node的输出pin的话，除此之外还有别的写法么 Blueprint支持的数据类型很有限 bool uint8 int32 float 7.UE4的Head FileUE4中的头文件有许多中，为了能够分清使用方法把遇到的头文件整理一下 Actor.h一般的写法是1#include "GameFramework/Actor.h" 一般是继承了UE4中的Actor类的话都需要包含这个头文件。 xxx.generated.h比如说1#include "CppGate.generated.h" 这个头文件是有UE4的UnrealHeaderTool自动生成的文件。如果类继承了UObject类并且想要在Blueprint中使用这个类的话，就需要include这个头文件。而且需要把这个头文件放到所有的头文件的最后才行。 8.UE4中的特殊容器1.FVector一个表示3D空间的向量。可以用来表示空间的一个点或者方向。 参考链接： FVector 9.类的初始值设定基础类型变量的初始化可以在声明的同时进行，以外的数据类型(FVector等)初始化需要在构造函数中进行。静态变量的初始化则需要在类外进行。123int ClassExample::static_var; //equle 0//or lik thisint ClassExample::static_var = 4; #pragma once vs include guard打开UE工程看到一些.h头文件的源码的时候看到了#pragma once有些困惑，不知道是做什么用的。于是调查了一下。 总体来说这两个命令都是为了避免同一个头文件被include多次 方式1：1234#ifndef __SOMEFILE_H_#define __SOMEFILE_H_...#endif 方式2：12#pragma once... #ifndef方式这种方式受C/C++语言标准支持，可以保证同一个文件不会被同时包含，也能保证内容完全相同的两个文件（或者代码片段）不会被同时包含。缺点是不同头文件中的宏的名字如果相同，会导致编译器找不到声明的问题。另外由于编译器每次需要打开头文件来判定是否有重复的定义，会导致编译的时间要长。 #progma once方式这种方式是保证“物理存在上”同一个文件不会被包含多次。而不是内容相同的两个文件。而且无法对一个头文件中一段代码做pragma once声明，只能针对文件。当然也不会发生第一种方式的宏名碰撞引发的问题。 使用哪一种方式见仁见智，有好处有坏处。根据情况使用。 附上别人的博客链接: #pragma once与#ifndef解析 时间线比较新的分析: インクルードガードとpragma once stackoverflow上关于上述两种方式的争论: #pragma once vs include guards? C++中的类与结构体参考链接： 详解C结构体、C++结构体 和 C++类的区别 开启HSLS语法高亮HLSL Tools for Visual Studio应该是HLSL的语法编辑器插件，有自动补全的功能，附上下载链接。但是并没有解语法高亮的问题。 下载链接： HLSL Tools for Visual Studio 在VS2017中开启语法高亮（syntax high lighting）虽然不是针对VS2017的解决方案，但是设定之后的确解决的这个问题： 设定顺序： 在VS2017中 Go to Tools -&gt; Options -&gt; Text Editor -&gt; Fie Extension 在这里选择编辑文件的扩展名与文法编辑器，然后添加保存。 这样设定应该里面有效果了。 参考链接： How to get syntax highlighting for alternate file extension for Visual Studio 2010 or 2013? UE4中使用的一些Tip1. 快速制作封闭空间快速挖空一个几何体的制作顺序： Modes panel -&gt; Geometry -&gt; Box -&gt; 设置尺寸 Details panel -&gt; Brush settings -&gt; Hollow 属性check 2.调整模型的模型坐标的原点根据模型的大小来调整模型坐标的原点，顺序： 双击UE4中导入的模型，打开材质编辑器(static mesh editor也叫Material Editor) 点击Show Pivot显示模型坐标，同时在左上角看见，模型的大小 在Detail panel中找到Transform，调整Import Tansiation的数值，移动坐标系 Tool bar -&gt; Asset -&gt; Reimport Model 之后就会发现模型坐标按照指示移动了 3.制作天空球(与雾)感觉要制作出天空的感觉同时还有雾的模糊的时候使用，可以看见太阳就是不知道能否模拟太阳的移动 顺序: 选定平行光源，开启Light -&gt; Atmosphere/Sun light 将Visual Effects -&gt; Atmospheric Fog 拖拽至场景中 Content Browser panel右下的View Options中开启Show Engine Content 在Engine Content中找到BP_Sky_Sphere并将其拖拽至场景中 在BP_Sky_Sphere的Details面板中的Directional Light Actor选定上面的平行光 4.UE4中的Volume应用在UE中使用Volume执行不同的任务可以解决很多问题，比如说： 给玩施加伤害 改变物理定律，在Volume中允许玩家悬浮等等 作为碰撞表面，不允许玩家进入 改变计算关卡光照和可见性方式 等等，出了直接使用Modes panel中的Volume工具之外，也可以直接将几何体笔刷(brush)转化为相应的Volume。Details -&gt; Actor -&gt; Convert Actor -&gt; Volume(that you want) 参考资料： Volume Reference 5.Z-FightingZ-Fighting又Depth Fighting，深冲突。就是贴图会出现闪烁的情况，与实际模型产生交叉融合 z-fighting的出现是的不同面上的像素在z-buffer中的值相近，导致前台取像素的时候一会去这个面的，一会取那个面的。改变照相机的near、far属性会涉及到z-buffer中的值的精度。因为在各个平台上z-buffer位数不同，因此改变near和far能给z-buffer中的值的浮点数部分尽量留出空间，消除z-fighting。 参考： z-fighting在unity中的解决方式 6.将选定的Actor合并为组使用Ctrl+G的快捷键可以快速把选定的Actor(场景的素材)合并为一组，下次选定的时候会选定为一组。便于移动或者复制。 使用Shift+G的快捷键会解除分组。当然这些操作都可以在选中Actor之后: Right Click -&gt; Group进行分组和分解 7.UE4中的Material和Material Function在UE4中偶然看到了这两个材质的声明，发现名字不太一样，需要调查一下。 UE C++中的需要注意的问题1.ConstructorHelpers类的使用就我的理解这个类可以在其他类的构造函数中实例化对象。自己的情况中多为获取在工程中的资源，并不是level中的Actor资源而是单纯的Content文件夹中的某个资源。123456789// 使用实例// SampleActorComponent.cpp中的构造函数USampleActorComponent::USampleActorComponent()&#123; PrimaryComponnetTick.bCanEverTick = true; static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; SampleAsset(TEXT("StaticMesh'/Game/StartrContent/Shapes/Shape_Plane.Shape_Plane'")); sample_mesh = SampleAsset.Object;&#125; 这样就能成功取到Content中的资源，当然不限于StaticMesh其他的类型UMaterial等等的类型都可以取到。需要注意的是 ConstructorHelpers类的使用必须是要在类的构造函数中进行（吃了不少苦头） SampleAsset的资源链接可以直接在UE4的Content文件夹右键资源copy reference中直接取到 关于更多的使用应该在另一篇博文中有拓展。 2.在C++类中为类添加用户输入响应在网上搜了一下如何给一个脚本添加键盘输入事件，也不是那么全，有价值的一个提问是这个 Check Keyboard Event in code 但是试了一下并不好用，就自己的理解来说，基本上想要键盘的输入的事件响应的基本上都应该去继承UE4的PawnActor类去了，而我自己就是想用键盘来调试而已。继承的类是ActorComponent，并不能实现他们的代码。后来找了一找还是有实现方法的。 首先要去UE4的Editor中的Project Settings中的input选项中将自己想要绑定的键位命名并登录。我起的名字就是PressedF等等。 然后就是在c++中实现绑定了：12345678910111213141516171819202122232425262728293031323334// SampleActorComponent.cppvoid USampleActorComponent::BeginPlay()&#123; // 因为要绑定一下键位的事件，所以需要在这里写 this-&gt;GetOwner()-&gt;EnableInput(this-&gt;GetWorld()-&gt;GetFirstPlayerController()); UInputComponent * myInputComp = this-&gt;GetOwner()-&gt;InputComponent; if(myInputComp) // check(myInputComp) &#123; SetupMyPlayerInput(myInputComponent); &#125;&#125;void USampeActorComponent::SetupMyPlayerInput(UInputComponent * myInputComponent)&#123; myInputComponent-&gt;BindAction("PressedF", IE_Pressed, this, &amp;USampleActorComponent::PressedMethod);&#125;void USampleActorComponent::PressedMethod()&#123; // 这里是按下键盘键位之后的动作内容&#125;// SampleActorCompoennt.hclass USampleActorComponent : public UActorComponent&#123; GENERATED_BODY()public: UFUNCTINN(BlueprintCallable, Category = "MyUE4Class") void PressedMethod(); // 这个在头文件的声明一定要使用UFUNCTION宏来修饰否则没有作用 void SetupMyPlayerInput(UInputComponent * myInputComponent);&#125; 完整的使用方法大概就是这样，应该有一篇文章介绍的很详细的但是关掉了页面不太好找了。 3.像Unity一样保存场景中的参照在Unity中把scene中的参照直接拖进脚本的声明公共变量以达到快速参照的目的，在UE4中也有类似的用法。123456789class USampleClass : public UActorComponent&#123; GENERATED_BODY()public: USampleClass(); UPROPERTY(EditAnywhere, Category = "Edit") AActor * targrtActor;&#125; 为属性添加UPROPERTY()宏让变量暴露给编辑器，然后在该脚本的Detail面板上wei该变量找到场景中的Actor参照。虽然不能拖拽了。 4.获取Actor上的Component不知道是不是UE4中获取Actor上的组件就这么麻烦还是我没找到，组件的获取并不是那么单纯的事情。12345// 获取名为targetActor身上的脚本组件（TArray&lt;USampleActorComponent*&gt; Comps;targetActor_p-&gt;GetComponents&lt;USampleActorComponent&gt;(Comps);// 这样Comps[0]的内容应该就是想要的组件的参照了 5.在UEC++中实现代理我在现实中都没怎么用到过得代理，我竟然一次用了这么多。在UE4中代理的制作感觉好简单好方便。之前有一个是在C++中声明代理，但是实现是在蓝图中的，叫Multi-Cast-Delegate好像。这次完全是在C++中声明在C++中实现代理。 再来复述一下代理的情况：一个类想要做一件事儿，但是这件事跟这个类的关系是只想知道这件事做了而已，具体做的内容完全不关心，这件事情的实现是另一个类的分工。这个时候只要在自己的类里面声明一个代理，当想要执行的时候通知那个类就行。就像是事件一样。 1.定义代理类型在UE4中引擎为我们做了大部分，而我们只要用就可以了。首先定义代理的类型。1234567891011#include "CoreMinimal.h"#include "SampleDelegateComponent.h" // 我们需要委托的类头文件声明#include "SampleActoomponent.generated.h" // 这个头文件是自动生成的，没有的话要手动补上去就是自己的文件名加上.generated.h，而且这个声明必须要在所有的声明的最后。原因不清楚DECLARE_DELEGATE(SampleDelegate)UCLASS()class USampleActorComponnet : UActorComponent&#123; // Class Contents&#125; 这样我们便声明了一个类型为SampleDelegate的代理了。 2.声明代理12// 在USampleActorComponent中的声明这个该类型的代理变量SampleDelegate sample_delegate; 3.绑定代理用上一条的方法获取到level中的Actor的参照，然后将代理绑定到这个想要代为我们执行的实例上去。123456789// 取得需要绑定的实例参照if(targetActor)&#123; // 获取到实例身上的脚本组件 TArray&lt;USampleDelegateComponent*&gt; Comps; targetActor-&gt;GetComponents&lt;USampleDelegateComponent&gt;(Comps); // 绑定代理 sample_delegate.BindUObject(Comp[0], &amp;USampleDelegateComponent::MethodWanted);&#125; 4.代理执行剩下的就是在想要的时候执行代理就好了。1sample_delegate.Execute(); 6.动态加载资源关于动态加载资源又是能说一箩筐的话题，这次只记录自己用到的。1UTexture2D * sampleTex = LoadObject&lt;UTexture2D&gt;(NULL, TEXT("Texture2D'/Game/Path..'"), NULL, LOAD_None, NULL); 参数啥的也不太清楚，用的时候按照这个方向查吧。之后的关于如何从零开始制作烟雾特效的教程里应该会出现。 7.动态改变物体材质参数关于UE4的材质，有好多的话要说，关于如何动态的改变一个物体材质的问题要是不是自己非要用C++写蓝图，估计也不会钻研的那么深。 首先是要动态的改变一个材质里面的参数需要我们创建一个动态的材质。也就是说我们需要得到场景中的物体的材质的实例参照，然后以这个参照为模板创建一个动态材质，再把这个修改了的动态材质赋给物体。 老规矩，上代码： .h文件1234// Class内，省略大部分框架代码// 头文件中声明材质UMaterial * target_material;UMaterialInstanceDynamic * target_material_dynamic; .cpp文件12345678910111213141516171819202122232425262728// 构造函数中使用ConstructorHelpers获取到物体的材质static ConstructorHelpers::FObjectFinder&lt;UMaterial&gt; targetMT(TEXT("PATH"));target_material = targetMT.Object;// 随后可以在BeginPlay函数中对动态材质进行初始化target_material_dynamic = UMaterialInstanceDynamic::Create(target_material, this-&gt;GetWorld());// 可以为材质中的变量赋值target_material_dynamic-&gt;SetScalarParameterValue("MaterialParaName",10);// 拓展复习~// 获取一个UStaticMesh上的组件的材质TArray&lt;UStaticMeshComponent*&gt;comps;this-&gt;GetOwner()-&gt;GetComponnets&lt;UStaticMeshComponent&gt;(comps);target_material = (UMaterial*)comps[0]-&gt;GetMaterial(0) // 指针类型强制转换这一步很重要// 更新材质结束之后要赋给物体mesh_comp = comps[0]mesh_comp-&gt;SetMaterial(0, target_material_dynamic);// 下面的是比较重要的一步// 在BeginPlay中实例化动态材质之后需要target_material_dynamic-&gt;AddToRoot();// 完后再EndPlay中将动态材质移除target_material_dynamic-&gt;RemoveFromRoot(); 这个也是吃了苦头的，因为自己非要用C++写，不用蓝图，这东西谁都不会告诉我啊。AddToRoot这个操作让UE的GC不会把我们创建的动态材质给回收掉。而使用的AddToRoot的东西在结束或者不想用的时候RemoveFromRoot，以便回收。哎呀没加的时候UE4崩的不要不要的。 8.UE_LOG输出奇奇怪怪的数据类型总是想输出些什么。使用UE_LOG可以在UE4的Editor输出运行的信息。但是C++嘛，你让它输出FString类型的东西，他不认识就不输出这个时候就像下面这样：1UE_LOG(LogTemp, Log, TEXT("output message %s"), *(FDateTime::Now().ToString())); 使用指针强制转换，我也不知道是个什么原理。 9.FTimerManager定时器定时器是个好东西。但是要怎么用呢？ 首先要获取到这个定时器，在世界中有这么一个定时器：12// 为什么要加 &amp; ，引用的作用应该就是我不知道，不加就报错。我也不知道我是怎么灵机一动加上就好用的。FTimeManager &amp;timer = this-&gt;GetOwner()-&gt;GetWorldTimerManager(); 然后声明一个Handle12// 在.h文件中声明一个Timer Handle供我们使用，一个Handle就是一个定时的名字应该FTimerHandle timer_handle; 最后开始定时：1timer.SetTimer(timer_handle, this, &amp;USampleActorComponent::TimerMethodWnted, 1.0, false); 参数的意思应该一目了然了。 UE4知识拓展主要用来记录一些常见但是需要理解的优先级不高或者不太常用的知识点的拓展。 1.Metadata Specifiers在UE4中的宏UFUNCTION()等等中会看到一些meta修饰符，有各自的用处。 Metadata Specifiers CallableWithoutWorldContext想要记录下这个meta的原因是，我想得到当前调用函数所在的Blueprint的名字。在C++中直接使用__Function__写个宏就可以直接得到调用函数的名字，但是在Blueprint中，没有宏当参数这么便利的方法，得顺便把self当参数传进去。 这就导致我想输出蓝图名字的时候，无论如何都得额外做一个把self传进去的操作。 但是有一天我发现，为什么UE4自带的Print函数就没有传这样的参，而且还把调用蓝图的名字输出来了。看代码就知道了。 在下面的源代码中可以找到UE4自带的Print函数声明定义： Engine\Source\Runtime\Engine\Classes\Kismet\KismetSystemLibrary.h Engine\Source\Runtime\Engine\Private\KismetSystemLibrary.cpp 会找到下面的声明：12UFUNCTION(BlueprintCallable, meta=(WorldContext="WorldContextObject", CallableWithoutWorldContext, Keywords = "log print", AdvancedDisplay = "2", DevelopmentOnly), Category="Utilities|String")static void PrintString(UObject* WorldContextObject, const FString&amp; InString = FString(TEXT("Hello")), bool bPrintToScreen = true, bool bPrintToLog = true, FLinearColor TextColor = FLinearColor(0.0, 0.66, 1.0), float Duration = 2.f); 实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869void UKismetSystemLibrary::PrintString(UObject* WorldContextObject, const FString&amp; InString, bool bPrintToScreen, bool bPrintToLog, FLinearColor TextColor, float Duration)&#123;#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST) // Do not Print in Shipping or Test UWorld* World = GEngine-&gt;GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::ReturnNull); FString Prefix; if (World) &#123; if (World-&gt;WorldType == EWorldType::PIE) &#123; switch(World-&gt;GetNetMode()) &#123; case NM_Client: Prefix = FString::Printf(TEXT("Client %d: "), GPlayInEditorID - 1); break; case NM_DedicatedServer: case NM_ListenServer: Prefix = FString::Printf(TEXT("Server: ")); break; case NM_Standalone: break; &#125; &#125; &#125; const FString FinalDisplayString = Prefix + InString; FString FinalLogString = FinalDisplayString; static const FBoolConfigValueHelper DisplayPrintStringSource(TEXT("Kismet"), TEXT("bLogPrintStringSource"), GEngineIni); if (DisplayPrintStringSource) &#123; const FString SourceObjectPrefix = FString::Printf(TEXT("[%s] "), *GetNameSafe(WorldContextObject)); FinalLogString = SourceObjectPrefix + FinalLogString; &#125; if (bPrintToLog) &#123; UE_LOG(LogBlueprintUserMessages, Log, TEXT("%s"), *FinalLogString); APlayerController* PC = (WorldContextObject ? UGameplayStatics::GetPlayerController(WorldContextObject, 0) : NULL); ULocalPlayer* LocalPlayer = (PC ? Cast&lt;ULocalPlayer&gt;(PC-&gt;Player) : NULL); if (LocalPlayer &amp;&amp; LocalPlayer-&gt;ViewportClient &amp;&amp; LocalPlayer-&gt;ViewportClient-&gt;ViewportConsole) &#123; LocalPlayer-&gt;ViewportClient-&gt;ViewportConsole-&gt;OutputText(FinalDisplayString); &#125; &#125; else &#123; UE_LOG(LogBlueprintUserMessages, Verbose, TEXT("%s"), *FinalLogString); &#125; // Also output to the screen, if possible if (bPrintToScreen) &#123; if (GAreScreenMessagesEnabled) &#123; if (GConfig &amp;&amp; Duration &lt; 0) &#123; GConfig-&gt;GetFloat( TEXT("Kismet"), TEXT("PrintStringDuration"), Duration, GEngineIni ); &#125; GEngine-&gt;AddOnScreenDebugMessage((uint64)-1, Duration, TextColor.ToFColor(true), FinalDisplayString); &#125; else &#123; UE_LOG(LogBlueprint, VeryVerbose, TEXT("Screen messages disabled (!GAreScreenMessagesEnabled). Cannot print to screen.")); &#125; &#125;#endif&#125; 重点是下面 WorldContext=”WorldContextObject”, CallableWithoutWorldContext 这部分。 受这个启发，这个让我们可以不用传入额外的参数（self），并且使用GetNameSafe函数得到名字。 顺便一提，Keywords关键字可以设置搜索的关键字。细节上面的官方文档中有。 道听途说1.关于C++中的资源释放一般在c++中应该是资源的获取与申请（new等等的操作）与资源的释放都是需要程序员手动操作的。但是如果使用了UE管理的资源，比如继承了UE中的类库等等的操作，那么释放这些资源的操作，在UE中会自动释放而不需要程序员的额外操作，反而要是操作了还会出问题。 当然这个问题只是道听途说，未能够验证。 当然需要仔细调查了啊 2.关于UE中UObject的派生对象的垃圾回收问题如果一个UObject的派生类对象中有一个UObject的派生类对象的指针变量，当这个指针变量经过NewObject&lt;&gt;()的操作实例化了之后，这个实例化对象就成为了GC对象（garbage collection）,但是仅仅如此还不足以达到自动回收的目的，像下面这样在声明之前加上UPROPERTY()宏，就不需要显式的delete垃圾回收了。12UPROPERTY()UObject* MyObjectReference; 总结来说，在C++中使用了new等等的方式来申请了一部分空间的话在使用结束的时候需要显式的释放掉，否则的话就会造成内存泄漏。然而上述的使用方式会使得这样声明的实例对象能够得到的资源自动回收。 参考来源: [Question]UObject Pointer References 关于C++好像发现了一个不得了的链接貌似可以在这个链接中找到C++的标准文档，英文文档。 Open Standards]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#中的单例模式-SingletonPattern]]></title>
    <url>%2F2018%2F07%2F15%2FC%23%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-SingletonPattern%2F</url>
    <content type="text"><![CDATA[这次来整理一下C的单例模式，参考的文章是Implementing the Singleton Pattern in C#。 曾经在做一个数据库管理类中经常多次使用了一个数据库管理的实例类对象，每次在新的不相关的类中需要使用数据库操作的时候都重新实例化一个数据库管理类对象，久而久之就觉得有些麻烦。便决定使用单例模式来管理，同时深究一下单例模式与C#中的使用。 算是这篇文章的汉化与总结吧。 –未完–]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Semaphore-信号量]]></title>
    <url>%2F2018%2F06%2F28%2FSemaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Semaphore,中文叫信号量，日语叫セマフォ（= .=）。经常会在多线程的编程中用到。信号量说简单点就是为了线程同步，或者说是为了限制线程能运行的数量。 仔细说明一下就是，信号量会在内部维护一个计数器，当一个线程调用了这个信号量，计数器就会减1，直到计数器减为0，调用这个信号量的线程将会被阻塞，直到有别的线程释放掉一个信号量使其计数器加1。 那么问题就来了，这个信号量维护的这个计数器应该是对线程的死锁有所防护的，也就是说同一时间只有一个线程能过获取这个信号量，而且当线程获取信号量的时候对信号量中的计数器进行减操作是具有原子性的操作。对于这个计数器的保存位置应该深入调查一下。 实例代码：12345678910111213141516171819202122232425262728293031323334353637383940414243using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading;namespace Semaphore1&#123; class Program &#123; //我设置一个最大允许5个线程允许的信号量 //并将它的计数器的初始值设为0 //这就是说除了调用该信号量的线程都将被阻塞 static Semaphore semaphore = new Semaphore(0, 5); static void Main(string[] args) &#123; for (int i = 1; i &lt;= 5; i++) &#123; Thread thread = new Thread(new ParameterizedThreadStart(work)); thread.Start(i); &#125; Thread.Sleep(1000); Console.WriteLine(&quot;Main thread over!&quot;); //释放信号量，将初始值设回5，你可以将 //将这个函数看成你给它传的是多少值，计数器 //就会加多少回去，Release()相当于是Release(1) semaphore.Release(5); &#125; static void work(object obj) &#123; semaphore.WaitOne(); Console.WriteLine(&quot;Thread &#123;0&#125; start!&quot;,obj); semaphore.Release(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS真机安装Build出错]]></title>
    <url>%2F2018%2F06%2F08%2FiOS%E7%9C%9F%E6%9C%BA%E5%AE%89%E8%A3%85Build%E5%87%BA%E9%94%99%2F</url>
    <content type="text"><![CDATA[为了面试，需要用尽一切手段了，把自己的毕业设计的时候做的2D游戏也拿出来了（捂脸）。找到了自己之前保存好的已经编译好的安装包，希望能够平安无事的安装到自己的系统高版本的iPhone7上。但是再次编译的时候果不其然还是要报错。1'__declspec' attributes are not enabled; use '-fdeclspec' or '-fms-extensions' to enable support for __declspec attributes 但是无论是Xcode还是Unity都已经升级的面目全非了，打开以前保存的Unity工程果不其然各种报错。想要解决出现的问题，第一个是NGUI的版本问题，代码中出现的一部分说是已经不支持Unity5.4+了…上网搜了一下，结果没有找到任何解答。 第一下就碰壁，只能再回去找已经编译好的文件的Build错误了。 问题解决继续搜关键词，看到了Unity社区中有一个这个提问：Error “unknown type name __declspec” after Xcode 7.3 upgrade 出问题的代码部分跟我的是一样的:1234567NORETURN static void il2cpp_codegen_raise_exception (Il2CppCodeGenException *ex)&#123; il2cpp::vm::Exception::Raise ((Il2CppException*)ex);#if __has_builtin(__builtin_unreachable) __builtin_unreachable();#endif&#125; 当然我是根本不知道这几行代码到底是干什么的。但是就是出错了…继续往下看，好像看到了一个解决方案: It has helped me: 1) Remove ‘NORETURN’2) Clean build3) Build it Like a hack:) XCode7.3, Unity5.2.2 UPD: XCode7.3, Unity5.3.4f1 - no issue 跟我的情况太像了，抱着试一试的态度，然后…Build通过了，游戏也成功的安装到了我的手机上了。 で？这个NORETURN到底是个什么？ 查了一下发现这个属性不光是Swift中的，C++中也有。所以说我已经厌倦了什么都学，什么都学对自己来说就是什么都学不会。自己之前一段时间看了Swift然后又去干别的，妥妥的全部忘光。 noreturn in Swiftnoreturn是一种属性，被这个属性修饰的函数表示没有任何返回值，函数可以被重写，但是重写之后也必须没有返回值。 具有代表性的函数有：exit(),abort()等等。 这里有一篇介绍Swift的Attributes的文章Swift - Attributes(@attribute) について 【編集中】介绍了Swift中的修饰属性。 noreturn in C++相比之下我更在意noreturn在C++中的作用。试着查了一下What is the point of noreturn? 字面意思看起来是:不返回函数的结果，没有返回值。但实际上跟void funtion还是有很大的区别。 void function运行会返回调用函数，只不过没有返回值。 被noreturn修饰的函数在运行结束之后并不会返回调用函数。 12345678910[[ noreturn ]] void f() &#123; throw "error"; // OK&#125;void g() &#123; f(); // unreachable: 在调用了`f()`之后，下面的代码永远不会执行 std::cout &lt;&lt; "No! That's impossible" &lt;&lt; std::endl;&#125; 别的事情不说，每次发现这种有关语言的语法的地方不明白的时候，就觉得特别打脸。]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>Bugs</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zsh找不到gulp工具包]]></title>
    <url>%2F2018%2F05%2F30%2Fzsh%E6%89%BE%E4%B8%8D%E5%88%B0gulp%E5%B7%A5%E5%85%B7%E5%8C%85%2F</url>
    <content type="text"><![CDATA[不能上网，一上网问题就接踵而来。今天突然看到了hexo博文压缩这个功能，就想着这个可以有，就按照教程安装了gult。安装完运行hexo g &amp;&amp; gulp之后准备舒舒服服的打包的时候，我一向视同己出的zsh弹出来了这个提示1zsh: command not found: gulp 刚装的你跟我说找不到？我信了你的邪。 自己解决应该是有点难度了，只能借用大家的智慧了。在网上搜到了这两篇博文COMMAND NOT FOUNDWITH A NODE MODULE (NPM) SOLUTION与【gulp】zsh: command not found: gulp!!!「急にgulpが壊れた!」と思ったら読む記事完美的解决了我的问题。 原因可以从下面的命令中看出来 1234➜ blog npm root/Users/stone/Documents/mynote/BLOG/blog/node_modules➜ blog npm root -g/Users/stone/node_modules gulp被安装到了个人文件夹中去而不是NPM命令的全局文件夹。 解决办法是运行下面的命令1npm config set prefix /usr/local 再运行一次npm root -g应该就会看到执行后的结果变化12➜ blog npm root -g/usr/local/lib/node_modules 然后再次安装gulp，应该是全局的安装1npm i -g gulp 确认gulp的版本123➜ blog gulp -v[23:25:50] CLI version 3.9.1[23:25:50] Local version 3.9.1 出现了一个CLI版本跟一个本地的版本。嘛，反正是好用了。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown文件转换为PDF文件]]></title>
    <url>%2F2018%2F05%2F29%2FMarkdown%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E4%B8%BAPDF%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近闲来无事(实际上由于跳槽面试的原因忙的要死)，在知乎上看到了一篇搭建博客的文章，看了一眼发现对于我这种WEB盲还挺友好，于是就自己搭建了这个博客。 就在ZH上捞鱼捞的正爽的时候，面试(未)公司发来了要看看我的作品的消息。我一看表现的时候到了，就掏出我刚学的Markdown来写了几篇我的作品的说明文。正当我想把刚build好的html文件打包压缩发送过去的时候，(自动脑补柯南的灵光一闪音效)我发觉事情并不是这么简单。 要是我作死直接发了一堆html过去，估计就别想见到人家了，就算见到了人家公司的HR，估计见面也有不小的概率会被锤。这个时候慌乱的我,手不由自主的打开了谷歌并输入了:How to convert markdown to pdf.然后发现正确的提问用法是:How to convert from markdown to pdf. (；´∀｀)嘛，英语不好这得批评，早晚得去考一次托福… 搜到的第一个是说用谷歌上的插件:Markdown Preview Plus - Chrome Webstore.ドラッグアンドドロップ就可以转换了。什么？ドラ…什么的，打开谷歌翻译:drag and drop.我… 但是利用网上的插件总感觉有些难受，还要上传文件什么的，万一上传到人家服务器上被人家看到了里面的内容就不好了(WEB盲)。于是看到了第二个方法：使用Node.js的工具markdown-pdf 1npm -g install markdown-pdf 安装好工具之后 1markdown-pdf 我的说明文.md 就能生成想要的PDF文件了。浏览生成的PDF文件的时候唯一在意的就是Markdown给隐藏起来的URL链接PDF文件也一并显示了出来。难不成是制作人有意这样，亦或者是机关在作祟，我就暂时不得而知了。因为现在的我得等人家的面试通知。 唉…寝よう]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Markdown</tag>
        <tag>碎碎念</tag>
      </tags>
  </entry>
</search>
