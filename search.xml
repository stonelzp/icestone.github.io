<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[UE4-DeferredDecal的使用和理解]]></title>
    <url>%2Fue4-how-to-use-deferred-decal%2F</url>
    <content type="text"><![CDATA[这次说一下UE4中的Decal的特效，我是没有遇到要我自己写Decal相关特效的任务的，只是觉得知道为好。 这个是Deferred Decal是UE4中的功能，我最先是在尝试优化程序的过程中了解到这个概念的，优化的部分在另一篇UE4-Performance提升–Forced by DBuffer的部分总有提到。 Deferred Decal UE4 Deferred Decal]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Rendering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPN使用中的问题记录]]></title>
    <url>%2Fhow-to-use-vpn%2F</url>
    <content type="text"><![CDATA[最近回国有点需要便购买了VPN的服务，这篇文章目的是为了记录我使用VPN的过程中遇到的一些问题，应该以后也会频繁用到做个备忘，以应付一些相似的问题。 VPN选择千针网络 感觉是灰色地带就不介绍太多，只是做个备忘。 Git设定在设置好了VPN之后，准备打开GitHub遇见了打不开登录界面的问题，这就很难受了，本来主要的目的就是为了使用GitHub。 GitHub网页登录打不开GitHub，明明已经设置好了，谷歌也好youtube也好都能打开，GitHub就是打不开。后来才解决。 需要打开VPN代理的全局模式(Global Mode)，这样就可以了。 但是这个模式估计是所有的网站都要跑流量的但是我不确定，注意一下为好。 GitHub命令行远程连接还有就是使用VPN的话命令行那里也是不能直接和GitHub通信的，不能push不能pull，需要为Git设置代理。 设置全局代理1git config --global http.proxy 127.0.0.1:1087 查看全局代理1git config --global http.proxy 取消全局代理1git config --global --unset http.proxy 代理地址和端口依设定而异，反正就是那个意思。 估计到我回日本的时候需要执行取消全局代理的操作。 还有本地和全局的区分，但是也就是把--global换成--local的区别。 其它遇到的问题vim-markdown我之前有设置过MarkdownPreview类似的预览插件，在用Vim打开一个MD扩展文件的时候就会自动打开浏览器页面预览，但是当我使用VPN的时候，预览页面就加载不出来了，貌似是端口被占用？我想查一下但是忘了之前使用什么设置的这个插件，也不知道怎么修改预览的端口号，反正关了VPN就好用了。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VR-脚步声检测功能实现]]></title>
    <url>%2Fvr-footstep-detection%2F</url>
    <content type="text"><![CDATA[也算是业务相关吧，业务要求要只用VR头戴设备检测脚步声，这里我根据公司前辈的工作内容进行了一些改良，主要是利用VR设备移动的时候的前后上下的加速度和速度来判定脚步。准确率正常情况下有90%以上吧。 这里我主要的灵感来源是这篇文章 CSS3人行走动作图解和动画实现 根据这种分解的例子找到判定的条件。 代码实现的话有时间贴上，并说明。]]></content>
      <categories>
        <category>VR</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Assembly-CSharp中的程序集]]></title>
    <url>%2Fassembly-csharp%2F</url>
    <content type="text"><![CDATA[在接触Unity的过程中，一直不清楚Assembly这个单词到底是什么意思，中文翻译是程序集，但是具体是个什么东西一直没有一个准确的概念。这次准备搞懂它并且对反射这个概念进行一次透彻的了解。 Assembly-程序集 .NET 中的程序集官方文档说明 程序集构成了 .NET 应用程序的部署、版本控制、重用、激活范围和安全权限的基本单元。 程序集是为协同工作而生成的类型和资源的集合，这些类型和资源构成了一个逻辑功能单元。 程序集采用可执行文件 (.exe) 或动态链接库文件 (.dll) 的形式，是 .NET 应用程序的构建基块 。 它们向公共语言运行时提供了注意类型实现代码所需的信息。 就像一个应用程序一样，在Windows中这个应用程序会有exe文件和若干dll文件。还有一些其他的我不知道的文件，这些都是程序集的一部分。这就是一个程序集，准确与否我也不确定。反正上面的我理解就是这个意思。 关于Assembly的一些要点的话在上面的链接中可以确认，有时间再整理一下吧。 Reflection-C#中的反射机制 反射 (C#)官网的说明跟没有说明一样，还是得参考其他的文章的使用。因为具体要怎么使用，为什么要使用反射对我来说还是一个疑问，使用反射有什么好处呢？ C#反射机制 反射是.NET中的重要机制,通过反射,可以在运行时获得程序或程序集中每一个类型(包括类、结构、委托、接口和枚举等)的成员和成员的信息。有了反射,即可对每一个类型了如指掌。另外我还可以直接创建对象,即使这个对象的类型在编译时还不知道。 运行时能够获取程序或程序集中的的成员情报。利用这些情报可以做很多的事情。 话是这么说我还不太清楚直接使用DLL中的情报有什么不同。就我的经验是不知道DLL中的开发的接口的时候也是无从下手，是不是使用反射就可以某种意义上了解DLL的实现和开放的接口或者函数，利于处理。当然EXE也是一样。 反射的使用System.Reflection 命名空间 System.Reflection 命名空间包含通过检查托管代码中程序集、模块、成员、参数和其他实体的元数据来检索其相关信息的类型。 这些类型还可用于操作加载类型的实例，例如挂钩事件或调用方法。 若要动态创建类型，请使用 System.Reflection.Emit 命名空间。 反射相关类System.Type类通过这个类可以访问任何给定数据类型的信息。 获取给定类型的Type引用有3种常用方式 使用C# typeof运算符 1Type t = typeof(string); 使用对象GetType()方法 12string s = "grayworm";Type t = s.GetType(); 还可以调用Type类的静态方法GetType() 1Type t = Type.GetType("System.String"); 官方文档说明：Type 类 System.Reflection.Assembly类它可以用于访问给定程序集的信息，或者把这个程序集加载到程序中。 官方文档：Assembly类 在官方文档中似乎例举了一些使用方法，暂时我并没有什么需要使用这个反射机制。但是貌似Unity中也会使用这个特性。下次当我决定使用一些DLL等的外部链接库的时候再好好研究并实现这些个特性。 不是往后推，后面对于自己的项目肯定会加入一个Log收集的动态链接库，那个时候一定要把两种链接方式都总结一下。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity-使物体旋转的功能脚本]]></title>
    <url>%2Funity-make-object-rotating%2F</url>
    <content type="text"><![CDATA[记一个使物体旋转的功能脚本，感觉这个功能时不时的会遇到，每次写的时候都挺绕的，不如记下来。 实现功能实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122using UnityEngine;using System;namespace Clown.Utility&#123; [Serializable, AddComponentMenu(&quot;Clown/Utility/Make Object Rotating&quot;)] public class MakeObjectRotating : MonoBehaviour &#123; [SerializeField] private bool clockWise = false; [SerializeField] private bool rotateAxisY = true; [SerializeField] private bool rotateAxisX = false; [SerializeField] private bool rotateAxisZ = false; [SerializeField] private float rotateSpeed = 0.0f; [SerializeField] private bool hasEnterTime = false; [SerializeField] private float enterTime = 4.0f; [SerializeField] private bool hasExitTime = false; [SerializeField] private float exitTime = 2.0f; bool isRotating = false; float speed = 0.0f; bool rotatingSwitch = false; public void OnEnable() &#123; rotatingSwitch = true; &#125; private void Update() &#123; var angles = transform.rotation.eulerAngles; var anglesY = angles.y; var anglesX = angles.x; var anglesZ = angles.z; if (isRotating) &#123; if (!rotatingSwitch) &#123; if (hasExitTime) &#123; speed -= (rotateSpeed / exitTime * Time.deltaTime); if (speed &lt; 0.0f) &#123; speed = 0.0f; isRotating = false; return; &#125; anglesY -= rotateAxisY ? (speed * Time.deltaTime) : 0f; anglesX -= rotateAxisX ? (speed * Time.deltaTime) : 0f; anglesZ -= rotateAxisZ ? (speed * Time.deltaTime) : 0f; &#125; else &#123; isRotating = false; speed = 0.0f; return; &#125; &#125; else &#123; anglesY -= rotateAxisY ? (rotateSpeed * Time.deltaTime) : 0f; anglesX -= rotateAxisX ? (rotateSpeed * Time.deltaTime) : 0f; anglesZ -= rotateAxisZ ? (rotateSpeed * Time.deltaTime) : 0f; &#125; &#125; else &#123; if(!rotatingSwitch) &#123; enabled = false; return; &#125; if (hasEnterTime) &#123; speed += (rotateSpeed / enterTime * Time.deltaTime); if (speed &gt; rotateSpeed) &#123; speed = rotateSpeed; isRotating = true; &#125; anglesY -= rotateAxisY ? (speed * Time.deltaTime) : 0f; anglesX -= rotateAxisX ? (speed * Time.deltaTime) : 0f; anglesZ -= rotateAxisZ ? (speed * Time.deltaTime) : 0f; &#125; else &#123; isRotating = true; anglesY -= rotateAxisY ? (rotateSpeed * Time.deltaTime) : 0f; anglesX -= rotateAxisX ? (rotateSpeed * Time.deltaTime) : 0f; anglesZ -= rotateAxisZ ? (rotateSpeed * Time.deltaTime) : 0f; &#125; &#125; angles.y = anglesY; angles.x = anglesX; angles.z = anglesZ; transform.rotation = Quaternion.Euler(angles); &#125; public void SetValueToRotate(bool val) &#123; rotatingSwitch = val; &#125; &#125;&#125; 使用的话，就在合适的时间调用SetValueToRotate或者OnEnable函数就好了，当然使用条件不一样注意一下，我就不写了。 这里我想着应该可以再优化一下代码结构的，但是想想值不值得还是两说，暂时也没有什么非常棒的想法。 这里还有就是我本来想把全部都写在项目文件里的，之前我只是实现了Y轴的旋转，因为项目面基本上不会出现其他轴的旋转了我就没有把全部实现都提交，也许会减轻一些处理吧，心理上的。 这里再贴一下Editor扩展的实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960using UnityEditor;using Project.Utility;[CustomEditor(typeof(MakeObjectRotating))]public class MakeObjectRotationInspector : Editor&#123; protected SerializedProperty clockWise; protected SerializedProperty rotateAxisY; protected SerializedProperty rotateAxisX; protected SerializedProperty rotateAxisZ; protected SerializedProperty rotateSpeed; protected SerializedProperty hasEnterTime; protected SerializedProperty enterTime; protected SerializedProperty hasExitTime; protected SerializedProperty exitTime; private void OnEnable() &#123; clockWise = serializedObject.FindProperty(&quot;clockWise&quot;); rotateAxisY = serializedObject.FindProperty(&quot;rotateAxisY&quot;); rotateAxisX = serializedObject.FindProperty(&quot;rotateAxisX&quot;); rotateAxisZ = serializedObject.FindProperty(&quot;rotateAxisZ&quot;); rotateSpeed = serializedObject.FindProperty(&quot;rotateSpeed&quot;); hasEnterTime = serializedObject.FindProperty(&quot;hasEnterTime&quot;); enterTime = serializedObject.FindProperty(&quot;enterTime&quot;); hasExitTime = serializedObject.FindProperty(&quot;hasExitTime&quot;); exitTime = serializedObject.FindProperty(&quot;exitTime&quot;); &#125; public override void OnInspectorGUI() &#123; // base.OnInspectorGUI(); serializedObject.Update(); EditorGUILayout.PropertyField(clockWise); EditorGUILayout.PropertyField(rotateAxisY); EditorGUILayout.PropertyField(rotateAxisX); EditorGUILayout.PropertyField(rotateAxisZ); EditorGUILayout.PropertyField(rotateSpeed); EditorGUILayout.PropertyField(hasEnterTime); if (hasEnterTime.boolValue) &#123; EditorGUI.indentLevel++; EditorGUILayout.PropertyField(enterTime); EditorGUI.indentLevel--; &#125; EditorGUILayout.PropertyField(hasExitTime); if (hasExitTime.boolValue) &#123; EditorGUI.indentLevel++; EditorGUILayout.PropertyField(exitTime); EditorGUI.indentLevel--; &#125; serializedObject.ApplyModifiedProperties(); &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity-Timeline的使用]]></title>
    <url>%2Funity-timeline%2F</url>
    <content type="text"><![CDATA[最近见到了好多Timeline的使用实例，但是对于Timeline的系统的学习和了解却没有。是时候仔细整理一下了。 TimelineTimeline中 「Marker」と「Signal、Signal Receiver」参考【Unity】Timelineからメソッドを呼ぶ新機能 「Marker」と「Signal、Signal Receiver」这篇文章学习。 这个功能在2019.1.a11之后的版本能够稳定使用。 由于并不是正式版本中的功能，今后可能会有变化。 Timeline Signal の使用方法 Animation这一部分难以归类，主要是想要记录一下在Timeline中播放AnimationClip的问题的。 使用Timeline来播放动画十分方便，但是不足以应对所有情况。比如说两个动画之间的切换就是十分生硬的切换。这里有两种情况。 同一个Timeline里面的AnimationClip切换: 这是最为普通解决方案也最是简单，那就是在Timeline中放置AnimationClip的时候，把前一个Clip的最后面的部分和后一个Clip的前面的部分叠加放置。没想到吧，在Timeline里面动画的片段是可以叠加放置的。就类似于旧Animation系统里面的CrossFade一样。 Timeline外的AnimationClip和Timeline内的AnimationClip动画状态的切换：这个我不知道更好的解决方案，自己的解决方案是在AnimatorController中做好动画之间的切换部分，然后在Timeline中加入Signal调用Animator的Tirgger进行Animation的切换。 再详细一点的说就是，将原本处在Timeline中的AnimationClip移到这个对象的AnimatorController中进行处理了。这里需要提及的是，AnimatorController的处理是挺耗时间 的，严重到旁边的大佬跟我说最好少使用的那种地步，实际上我也不清楚，既然人家说了就少用吧。但是想想那Timeline的使用，播放动画的时候也是需要这个对象有Animator组件的，也就是说也是用这个组件进行播放的。然后我看了一下，当不指定某一个AnimatorController(我们制作的AnimatorController)的时候，有一个叫RuntimeAnimatorController的东西顶替了指定的位置，Timeline有这个就可以播放AnimationClip而不需要我们指定AnimatorController，当然硬要指定也不是不可以。 但是最终我还是用了自己的AnimatorController……因为不知道更好的办法了。在完成可以让动画之间的切换如丝般顺滑之前要注意的是： AnimatorController :HasExitTime 一定要取消，然后调整Setting中的参数，过渡的时间等等。 AnimatorController: Parameters 参数的设置主要是为了方便脚本在运行时切换，这里随机应变就好。 Timeline： Signal的制作。这就是这篇最开始的内容了，为什么要做这个就是因为方便调整时间或者方便其他比如设计师修改，毕竟你把人家的AnimationClip都移走了。 Scripts :最关键的脚本，要注意的是一是为Signal提供函数，二是设置AnimatiorController的状态。 暂时就想到这么多。 另外在对导入的模型的动画进行编辑的时候，发现了一下小的知识。 Unity中对导入的模型Edit的时候，可以对导入的AnimationClip进行自定义，以其中一段的Clip为基础进行截取的操作，这样就可以方便的增加自己想要的片段。 比如说想要在一段长的片段中截取Idle Clip，可以在Clips中添加新的片段，然后选定时间，调整Loop Time，方便循环播放，然后别忘了Loop Pose，这个可以让你截取的部分无缝循环播放。(这是Unity说的) 暂时没有在Unity中发现有能导入模型的动画而不导入模型的功能。这点不同于UE4的导入。 还有就是我在Inspector里面看到了下面的错误： The clip range is outside of the range of the source take. 虽然一眼就知道这个的原因是为什么，设置clip的Start和End的时候是从-300开始的，什么？还能从负数开始？这个我肯定不知道，但是事实就是这个项目里，这个clip，里面的Start，里面写着-300。 前几天遇见一个BUG，就是当把Signal放到Timeline的第0帧的时候，这个Signal不会被执行，第二帧也不行。据说是之Timeline的BUG。 参考文章: 《Unity備忘録》3DCGで設定したアニメーションをUnityで制御する方法]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4-踩坑指南]]></title>
    <url>%2Fue4-fucking-moment%2F</url>
    <content type="text"><![CDATA[在UE4中踩了不少的坑，这篇主要是用来介绍自己在使用过程中由于粗心或者知识浅薄而掉进去的大坑。 关于蓝图蓝图这个东西我看不顺眼好久了，方便那是非常方便，但是也不能只看脚下的路不是么，等到时间长了，写的多了，那变量维护起来就是爽到飞起了，前期轻松后期地狱。 GetDisplayName ブループリント周りで注意: 「Get Display Name」ノードは本番で使わないでください。エディタからのゲーム呼び出しとエディタなしのリリースモード等で挙動が異なります。 自己作死用了这个节点，而且还用这个取出来的数据作为判断条件，这不是找死么。 蓝图的话请使用GetObjectName节点。C++的话GetName()函数。]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity-异步处理]]></title>
    <url>%2Funity-async%2F</url>
    <content type="text"><![CDATA[主要为了理解async/await关键字的意义。 async/awaitと同時実行制御]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity-Serialization理解]]></title>
    <url>%2Funity-serialization%2F</url>
    <content type="text"><![CDATA[这个概念对于Unity来说非常重要。了解这个概念应该会对开发的效率有很大的提升。 在最开始应该理解一下什么是序列化。 Serialization 序列化 序列化又称串行化，是.NET运行时环境用来支持用户定义类型的流化的机制。其目的是以某种存储形式使自定义对象持久化，或者将这种对象从一个地方传输到另一个地方。 Unity中非常多非常多的场景中使用了序列化，参考一下这篇文章Serialization in Unity，深入理解一下Unity中的序列化。 下面我就对这篇文章的内容进行整理，主要是做笔记。 Serialization in Unity先是比较重要的内容摘抄一下。 Storing data stroed in your scripts. 保存你脚本中保存的数据。是大多数人最熟知的功能。 Inspector window. Inspector窗口不是经过C#的API来了解内部的数据结构或者属性，它要求对象序列化数据然后显示序列化之后的数据内容。 Prefab. prefab是一个或多个对象和组件的被序列化的数据流(serialized data stream)。一个prefab实例(instance)实际上是一组应该被应用到这个被序列化数据实例的修改内容(A prefab instance is a list of modifications that should be made on the serialized data for this instance.)。Prefab这个概念实际上只存在于Editor阶段，当Unity开始Build工程的时候就会把这些修改应用到这些被序列化的数据流上，并且当这些修改被实例化，被实例化的数据对象并不会知道它们曾经是Editor编辑器中的Prefab。 Instantiation. 当你调用Instantiate()函数，对prefab，scene中的gameobject，或者是其它的能被序列化的数据(everything that derives from UnityEngine.Object can be serialized)的操作结果，我们将会序列化对象，然后创建一个新的对象，然后反序列化对象数据到新的对象数据中。 (We then run the same serialization code again in a different variant, where we use it to report which other UnityEngine.Object’s are being referenced. We then check for all referenced UnityEngine.Object’s if they are part of the data being Instantiated(). If the reference is pointing to something “external” (like a texture) we keep that reference as it is, if it is pointing to something “internal” (like a child gameobject), we patch the reference to the corresponding copy). 这里我直接贴了英文原文，感觉翻译不出人家的意思。要注意的是： Variant: 在unity编辑器中偶尔会看见这个名字，在我prefab中嵌套另一个prefab的时候印象最深。按照上面的说法，这个是用来通知被引用的UnityEngine.Object’s，然后同样对这些对象执行上述的序列化代码。 如果引用的内容是外部数据(“external”)将会保留原有的引用。 如果引用的内容是内部数据(“internal”)将会将引用替换为原有数据的副本。 在这里，在这篇文章的评论部分有提及，作者举了一个例子来说明这个过程： The scenario you mean is when you call Instantiate() on something. Let’s take this example. There are three objects. O1: GameObject components=O2, O3O2: RigidBodyO3: BoxCollider when you invoke Instatiate(gameObject1), we duplicate all three objects. O4: GameObject components=O2, O3O5: RigidBodyO6: BoxCollider Notice how the cloned object O4, actually points to O2 and O3 in its component list. this is obviously not what you intended. In the second phase of Instantiate, we fix this up, by running the serializer in a special mode on O1,O2&amp;O3. we ask it “please report your object references”, and then we check if any of the objects referenced were included in the list of objects that were cloned. For each reference that referenced an object that was cloned (both entries in the componentlist in our case), we update that reference to the cloned version instead of the original. after the fix it looks like this: O4: GameObject components=O5, O6O5: RigidBodyO6: BoxCollider Saving. 如果设置了”force text serialization”，并且用文本编辑器打开.unity的scene文件，we run the serializer with a ymal backend. Loading. 向后兼容加载（backwards compatible loading）也是基于系列化机制(serialization)的系统。In-Editor的yaml loading利用了序列化机制，运行时加载scenes和assets也利用了这个。Assetbundles也利用了序列化系统(serialization system)。 Hot reloading of editor code. 当你改变了editor脚本数据，我们会序列化所有的editor窗口（它们都继承自UnityEngine.Object!），然后我们销毁所有的窗口，unload掉所有的旧的C#代码，加载新的C#代码，重新创建窗口，并在最后反序列化数据流中的数据到新的窗口。 Resource.GarabageCollectSharedAssets(). Unity中使用的GC(native garabage collector)，不同于C#所使用的GC。我们使用这个系统，当加载一个scene，之前的scene未引用的内容就会被unload掉。这种GC会在某种模式下运行序列器(serializer)，在这个模式下我们用它来让对象通知所有的引用到外部的UnityEngine.Objects。这就是为什么我们在scene1中使用的textures会在scene2中被unload掉。 This is our native garbage collector and is different to the C# garbage collector. It is the thing that we run after you load a scene to figure out which things from the previous scene are no longer referenced, so we can unload them. The native garbage collector runs the serializer in a mode where we use it to have objects report all references to external UnityEngine.Objects. This is what makes textures that were used by scene1, get unloaded when you load scene2. The serialization system is written in C++, we use it for all our internal object types (Textures, AnimationClip, Camera, etc). Serialization happens at the UnityEngine.Object level, each UnityEngine.Object is always serialized as a whole. They can contain references to other UnityEngine.Objects and those references get serialized properly. 由于一些执行效率的需要，serializer的行为不完全是如你所愿，比如说MonoBehaviour component的序列化是由你写的脚本所支持的，所以了解serializer的运行细节能够让你更好的使用它。 为了能让我们写的脚本中的序列化区域(a fieldof my script)能够被序列化需要什么条件？ Be public,or have [SerializeField] attribute Not be static Not be const Not be readonly The fieldtype needs to be a type that we can serialize. 什么样的类型(fieldtype)能被序列化呢？ Custom non abstrace classes with [Serializable] attribute. Custom structs with [Serializable] attribute. (new inUnity4.5) References to objects that derive from UnityEngine.Object Primitive data dypes(int,float,double,bool,string,etc) Array of a fieldtype we can serialize List of a fieldtype we can serialize 那么什么情况是，serializer的动作会是与我们的期望有所不同呢？12345678910[Serializable]class Animal&#123; public string name;&#125;class MyScript : MonoBehaviour&#123; public Animal[] animals;&#125; 当我们试着在数组animals加入三个相同的Animal object对象引用的时候，即三个引用都指向相同的对象。在已序列化的数据流中你会发现三个对象，当你进行反序列化会发现那里有三个不同的对象。 当你需要需要序列化一个比较复杂的引用的对象列表，这个时候就不能依靠Unity的serializer。你需要做些操作为了能让这些数据正常序列化。 但是需要注意的是，这个情况只适应于自定义类(custonm classes)，因为他们是被内联的序列化（serialized “inline”）,因为他们的数据成为了既存的MonoBehaviour中的完整的序列化数据的一部分。当你的变量区域有一个UnityEngine.Object的派生类引用，那么数据并不是内联序列化，那么其实际的引用数据会被成功的序列化。 Note that this is only true for custom classes, as they are serialized “inline” because their data becomes part of the complete serializationdata for the MonoBehaviour they are used in. When you have fields that have a reference to something that is a UnityEngine.Object derived class, like a “public Camera myCamera”, the data from that camera are not serialized inline, and an actual reference to the camera UnityEngine.Object is serialized. (我担心自己的理解有偏差还是把英文原文贴了出来。) No support for null for custom classes The serializer does not support null. If it serializes an object and a field is null, we just instantiate a new object of that type and serialize that. Obviously this could lead to infinite cycles, so we have a relatively magical depth limit of 7 levels. At that point we just stop serializing fields that have types of custom classes/structs and lists and arrays. [1] Serializer不支持null类型的序列化，如果执行这样的操作了就会导致死循环，unity在这种死循环中加入了最大的生成层次。在Unity4.5之后的版本加入了警告的信息。 No support for polymorphism 不支持多态。1public Animal[] animals; 在里面加入一个dog,cat,giraffe三个派生实例，在序列化之后我们得到的是三个Animal类型的实例。 这会发生在自定义类(“custom classes”)的内联序列化(get serialized inline)过程中。当对象实例是UnityEngine.Object’s派生的实例多态的特性还是有效的。 You’d make a ScriptableObject derived class or another MonoBehaviour derived class, and reference that. The downside of doing this, is that you need to store that monobehaviour or scriptable object somewhere and cannot serialize it inline nicely. 你可以利用ScriptableObject派生类或者另一个MonoBehavior派生类，并引用这个生成的实例。这种方式的缺点是，你必须在某个地方存储monobehaviour或者scriptable对象，而不能很好的内联序列化(serailized inline)。 产生这样的限制的原因是，序列化系统的一个核心功能之一的实现，了解一个对象的数据结构依靠的是类的类型，而不是运行时被存储在这个类区域的数据类型。 The reason for these limitations is that one of the core foundations of the serialization system is that the layout of the datastream for an object is known ahead of time, and depends on the types of the fields of the class, instead of what happens to be stored inside the fields. 那么如何序列化一些Uinty不支持的数据类型？ 大多情况下可以使用serialization callbacks。它们会在serializer开始读取你的自定义数据区域之前通知你，并在serializer结束之后写入数据。（应该就是上面说的序列化之前存储monobehaviour或者scriptable对象，并在序列化完成之后将数据写入。） In many cases the best approach is to use serialization callbacks. They allow you to be notified before the serializer reads data from your fields and after it is done writing to them. You can use this to have a different representation of your hard-to-serialize data at runtime than when you actually serialize. You’d use these to transform your data into something Unity understands right before Unity wants to serialize it, you also use it to transform the serialized form back into the form you’d like to have your data in at runtime, right after Unity has written the data to your fields. 让我们创建一个树状的数据的结构(tree datastructure)，如果你直接让Unity去序列化这样的数据，”no support for null”的限制会让你的数据流变得非常大，导致一些程序效率的问题。 Let’s say you want to have a tree datastructure. If you let Unity directly serialize the data structure, the “no support for null” limitation would cause your datastream to become very big, leading to performance degradations in many systems: 12345678910111213141516171819202122232425262728293031323334353637383940414243using UnityEngine;using System.Collections.Generic;using System; public class VerySlowBehaviourDoNotDoThis : MonoBehaviour&#123; [Serializable] public class Node &#123; public string interestingValue = "value"; //The field below is what makes the serialization data become huge because //it introduces a 'class cycle'. public List&amp;lt;Node&amp;gt; children = new List&amp;lt;Node&amp;gt;(); &#125; //this gets serialized public Node root = new Node(); void OnGUI() &#123; Display (root); &#125; void Display(Node node) &#123; GUILayout.Label ("Value: "); node.interestingValue = GUILayout.TextField(node.interestingValue, GUILayout.Width(200)); GUILayout.BeginHorizontal (); GUILayout.Space (20); GUILayout.BeginVertical (); foreach (var child in node.children) Display (child); if (GUILayout.Button ("Add child")) node.children.Add (new Node ()); GUILayout.EndVertical (); GUILayout.EndHorizontal (); &#125;&#125; Instead, you tell Unity not to serialize the tree directly, and you make a seperate field to store the tree in a serialized format, suited for Unity’s serializer: 为serializer添加自定义数据的序列化操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697using UnityEngine;using System.Collections.Generic;using System;public class BehaviourWithTree : MonoBehaviour, ISerializationCallbackReceiver&#123; //node class that is used at runtime public class Node &#123; public string interestingValue = "value"; public List&amp;lt;Node&amp;gt; children = new List&amp;lt;Node&amp;gt;(); &#125; //node class that we will use for serialization [Serializable] public struct SerializableNode &#123; public string interestingValue; public int childCount; public int indexOfFirstChild; &#125; //the root of what we use at runtime. not serialized. Node root = new Node(); //the field we give unity to serialize. public List&amp;lt;SerializableNode&amp;gt; serializedNodes; public void OnBeforeSerialize() &#123; //unity is about to read the serializedNodes field's contents. lets make sure //we write out the correct data into that field "just in time". serializedNodes.Clear(); AddNodeToSerializedNodes(root); &#125; void AddNodeToSerializedNodes(Node n) &#123; var serializedNode = new SerializableNode () &#123; interestingValue = n.interestingValue, childCount = n.children.Count, indexOfFirstChild = serializedNodes.Count+1 &#125;; serializedNodes.Add (serializedNode); foreach (var child in n.children) AddNodeToSerializedNodes (child); &#125; public void OnAfterDeserialize() &#123; //Unity has just written new data into the serializedNodes field. //let's populate our actual runtime data with those new values. if (serializedNodes.Count &amp;gt; 0) root = ReadNodeFromSerializedNodes (0); else root = new Node (); &#125; Node ReadNodeFromSerializedNodes(int index) &#123; var serializedNode = serializedNodes [index]; var children = new List&amp;lt;Node&amp;gt; (); for(int i=0; i!= serializedNode.childCount; i++) children.Add(ReadNodeFromSerializedNodes(serializedNode.indexOfFirstChild + i)); return new Node() &#123; interestingValue = serializedNode.interestingValue, children = children &#125;; &#125; void OnGUI() &#123; Display (root); &#125; void Display(Node node) &#123; GUILayout.Label ("Value: "); node.interestingValue = GUILayout.TextField(node.interestingValue, GUILayout.Width(200)); GUILayout.BeginHorizontal (); GUILayout.Space (20); GUILayout.BeginVertical (); foreach (var child in node.children) Display (child); if (GUILayout.Button ("Add child")) node.children.Add (new Node ()); GUILayout.EndVertical (); GUILayout.EndHorizontal (); &#125;&#125; Beware that the serializer, including these callbacks coming from the serializer, usually do not run on the main thread, so you are very limited in what you can do in terms of invoking Unity API. (Serialization happening as part of loading a scene happens on a loading thread. Serialization happening as part of you invoking Instantiate() from script happens on the main thread). You can however do the necessary data transformations do get your data from a non-unity-serializer-friendly format to a unity-serializer-friendly-format. 需要注意的是，这些回调通常并不会运行在主线程中，所以当调用UnityAPI的时候就需要注意加一些限制。（当是scene加载过程中的序列化是loading thread中发生的，你调用Instantiate()函数过程中的序列化是在主线程中发生的。） 通过上面的手段就可以实现一些Unity不支持的数据类型的序列化。 这个时候我就会问List&lt;Node&gt;是个什么，查了一下，就是&lt;,&gt;的表示。HTML特殊文字コード表。 额… 看了一下时间，是2014年的文章，现在已经2020年了…不过自定义序列化数据之前的东西还是没变的感觉，仍是非常有用，对我来说。 【Unity】【エディタ拡張】SerializedObjectの勘所をまとめてみる]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>serialization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity-第三方库介绍和使用]]></title>
    <url>%2Funity-plugins%2F</url>
    <content type="text"><![CDATA[这篇主要是介绍一些Unity的插件使用，Unity的插件库感觉很方便，而且确实很丰富。 Dynamic Bone使用的话搜一下应该就能找到，我只是稍微使用这个库来模拟了下垂的线。移动的时候会像飘着那样移动。 Alembic Stream Player component这是一个很神奇的组件，我还不太确定这个到底是组件还是插件。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>plugins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity-DoTween-曲线的魅力]]></title>
    <url>%2FUnity-DoTween-%E6%9B%B2%E7%BA%BF%E7%9A%84%E9%AD%85%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[因为在使用DoTween的时候，有许多我不知道的用法，关于曲线的使用和一些很重要的名词。这篇文章主要用来记录这些曲线的操作和使用。 首先是曲线的基础： 一から学ぶベジェ曲線 虽然是随便搜也能搜到，暂且记下来吧。 ease Easing functions specify the rate of change of a parameter over time 相当实用的网站，大佬教我搜ease的时候搜到的。 DoTween其实应该把这个放到Unity-插件的内容里的，感觉和曲线息息相关的插件，就放到了这里。 DOCUMENTATION DoPath/DoLocalPath这个是我所需要的，我使用的地方。 关于这个插件有很多的使用，有免费版和Pro版。我看到有人整理的我就先上个链接-HowTo_DOTween.md 我自己的话充其量用了上面的路径功能，换了换set ease的条件。还有一些RX的使用，Onstart(),OnComplete()。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>DoTween</tag>
        <tag>Curve</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4-枚举的使用]]></title>
    <url>%2Fue4-enum%2F</url>
    <content type="text"><![CDATA[介绍关于枚举的使用。 UE4 C++とUnreal C++の列挙型の扱い]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4-Editor扩展]]></title>
    <url>%2Fue4-editor-extension%2F</url>
    <content type="text"><![CDATA[今天这篇文章要写UE4的编辑器扩展内容的，我还没学会，有时间的话一定要整理一下。 在用了Unity的各种技巧之后，再回到UE4的时候不禁觉得要是UE4也有这些方便的扩展功能就好了。Unity中的自定义Inspector扩展就很方便，还有DebugMenu等等。 Customizing detail panels UE4 Blutilityによるお手軽なエディター拡張]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity-Editor扩展]]></title>
    <url>%2Funity-editor-extension%2F</url>
    <content type="text"><![CDATA[编辑器扩展是很重要的一个部分，多使用可以提高开发效率。当然也是需要学习的。(未整理) 由于是Editor的扩展功能在实际的项目中要注意不要把Editor的功能打包在项目的功能里面。 Unity Editor扩展Unity编辑器扩展好多内容啊，只能记下我遇见的了。有时间要找找一些感觉用的上的。 参考公司大佬的写法，我做了一个当我准备关掉Editor的时候会弹出来一个MessageBox的功能。没啥实际的功能，就是为了提醒。 实现需求EditorApplication.wantsToQuit就是实现这个功能的主角。 实现这个功能的代码:123456789101112131415161718192021222324[InitializeOnLoad]public class EditorReminder&#123; [InitializeOnLoadMethod] public static void ValidateReminder() &#123; EditorApplication.wantsToQuit += EditorWantToQuitReminder; &#125; static bool EditorWantToQuitReminder() &#123; bool.TryParse(EditorUserSettings.GetConfigValue(&quot;EnableReminder&quot;), out var enable); if(!enable) &#123; return true; &#125; return EditorUtility.DisplayDialog(&quot;Reminder&quot;, &quot;Have you released all your locks on GitHub?&quot;, &quot;Yes, quit!&quot;, &quot;No, wait a second.&quot;); &#125; &#125; 几行就能实现这个功能，真的好简单啊（站着说话不腰疼）。 InitializeOnLoad Running Editor Script Code on Launch Sometimes, it is useful to be able to run some editor script code in a project as soon as Unity launches without requiring action from the user. You can do this by applying the InitializeOnLoad attribute to a class which has a static constructor. A static constructor is a function with the same name as the class, declared static and without a return type or parameters (see here for more information):- 官方文档上说对于有一个静态构造函数的类前可以加上InitializeOnLoad这个attribute，但是上面的那个例子我并没有显式的去声明一个静态的构造函数。而且执行下来也没什么问题，难道说有一个静态构造函数会好一些吗。 A static constructor is always guaranteed to be called before any static function or instance of the class is used, but the InitializeOnLoad attribute ensures that it is called as the editor launches. 就是这样使用的。 InitializeOnLoadMethodInitializeOnLoadMethodAttribute Allow an editor class method to be initialized when Unity loads without action from the user. 项目被加载到Unity中的时候带有这个属性的静态函数就会被自动调用。 EditorApplicationEditorApplication wantsToQuit就是我用的那个啦，连用法都是抄的官方文档的。 Unity raises this event when the editor application wants to quit. 123456789101112131415161718using UnityEngine;using UnityEditor;// Ensure class initializer is called whenever scripts recompile[InitializeOnLoad]public class EditorWantsToQuitExample&#123; static bool WantsToQuit() &#123; Debug.Log(&quot;Editor prevented from quitting.&quot;); return false; &#125; static EditorWantsToQuitExample() &#123; EditorApplication.wantsToQuit += WantsToQuit; &#125;&#125; 想要在Editor退出前做点什么？那么用这个吧。 quitting想要在Editor退出的时候做点什么那么用这个。 EditorUtilityEditorUtility 一些通用的函数库，看名字就知道应该会很多 EditorUtility.DisplayDialogEditorUtility.DisplayDialog 弹出一个窗口？ EditorUtility.DisplayDialogComplex弹出一个更复杂的窗口？（貌似是支持三个按钮） MenuItemMenuItem 这个属性可以让在Editor上的菜单栏添加项目，可以用来做什么呢？那可太多了，比如说需要方便切换的项目设定，亦或者想要方便调用一个函数（啊这个好像可以直接在想要调用的GameObject上右键调用，使用另外一个Attribute）。总而言之，就是方便。 需要注意的是只有静态函数才能使用这个MenuItem属性。 这个光看官方文档不靠谱，讲的太少了，看我总结的？我总结的也没什么好看的，看这个 メニューを追加するための属性「MenuItem」は意外と多機能【Unity】【エディタ拡張】【属性】 还能设定快捷键，厉害了。 123456789[MenuItem(menuRoot + &quot;EnableReminder&quot;)]private static void EnableReminder()&#123; var path = menuRoot + &quot;EnableReminder&quot;; var enable = Menu.GetChecked(path); Menu.SetChecked(path, !enable); EditorUserSettings.SetConfigValue(&quot;EnableReminder&quot;, (!enable).ToString());&#125; 用的话就是这么用的。我靠EditorUserSettings又是什么？ 2020/01/16更新 MenuItem参数说明在菜单栏里添加自定义项的话当然需要对其参数有所了解，直接进入源码查看即可，这里我顺便贴一下注释:1234567891011121314151617//// Summary:// Creates a menu item and invokes the static function following it, when the menu// item is selected.//// Parameters:// itemName:// The itemName is the menu item represented like a pathname. For example the menu// item could be &quot;GameObject/Do Something&quot;.//// isValidateFunction:// If isValidateFunction is true, this is a validation function and will be called// before invoking the menu function with the same itemName.//// priority:// The order by which the menu items are displayed.public MenuItem(string itemName, bool isValidateFunction, int priority); 这里关于isValidateFunxtion的说明就是增加一个验证函数，比如说我只想在游戏运行的时候执行某个操作，在Editor未运行的时候调用这个函数没有意义那就加上一个验证函数。 关于priority的含义就是可以自定义菜单选项的顺序，这里要注意的是想要在弹出来的菜单中看到分割线的话，优先级的数值是10起跳的。摘一段官网的文字: Note: The understanding of ten or greater is considered to create a divider in the menu. However, as per the example above, the difference between script function need to have the priority separated by 11 or more. This is why the example before has a value of 100 and one of 111. Changing 111 to 110 does not have a divider. ScriptTemplates简单创建一个想要的脚本模板。Unity提供了两种方式。 一种是直接在Unity原有的ScriptTemplates的地方添加类似的新的模板。 另一种是在工程里添加新的模板。 当然是推荐第二种啦。但是第一种也应该知道，毕竟要看人家是怎么做的啊。贴一下Unity引擎内置的脚本模板的位置: Windows:1C:\Program Files\Unity\Editor\Data\Resources\ScriptTemplates\ Mac:1/Applications/Unity/Unity.app/Contents/Resources/ScriptTemplates/ 主要是第二种使用方法，需要做的是以下的事情： 创建Assets/ScriptTemplates/文件路径，模板文件放置在里面 模板文件命名规则：{priority}-{メニュー名}-{ファイル名}.{拡張子}.txt 重启Editor 不需要MenuItem，只要起对了名字，放对了位置，那么重启一下就能用。厉害了。 知道了之后也不是很难嘛，然后我看到了一篇关于ScriptableObject式的脚本模板文章： ScriptTemplatesでScriptableObjectのための環境構築 虽然我暂时并没有找到任何非要使用ScriptableObject的理由，是我还不了解这个概念，什么情况下该使用这个东西不知道。 EditorUserSettings プロジェクト内でデータを保存【Unity】【エディタ拡張】 挺神奇的一个功能，用来保存本地设定相当理想的功能，但是貌似只有Get和Set两个方法写入的内容没法删除，别瞎写好么，我第一印象。 ##先记下，后整理 【Unity】エディタ拡張で使用できるコールバックを40個まとめて紹介 Editor扩展实例Editor扩展的模板写法12345678910111213141516171819202122232425262728293031323334using UnityEditor;using UnityEngine;namespace EditorExtension&#123; [CustomEditor(typeof(ExtensionClass), true)] public class ExtensionClassInspector ： Editor &#123; protected ExtensionClass extensionClass = null; protected SerializedProperty attributeA; protected SerializedProoerty attributeB; ...... private void OnEnable() &#123; extensionClass = target as ExtensionClass; attributeA = serializedObject.FindObject(&quot;ExtensionClass_AttributeAName&quot;); attributeB = serializedObject.FindObject(&quot;ExtensionClass_AttributeBName&quot;); ...... &#125; public override void OnInspectorGUI() &#123; serializedObject.Update(); EditorGUILayout.PropertyField(attributeA); EditorGUILayout.PropertyField(attributeB); ...... serializedObject.ApplyModifiedProperties(); &#125; &#125;&#125; 最普通的格式就是上面那样，这是对Inspector格式的扩展，内容都是最基础的。需要注意的是在对OnInspectorGUI函数进行重写的时候，最开始要Update()，最后要ApplyModifiedProperties()。 缩进123456// 在上面的例子中的话EditorGUILayout.PropertyField(attributeA);EditorGUI.indentLevel++;EditorGUILayout.PropertyField(attributeB);EditorGUI.indentLevel--; Inspector变量名设定在Inspector不指定变量名字的话就会使用默认的变量名字，但是也可以自己设置。 1EditorGUILayout.PropertyField(attributeA, new GUIContent(&quot;NameA&quot;)); 这里的话就不自觉的产生了EditorGUILayout是什么的想法，还有其它的作用吧 EditorGUILayout GUIContent 类型判断在OnInspectorGUI函数中也想要使用条件判断，这个时候不知道变量的类型不好办，上面的代码中表示的，变量类型都是SerializedProperty，条件语句对这个变量类型并不知晓。 123if(attributeA.boolValue) return;switch(attributeB.intValue) &#123;&#125; 等等类型，基本数据类型应该都会有覆盖到，不太清楚。 Inspector在运行时添加不可交互内容1234567891011121314151617181920212223if(EditorAppliation.isPlaying)&#123; EditorGUILayout.BeginVertical(GUI.skin.box); EditorGUILayout.LabelField(&quot;Running status&quot;); // EditorGUI.BeginDisabledGroup(true); EditorGUILayout.PropertyField(flag1); EditorGUILayout.PropertyField(flag2); EditorGUI.EndDisabledGroup(); EditorGUILayout.BeginHorizontal(); GUILayout.FlexibleSpace(); if (GUILayout.Button(&quot;buttonA&quot;, GUILayout.Width(100))) &#123; (target as ExtensionClass)?.SampleFunctionA(); &#125; EditorGUILayout.EndHorizontal(); EditorGUILayout.EndVertical();&#125; 我只是拿来用而已…..出现了好多我不会用的控件。还需要学习啊。 Inspector中显示List元素 【Unity】【エディタ拡張】配列やリストのInspector表示を改良する 因为比我想象的要麻烦，我就直接用了人家的代码……原本颜色什么的都无所谓的。 真的超级麻烦，如果希望上面的List中的元素是List又该怎么办呢？ 答案是没人这么写啊…只好自己写个类，类里面的属性加上List好了。 error解决 12Unsupport type ..ApplyModifiedProperties() ‘Unsupported type’ error in custom editor script 删掉重新再add component之后就修复了。 Inspector中显示多元List 多次元のListをInspectorに表示する【Unity】 方法很简单，但是这里遇见了一个问题，因为使用了Inspector扩展，Inspector上不显示。12// EditorGUILayout.PropertyField(pathAnchors);EditorGUILayout.PropertyField(pathAnchors, true); 加上一个true的参数就好了，原因我也不知道，之后在调查吧。 12345678910111213[Serializable]public class AreaPathAnchor&#123; public List&lt;GameObject&gt; List = new List&lt;GameObject&gt;(); public AreaPathAnchor(List&lt;GameObject&gt; list) &#123; List = list; &#125;&#125;[SerializeField]private List&lt;AreaPathAnchor&gt; pathAnchors = new List&lt;AreaPathAnchor&gt;(); Inspector扩展中对应的代码:1234public override void OnInspectorGUI()&#123; EditorGUILayout.PropertyField(pathAnchors, true);&#125; Inspector中加入HDRColor选择(未整理)其实这个属性也不需要刻意的去扩展，只要在属性前加上限定Unity就会自动处理了。1[ColorUsage(false,true)] private Color color1; 像这样子。 关于这个属性的更详细的说明之后再整理。 ColorUsageAttribute Constructor マテリアルのEmissionを操作 SerializedObject 【Unity】【エディタ拡張】SerializedObjectの勘所をまとめてみる]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity-トレマーチング入門]]></title>
    <url>%2Funityraymaching%2F</url>
    <content type="text"><![CDATA[一时兴起，仔细阅读了一下公司前辈的投稿，看到了这个陌生的名词，刚开始一头雾水，不知道是干什么的，但是仔细了解一下后知道真是マジヤバくね。(未整理) 主要是Unity最新的更新可以使用工具来使用トレマーチング了。 のたぐすさんのTweet 激发了俺的求知欲。网上一搜，教程一大片，是我孤陋寡闻的错。 [GLSL] レイマーチング入門 vol.1 Unity×レイマーチングによる映像制作の実践手法 シェーダだけで世界を創る！three.jsによるレイマーチング 这篇share中的链接： 「How Raymarcher Works」 确定不找时间整理么..]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>rendering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity中的Prefab系统]]></title>
    <url>%2Funity-prefab-system%2F</url>
    <content type="text"><![CDATA[关于Unity中的Prefab的使用。 kurihara-nの日記 Prefab Variants -Unity2018.3からのPrefab活用-]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Prefab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity-关于NativeArray]]></title>
    <url>%2Funity-native-array%2F</url>
    <content type="text"><![CDATA[那一天，我听到了这个陌生的名词，不知道是什么，也不知道用来干什么的。它的名字叫”NativeArray”。 NativeArray 【Unity】アセット読書会に行ってきたよ。NativeArrayってなんだろう？]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity-Performance提升]]></title>
    <url>%2Funity-performance%2F</url>
    <content type="text"><![CDATA[我知道这只是早晚的事儿。 【CEDEC2018】一歩先のUnityでのパフォーマンス/メモリ計測、デバッグ術 UI部分大佬总是跟我说不要用Canvas，当然是指游戏运行中的某种情况，貌似公司的大佬对于UI的效率很是关心。因为我也不懂太多关于UI的渲染问题所以只能先记下。 Unity UI の最適化に関するヒント Unite Europe 2017 - Squeezing Unity: Tips for raising performance 上面的视频我看了两遍都没看完，中途都困得不行了…但是确实很重要，一定要整理。 Unity中UI需要了解摘取上面的视频中的内容 The Absolute Basics Canvases generate meshes &amp; draw them Drawing happens once per frame Generation happens when “something changes” “Something changes” = “1 or more UI elements change” Change one UI element, dirty the whole canvas Yes, one. What’s a rebuild? Theoretically… Three steps: Recalculate layouts of auto-layouted elements Regenerate meshes for all enabled elements Yes, meshed are still created when alpha=0! Regenerate materials to help batch meshed What’s a rebuild? In Reality… Usually, all system are dirtied instead of individually Notable exceptions: Color property fill* properties on Image After all that… Canvas takes meshes, divides them into batches Sorts the meshes by depth (hierarchy order) Yes, this involves a sort() operation! AllUI os transparent. No matter what. Overdraw is a problem! The Vicious Cycle Sort means performance drops faster-than-linear as number of drawable elements rises. Higher number of elements means a higher chance any given element will change. Slice up your canvases! Add more canvases. Each canvas owns its own set of UI elements Elements on different canvases will not batch. Main tool for constraining size of UI batches. Nesting Canvases Canvases can be created within other canvases Child canvases inherit rendering settings. Maintain own geometry. Perform own batching. 后半段我开始听不太懂了……]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Performance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity中的通信]]></title>
    <url>%2Funity-data-transission%2F</url>
    <content type="text"><![CDATA[这篇文章主要是因为一篇讲Unity的实时数据通信内容博文很重要。 MagicOnion因为数据传输也很重要，所以这篇文章非常重要。 MagicOnion – C#による .NET Core/Unity 用のリアルタイム通信フレームワーク gPRC gRPCって何？]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity-Shader学习]]></title>
    <url>%2Funity-shader-learning%2F</url>
    <content type="text"><![CDATA[关于Unity的Shader，能说的内容很多，因为我是真的不懂。之前用了好长时间看了关于Unity的书，能看懂一些内容了，但是还远不到立马就能写的程度。这次把自己所见所得写下来。 PostProcessing不知道该起什么名字为好。 Post Processing Stack v2这个是一个Unity中方便添加PostProcessing特效的插件。 对这个插件有一个大体上的了解可以参照这篇文章： Unity ルックデヴ講座 Post Processing Stack v2編 但是当你想要添加自己的自定义特效的话，就不够用了。 Post Processing Stack v2にカスタムエフェクトを追加する方法 使用这个插件添加自定义Post Processing Shader的话，就要写点代码了，不光是Shader的。 Renderer PipelineLWRP 【 Unity道場 1月 ~LWRPとシェーダー~】軽量レンダーパイプライン、Light Weight Renderer Pipeline…とは Scriptable Render Pipeline Unity Scriptable Render Pipeline 使用PostProcessingStack的实例使用PostProcess制作受伤效果感觉上就像是受到伤害的时候摄像机中心到边缘向红色渐变的效果。 首先是我使用的Unity版本是Unity2019.2.12f1。 参考的就除了上面贴出来的链接之外，还有最重要的官方文档了PostProcessing-Writing Custom Effects Custom effects need a minimum of two files: a C# and a HLSL source files (note that HLSL gets cross-compiled to GLSL, Metal and others API by Unity so it doesn’t mean it’s restricted to DirectX). C123456789101112131415161718192021using System;using UnityEngine;using UnityEngine.Rendering.PostProcessing; [Serializable][PostProcess(typeof(GrayscaleRenderer), PostProcessEvent.AfterStack, &quot;Custom/Grayscale&quot;)]public sealed class Grayscale : PostProcessEffectSettings&#123; [Range(0f, 1f), Tooltip(&quot;Grayscale effect intensity.&quot;)] public FloatParameter blend = new FloatParameter &#123; value = 0.5f &#125;;&#125; public sealed class GrayscaleRenderer : PostProcessEffectRenderer&lt;Grayscale&gt;&#123; public override void Render(PostProcessRenderContext context) &#123; var sheet = context.propertySheets.Get(Shader.Find(&quot;Hidden/Custom/Grayscale&quot;)); sheet.properties.SetFloat(&quot;_Blend&quot;, settings.blend); context.command.BlitFullscreenTriangle(context.source, context.destination, sheet, 0); &#125;&#125; Important: this code has to be stored in a file named Grayscale.cs. Because of how serialization works in Unity, you have to make sure that the file is named after your settings class name or it won’t be serialized properly. 这里要注意的是脚本名字要一致。 Setting The settings class holds the data for our effect. These are all the user-facing fields you’ll see in the volume inspector. 之前用的时候就会觉得为什么还要做个这个类，原来是为了保存为PostProcess准备的预设数据，所以有Serializable属性。 1234567[Serializable][PostProcess(typeof(GrayscaleRenderer), PostProcessEvent.AfterStack, &quot;Custom/Grayscale&quot;)]public sealed class Grayscale : PostProcessEffectSettings&#123; [Range(0f, 1f), Tooltip(&quot;Grayscale effect intensity.&quot;)] public FloatParameter blend = new FloatParameter &#123; value = 0.5f &#125;;&#125; ……我觉得官网说的比我清楚多了，干脆贴上英文得了。 看英文，看英文。Writing Custom Effects Renderer Our renderer extends PostProcessEffectRenderer, with T being the settings type to attach to this renderer. 123456789public sealed class GrayscaleRenderer : PostProcessEffectRenderer&lt;Grayscale&gt;&#123; public override void Render(PostProcessRenderContext context) &#123; var sheet = context.propertySheets.Get(Shader.Find(&quot;Hidden/Custom/Grayscale&quot;)); sheet.properties.SetFloat(&quot;_Blend&quot;, settings.blend); context.command.BlitFullscreenTriangle(context.source, context.destination, sheet, 0); &#125;&#125; 看文档看文档。 Shader进入Shader的书写。 12345678910111213141516171819202122232425262728293031323334Shader &quot;Hidden/Custom/Grayscale&quot;&#123; HLSLINCLUDE #include &quot;Packages/com.unity.postprocessing/PostProcessing/Shaders/StdLib.hlsl&quot; TEXTURE2D_SAMPLER2D(_MainTex, sampler_MainTex); float _Blend; float4 Frag(VaryingsDefault i) : SV_Target &#123; float4 color = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.texcoord); float luminance = dot(color.rgb, float3(0.2126729, 0.7151522, 0.0721750)); color.rgb = lerp(color.rgb, luminance.xxx, _Blend.xxx); return color; &#125; ENDHLSL SubShader &#123; Cull Off ZWrite Off ZTest Always Pass &#123; HLSLPROGRAM #pragma vertex VertDefault #pragma fragment Frag ENDHLSL &#125; &#125;&#125; 看文档，看文档。关于shader里面的内容还有好多我不懂的。 Effect orderingCustom editorAdditional notes特效制作所以上面的使用说明看完之后，就是实现部分了。不知不觉就把上面的部分写到这一章节离了= =。 因为上面的实现都差不多，只记下Shader部分的： 123456789101112131415161718192021222324252627282930313233343536Shader &quot;Hidden/Custom/Damage&quot;&#123; HLSLINCLUDE#include &quot;Packages/com.unity.postprocessing/PostProcessing/Shaders/StdLib.hlsl&quot; TEXTURE2D_SAMPLER2D(_MainTex, sampler_MainTex); float _Range; float4 _Color; float4 Frag(VaryingsDefault i) : SV_Target &#123; float2 uv = i.texcoord; float4 color = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv); float radiusFactor = (1 - _Range) * (1 - _Range) / 4; float radius = saturate(((uv.x - 0.5) * (uv.x - 0.5) + (uv.y - 0.5) * (uv.y - 0.5)) / radiusFactor); return saturate(color * (1 - radius) + _Color * radius); &#125; ENDHLSL SubShader &#123; Cull Off ZWrite Off ZTest Always Pass &#123; HLSLPROGRAM #pragma vertex VertDefault #pragma fragment Frag ENDHLSL &#125; &#125;&#125; 这些都是要做的准备工作，最后要把这个PostProcess应用到Camer上。 Camera上添加PostProcessLayer组件，指定PostProcessEffect的layer New一个GameObject，添加PostProcessVolume组件，可以是子物体 GameObject的Layer需要指定上面提到的layer 这些是有可能会忘的，其他的就很简单了。别忘了New一个新的Profile。参数的话可以参照Class PostProcessVolume 使用PostPerocess制作向纯色渐变的效果说起来上面的效果也只是这个效果的拓展，这个效果是我从巨佬那里偷学来的。 关于Shader的一些文章 Cg Programming/Unity/Translucent Bodies Toon Shader 【Unity】良い感じに見える（屋内向け）ライティングの設定手順 Unity Post Processing Stackで作る光芒エフェクト 【Unity】【シェーダ】ブルームを独自実装する 原先在知乎上看到的文章，这回有大图看： Unite 2018 | 《崩坏3》：在Unity中实现高品质的卡通渲染（上） Dark and Stormy]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习笔记]]></title>
    <url>%2Fgit-learning%2F</url>
    <content type="text"><![CDATA[Git的使用尤为重要，只要是做项目开发没有版本管理的话，那就没个玩。但是Git的使用虽然是很简单但是精通的话还是要时间。 这里就是要记下我在使用Git的过程中遇到的问题和解决方案。像记事本一样。 Git git-recipes 这是Git的中文Wiki，我还没看过，真是罪过，一定要看！！ Flight rules for Git 有中文翻译。顺便一提这个是日语翻译【永久保存版】Gitのあらゆるトラブルが解決する神ノウハウ集を翻訳した Git使用中遇到的关于换行符 気をつけて！Git for Windowsにおける改行コード 关于差分（diff）在提交(add)代码之前，使用差分工具看看自己修改过的内容是一个极好的习惯，确保自己代码修改的地方，防止提交一些自己失误添加的内容。 最近就发生了我提交了迷之代码的尴尬事情，查看历史的提交记录，追溯到我，场面一度非常尴尬。 忘れやすい人のための git diff チートシート SourceTree最近一直在用这个工具，很方便了，代替Git吧，但是遇到了问题。 在SourceTree中使用Git LFS的时候，文件超过一定大小当你准备提交的时候就会提醒你把这个文件交给Git LFS来处理，于是我照办了。由于这个文件的路径有些奇葩，有space的存在，于是我明明在.gitattribute文件中添加了路径，SourceTree还是会提醒我这个文件要用Git LFS来处理。 文件路径奇葩带空格又不是我的错，我只是导入一个插件而已。至于解决方案，那就是使用命令行工具来提交啊。关键时候还得是Bash。 参考了下面的文章： [[:space:]] seam to prevent Git lfs to work with SourceTree]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的TraceFunctions]]></title>
    <url>%2Fue4-trace-fnctions%2F</url>
    <content type="text"><![CDATA[UE4中的Trace比我想象中的要重要，除了模拟交互之外，获取两点之间的距离，也可以起到非常大的作用。(未整理） 如何知道物体离地面的高度？这是我迫切想要知道的事情，搜了一下果然发现有人问了相同的问题。 How to obtain landscape height? 于是我就用Trace试了一下，完美。 Trace FunctionsTrace Functions 基本上就是人家这篇Wiki写的内容，但是`LineTraceSingle这个函数编译没有通过，我用了UWorld::LineTraceSingleByChannel来替代了。 LineTraceSingleByChannelFCollisionQueryParamsLineTraceSingleByObjectTypeFCollisionObjectQueryParamsCollision关于UE4中的碰撞系统，是个很复杂的问题，在这里只是针对Trace需要的碰撞记记载。 Collision Response Reference Collision Response Reference]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我所理解的Unity-IK]]></title>
    <url>%2Fthe-inverse-kinematics-wat-i-understand%2F</url>
    <content type="text"><![CDATA[在程序中人物模型出现很自然的运动的时候，大部分情况下我都觉得应该是动画的运动。由动作设计师准备好的动画，工程师将动画拆分组合这样的。然而实际上貌似并不是。 Root Motion Unity - Manual: Root Motion - how it works 在此之前，先介绍一下RootMotion。 Generic 动画中 Root Motion的概念和使用 Inverse Kinematics Unity - Manual: Inverse Kinematics 反向运动学，这是中文翻译，一开始是懵的。 IK和FK对应，正向运动学就是根骨骼带动节点骨骼运动。而反向运动学就是由子节点带动父节点运动。 游戏中反向运动学(ik)的研究与简介 - 风恋残雪 - 博客园话说这个大佬的文章，我应该常常关注的。IK使用在上面提到的官方文档中有大致的使用方法。具体的使用之后整理 VR - Final IK这个算是主角了，这篇文章的目的就是熟悉并使用这个Asset。（好贵） 主要还是看人家的官方视频： FINAL IK TUTORIAL Final IK Document Final IK の VRIK の Solver にある各値の説明 这个东西怎么说呢，我试着用了用，方便是方便，源码是C#的，读起来也不是很费力。但是最后我也就是用了FinalIk里的InteractionSystem，其他的都放弃了。想要在自己的代码里引用他的脚本文件会出error，然后一大堆的初始化内容需要重写，在Unity的Editor里直接拖拽就很方便，自己在代码里写就各种null。 搜了一下感觉这篇很有意思，先保存一下。 UnityとHTC VIVEでバーチャルアイドルに変身（ATL客員研究員寄稿記事） | Advanced Technology Lab. Leap Motion]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>IK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UniRx从入门到放弃]]></title>
    <url>%2Funirx-learning-note%2F</url>
    <content type="text"><![CDATA[时隔一年再次接触Unity，发生了好多变化，也许是之前见识也少的原因，遇到了UniRx这个库，刚遇到的时候感觉真是无从下手，就俩接口，叫我看不出来个所以然。 理解UniRx我来了，我表示我并没有理解UniRx，只知道是个什么东西远远不够。当出现Operator的使用的时候，我发现我根本不理解。 UniRx(ユニアールエックス)の基本的な使い方と具体的な利用例【Unity】【UniRx】 UniRx 学习 Reactive ExtensionUniRx大体上的印象我是从这篇文章终于算是稍微理解了一些： UniRx入門 その1 这个作者还有一些其他的入门文章有时间也可以观摩一下:UniRx入門シリーズ 目次はこちら UniRxを導入するメリット ～こういう時にUniRxは使えるよ～ 超级有用的一篇知乎文章： 又见Rx——Rx via UniRx 里面的那个讲Rx的视频真的很厉害。 SubscribeOnMainThread &amp; ObserveOnMainThread这个是做什么的 How to use SubscribeOnMainThread? It seems never working #282 SubscribeOnMainThread means that you are subscribing (therefore starting the task [for cold observables]) in main thread whereas ObserveOnMainThread means that you are observing (listening) onNext messages in main thread. When you are using Observable.Start method, the task will be run on the ThreadPool by default. So use it with the ObserveOnMainThread to access Unity API in the Subscribe method. 从名字上也能大致了解，就是为了让Subscribe中的内容在MainThread中执行。因为涉及到Unity的GameObject的操作都要在主线程中进行。 按理说我应该试着使用这两个方法，再去了解这个方法应不应该这样用，也就是试错。 但是我听前辈说这两个方法不太靠得住（意思应该就是使用的时候可能会报错，因为在子线程中动Unity的GameObject，或者Unity的一些东西，编译就会报错，会好好的报出错误信息的），最靠谱的方式是用await UniTask.Yield()。至于具体怎么用，在后面的地方专门展开。 ObserveEveryValueChangedObservable Observable Disposables这个也是一个很重要的概念。 Disposables Operators UniRx オペレータ逆引き Switch Rxにおける並行非同期実行とリソース処理の問題 Do 【Unity】【UniRx】Observable.DoXxx()系のメソッドの挙動まとめ Reactive Programming(重要) Introduction to Reactive Programming]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>UniRx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我所理解的Lambda表达式]]></title>
    <url>%2Fthe-lambda-what-i-understand%2F</url>
    <content type="text"><![CDATA[纠结了好久，最终决定把lambda这个部分从Unity中分离出来单独总结。理解并能够使用Lambda表达式是这篇文章的目的。除此之外如果有关于lambda的拓展用法亦或者好的使用案例一并在这里记录。 首先是Lambda的基础概念 Lambdalambda expressions是什么 A lambda expression is a block of code (an expression or a statement block) that is treated as an object. It can be passed as an argument to methods, and it can also be returned by method calls. 来自 Lambda expressions (C# Programming Guide) 匿名函数，也可以这样叫，将函数作为对象处理，用{}包含。因为最近一年之和C++打交道，C#的语言机制究竟是什么样子的完全不记得了，关于C#的编译执行过程应该与C++区别并整理到别的文章去。 但是就C++的感觉来说，lambda给我的印象就是函数指针。但是内部的处理我还是不清楚(无论是C#还是C++)，比如说函数指针(lambda)的调用代价是什么样子的，跟普通的函数调用有什么区别等等。 但是这些先放一边，将lambda视为一个对象，可以作为参数①，可以作为返回函数调用②。 lambda怎么用既然要使用lambda就要知道它的使用方式是什么样子的。 私はこうしてLINQ・ラムダ式を理解できた（入門） 这篇涉及了一些Linq的东西，讲的会比较多一些，但是很好的涵盖的lambda的继承用法。 C# 今更ですが、ラムダ式 这篇讲的内容比较少但是对于基础讲的很具体。 lambda文法什么时候用lambda]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS中有用的插件]]></title>
    <url>%2Fvisual-studio-plugins%2F</url>
    <content type="text"><![CDATA[我觉得我应该好好钻研一下这个“宇宙第一”的各种用法了，好多意想不到的插件甚至是快捷键我都不知道。 PluginsVsVimProductivity Power Tools Productivity Power Tools 2017/2019 具体的功能之后有时间整理一下。 关于注释 How to: Insert XML comments for documentation generation 主要是我想知道使用///来插入一段完整的段落注释的方法。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>plugins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity知识点记录]]></title>
    <url>%2Funity-learning-note%2F</url>
    <content type="text"><![CDATA[更新内容(2019/05/29) 更新MenuItem的详细使用 Unity的使用这次终于不是自己单枪匹马的干，而是真的项目中使用Unity引擎来做开发了。 先附上官方文档： Unity User Manual (2019.1) 1.Unity C# 中的一些比较重要的使用1.MenuItem1234#if UNITY_EDITOR [UnityEditor.MenuItem(&quot;Project/Operation&quot;) public static void OperationRun()&#123;&#125;#endif 或者12345using UnityEditor;using UnityEngine; [MenuItem(&quot;Project/Operation&quot;)] public static void OperationRun()&#123;&#125; 上面的用法，貌似也可以被叫做Debug Menu ,感觉用处相当大。 便利的调用一些比较麻烦的函数，触发条件和时机需要自己掌控等等，总而言之，这个很重要。 第8章 MenuItem 但是要注意添加的方法都是static的方法，调用非静态函数的方法，我知道的有两个: 1.向静态函数中传递对象引用。 2.在静态函数遍历所有对象找到那个想要的对象并调用对象函数，这限于Unity中debug场景，毕竟可以遍历场景中的所有对象。使用FindObjectofType之类的函数。 其他要注意的是，这个功能算是对UnityEditor的扩展功能，使用的时候不要忘记：12345#if UNITY_EDITORusing UnityEditor#endif加上编译选项才安全。 2.Unity C# 中的序列化(Serialization) Unity与C#的序列化与反序列化 Unity 遊戲存檔機制淺談，從序列化 (Serialization) 到儲存裝置 (Storage) SerializeField Unityの[SerializeField]について色々な疑問に答えてみる HideInInspector【Unity】HideInInspectorとSerializeFieldの興味深い関係 Serializable [Unity] 自前のクラスをインスペクタから編集できるようにする 3.MessagePack 黒騎士と白の魔王におけるMessagePack-CSharpのUnionの活用事例 4.FindObjectOfType （シーン上にある該当する物の中からUnityが適当に選んだ１つが返ります。１つも存在していなかったらnullが返ります） ゲームオブジェクトを参照して、スクリプトにアクセスするのがGetCompornetで、 スクリプトを参照して、スクリプトにアクセスするのがFindObjectOfTypeです。 就像上面说的那样，下面附上使用： Object.FindObjectOfType Object.FindObjectsOfType 123public static Object FindObjectOfType (Type type);public static Object[] FindObjectsOfType (Type type); 这个方法非常低效，不适合在每一帧都调用，可以利用SingletonPattern。 【Unity】GameObject.Find 系関数の処理速度の検証結果 5. Attribute1. AddComponentMenu2. RequireComponent6. CustomEditor7. ContextMenu可以在Inspector视图里直接调用函数？ 2.C# 语法？类型声明 Why is there a questionmark on the private variable definition? ?? operator What do two question marks together mean in C#? $ operator $ - 字符串内插（C# 参照） =&gt; operator看见的第一眼以为是lambda表达式，但是后面接着出现的是是变量而不是表达式。 C# の =&gt; プロパティ 相当于{get;}但是又不是简单的get。 123◆ private A a =&gt; new A();◆ ＝ private A a &#123; get &#123; return new A(); &#125; &#125; ◆ ≠ private A a &#123; get; &#125; = new A(); where关键字 where (generic type constraint) (C# Reference) 一般类型约束？ For example, you can declare a generic class, MyGenericClass, such that the type parameter T implements the IComparable&lt;T&gt; interface:1public class AGenericClass&lt;T&gt; where T : IComparable&lt;T&gt; &#123; &#125; 使用了模板但是约束了类型，是这样的么。 我发誓这个关键字在我以前用C#的时候肯定知道，但是我忘了。。 @ What does the @ symbol before a variable name mean in C#? [duplicate] await/async C# 今更ですが、await / async Taskを極めろ！async/await完全攻略 IEnumerator [C#]IEnumeratorとIEnumerableを調べた 3.Unity语法1.Instantiate根据Prefab生成实例。 3.LINQ (Linq) はじめての LINQ - Qiita 当我想深入了解LINQ的时候，我发现我需要先理解Lambda表达式。 4.Reactive Extensions (Rx) こわくないReactive Extensions超入門 - Qiita 5.UniRx 又见Rx——Rx via UniRx 这是我在知乎上找到的一篇文章，感觉能学到很多东西。 Reactive Extensions for Unity UniRxを導入するメリット ～こういう時にUniRxは使えるよ～ - Qiita 6.Lambda直接搜C# lambda最先出来的三个链接。 Lambda expressions (C# Programming Guide) =&gt; operator (C# Reference) Unity中的插件SteamVR Unity要记录的是SteamVR Unity Plugin v2这个Unity的VR开发插件。开始调查这个插件的契机是不知道SteamVR_Behaviour_Pose这个类的作用，而明白这个是插件的内容。 Unity＋HTC Vive開発メモ Unity標準のVR機能（UnityEngine.XR）メモ 上面的这个人的文章我看很厉害就直接先粘链接了。 SteamVR_Behaviour_PoseAmplify Shader Editor 【Amplify Shader Editor】ノードベースでシェーダ作りのAmplifyを触ってみました。エディタの操作性、学習コスト、サンプルデモを大量に紹介！]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>笔记</tag>
        <tag>plugins</tag>
        <tag>Unity2019.1.3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习OpenGL]]></title>
    <url>%2Flearn-opengl%2F</url>
    <content type="text"><![CDATA[再不赶上日程把OpenGL看了，那可就真的要懒死了啊。 OpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的常见关键字记录]]></title>
    <url>%2Fc%2B%2B-modifier-keyword%2F</url>
    <content type="text"><![CDATA[之后需要整理并理解的: explicit说明符 偶然看见的: explicitとvolatileキーワード(C++) Typedefの考え方 除了关键字，符号也算 *p++のお話(インクリメント演算子って不思議だね]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Next博客修缮笔记]]></title>
    <url>%2FHexo%2BNext-maintain-myblog-note%2F</url>
    <content type="text"><![CDATA[自从发现自己写的东西被人原封不动的复制粘贴扔到了CSDN之后，曾经一度想要废了这个博客，写博客对我来说就是一个记笔记的过程，记录自己工作中遇到的问题和解决过程，顺便写写自己的心得什么的，就是很随意。未想着给别人看，但是要是写的某一个地方帮上了某个地方的某个人也是好事情，哪怕不知道有没有，但也是一种安慰了。所以博客自建成起，就根本没设置什么自欺欺人的评论功能点赞功能。也没想着会有。 但是整篇文章直接贴走，连个转载链接都不留是不是就有些过分了，生气不可避免了但是也只是只能无能狂怒了。去CSDN注册个账户举报？说到底对于我去CSDN注册账户这件事情都很抵触。算了，就算了吧。 关于博客内容书写代码部分果然UE4中的有些代码不会给你高亮，看起来就很不舒服，有时间填一下坑。 关于博客构建1. 博文压缩我之前貌似有整过这个叫做gulp的东西。而且连gulpfile.js这个文件也存在。 因为用起来麻烦就忘了。 执行 hexo g &amp;&amp; gulp 就会压缩public中的静态资源文件。 2.修改代码块自定义样式\themes\next\source\css\_custom\custom.styl 123456789101112131415// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; 我加入了上面的代码，原先是什么都没有的… 看了下效果，嗯，感觉什么都没变。 寝るか]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++编程思想-第一卷-第十五章-多态性和虚函数]]></title>
    <url>%2Fc%2B%2B-chapter15-virtual%2F</url>
    <content type="text"><![CDATA[多态性（在C++中通过虚函数来实现）是面向对象程序设计中数据抽象和继承之外的第三个基本特征。 多态性和虚函数15.1 C++程序员的演变虚函数增强了类型概念，而不是只在结构内部隐蔽的封装代码，所以毫无疑问，对于新的C++程序员来说，这些概念是最困难的。然而它们是理解面向对象程序设计的转折点。如果不用虚函数，就等于还不懂得面向对象程序设计（OOP）。 15.2 向上类型转换在第14章中，我们已经看到对象如何能作为它自己的类或作为它的基类的对象使用。另外，还能通过基类的地址操作它。取一个对象的地址（指针或者引用），并将其作为基类的地址来处理，这被称为向上类型转换（upcasting），因为继承树的绘制方式是以基类为顶点的。 15.3 捆绑（binding）15.3.1 函数调用捆绑把函数体与函数调用相联系称为捆绑。当捆粄在程序运行之前（由编译器和连接器）完成时，称为早捆绑（early binding）。 晚捆绑（late bingding）根据对象的类型，发生在运行时。又称为动态捆绑（dynamic binding）或运行时捆绑（runtime binding）。 15.4 虚函数对于特定的函数，为了引起晚捆绑，C++要求在基类中声明这个函数的时候使用virtual关键字。晚捆绑只对virtual函数起作用，而且只在使用含有virtual函数的基类的地址时发生，尽管它们也可以在更早的基类中定义。 仅仅在声明的时候需要使用virtual关键字，定义时不需要。 如果一个函数在基类中被声明为virtual，那么在所有的派生类中它都是virtual。在派生类中virtual函数的重定义通常称为重写（overriding）。 注意，仅需要在基类中声明一个函数为virtual。调用所有匹配基类声明行为的派生类函数都将使用虚机制。虽然可以在派生类声明前使用关键字virtual（这也是无害的），但这样会使程序段显得冗余和混乱。 15.4.1 扩展性编译器保证对于虚函数总是有某种定义，所以绝不会出现最终调用不与函数体捆绑的情况（这种情况将导致灾难）。 这里我有相当大的疑问： 按照上面的说法，继承的基类中有虚函数的情况下，派生类都将使用虚机制 虚机制是什么 其次，按照上面的描述在派生类声明前加上virtual也可以，也就是说派生类中的函数也称为了虚函数？ 然后是在派生类中定义了一个名为FunctionA()的新的函数的话，这个函数尽管没有加入virtual关键字，实际上也是虚函数？ 然后假设从相同基类派生的派生类PAClass()和PBClass()两个同时新定义了一个名为FunctionA()的函数的话，这种情况下他们是相同的虚函数吗？ 按照书上说的意思（我的理解），出现上面情况的时候，将会自动的调用继承层次中“最近”的定义。 但我不太懂。还是得继续摸索下去。 15.5 C++如何实现晚捆绑当告诉编译器要晚捆绑时（通过创建虚函数来告诉），编译器安装必要的晚捆绑机制。 关键字virtual告诉编译器它不应当执行早捆绑，相反，它应当自动安装对于实现晚捆绑必须的所有机制。 为了达到这个目的，典型的编译器（通用的方法）对每个包含虚函数的类创建一个表（称为VTABLE）。在VTABLE中，编译器放置特定类的虚函数的地址。在每个带有虚函数的类中，编译器秘密的放置一个指针，称为vpointer（缩写为VPTR），指向这个对象的VTABLE。当通过基类指针做虚函数调用时（也就是做多态调用），编译器静态的插入能取得这个VPTR并在VTABLE表中查找函数地址的代码，这样就能调用正确的函数并引起晚捆绑的发生。 15.5.1 存放类型信息必须有一些类型信息放在对象中，否则类型将不能在运行时建立。但是类型信息被隐蔽了。 不带虚函数，对象的长度恰好就是所期望的长度。而带有单个或多个虚函数的对象，是所期望的长度加上一个void指针的长度。 它反映出，如果有一个或多个虚函数，编译器都只在这个结构中插入一个单个指针（VPTR）。这是因为VPTR指向一个存放函数地址的表。 15.5.2 虚函数功能图示上不了图了 每当创建一个包含有虚函数的类或从包含有虚函数的类派生一个类时，编译器就为这个类型创建一个唯一的VTABLE。在这个表中，编译器放置了在这个类中或在它的基类中所有已声明为virtual的函数的地址。如果在这个派生类中没有对基类中声明为virtual的函数进行重新定义，编译器就使用基类的这个函数的虚函数地址。 当使用简单继承时，对于每个对象只有一个VPTR。VPTR必须被初始化为指向VTABLE的起始地址。（这个在构造函数中发生，在稍后会看的更清楚） 一旦VPTR被初始化为指定相应的VPTR。对象就知道它自己是什么类型。但只有当虚函数被调用的时候这种自我认知才有用。 当通过基类地址调用一个虚函数时（此时编译器没有能完成早捆绑所需的所有信息），要特殊处理。它不是实现典型的函数调用，那样只是简单的用汇编语言CALL特定的地址，而是编译器为完成这个函数调用而产生不同的代码。 此处应有图但是上不了。 编译器从这个Instrument（基类）指针开始，这个指针指向这个对象的起始地址。对于所有的Instrument对象和由Instrument派生的对象，它们的VPTR都在对象的相同位置（常常在对象的开头），所以编译器就能取出这个对象的VPTR。VPTR指向VTABLE的起始地址。所有的VTABLE都具有相同的顺序，不管何种类型的对象。Play()是第一个， What()是第二个， Adjust()是第三个。所以无论是什么特殊的对象类型，编译器都知道Adjust()是必在VPTR+2处。这样就不是以“Instrument::Adjust”地址调用这个函数，而实际上是在“VPTR+2”处调用这个函数。因为获取VPTR和确定实际函数地址发生在运行时，所以这样就得到了所希望的晚捆绑。 15.5.3 揭开面纱看一下虚函数调用产生的汇编语言代码。下面是在函数f(Instrument&amp;i)内部调用 i.Adjust(1); 某个编译器所产生的输出：12345push 1push simov bx, word ptr [si]call word ptr [bx+4]add sp, 4 说实话我是看不懂汇编的。 C++函数调用的参数与C函数调用一样，是从右向左进栈的（这个顺序是为了支持C的变量参数表），所以参数1首先压栈。对于这个函数，寄存器si（Intel x86处理器的一部分）存放i的地址。因为它是被选中对象的首地址，它也被压进栈。记住，这个首地址对应this的值，正因为调用每个成员函数时this都必须作为参数压进栈，所以成员函数知道它工作在哪个特殊对象上。这样我们总能看到，在成员函数调用之前压栈的次数等于参数个数加1（除了static成员函数，因为它没有this）。 然后必须实现实际的虚函数调用。首先，必须产生VPTR，找到VTABLE。对于这个编译器，VPTR在对象的开头，所以this的内容对应于VPTR。1mov bx, word ptr [si] 取出si（即this）所指的字，它就是VPTR。将VPTR放入bx寄存器中。 在bx中这个VPTR指向VTABLE的首地址，调用的函数在VTABLE中的第二个位置（0，1，2,它是表中的第三个函数）。对于这种内存模式，每个函数指针是两个字节长，所以VPTR+4，计算相应的函数地址所在的地方。 幸好编译器仔细处理，并保证VTABLE中的所有函数指针都以相同的次序出现，而不论我们在派生类中是以什么样的顺序覆盖它们。 一旦VTABLE中相应函数指针的地址被计算出来，就调用这个函数。所以取出这个地址并马上在这个句子中调用。1call word ptr [bx+4] 最后栈指针移回去，以清除在调用之前压入栈的参数。在C和C++汇编代码中，将经常看到调用者清除这些参数，但这可能依据处理器和编译器的实现而有所不同。 15.5.4 安装vpointer因为VPTR决定了对象的虚函数的行为，所以我们看到VPTR总是指向相应的VTABLE是多么重要。在VPTR适当初始化之前绝不能调用虚函数。 15.5.5 对象是不同的认识到向上类型转换仅处理地址，这是重要的。 如果编译器有一个它知道确切类型的对象，那么（在C++中）对任何函数的额调用不再使用晚捆绑，或至少编译器不必使用晚捆绑。因为编译器知道对象的确切类型，为了提高效率，当调用这些对象的虚函数时，很多编译器使用早捆绑。 12345678910111213141516171819202122232425// Early binding &amp; virtual functions#include &lt;iostream&gt;#include &lt;stream&gt;using namespace std;class Pet&#123;public: virtual string speak() const &#123;return "";&#125;&#125;;class Dog : public Pet&#123;public: string speak() const &#123;return "Bark";&#125;&#125;;int main() &#123; Dog ralph; Pet* p1 = &amp;ralph; Pet&amp; p2 = ralph; Pet p3; p1-&gt;speak(); p2.speak(); p3.speak();&#125;; 使用地址就意味着不完全，p1,p2可能表示Pet的地址，也可能是其派生对象的地址，所以必须使用虚函数。而当调用p3的时候,不存在含糊，编译器知道确切的类型并且知道它是一个对象，这样可以使用早捆绑。 15.6 为什么需要虚函数virtual关键字可以改变程序的效率。 从前面的汇编语言输出可以看出，它并不是对于绝对地址的一个简单的CALL，而是为设置虚函数调用需要两条以上的复杂的汇编指令。这既需要代码空间，又需要执行时间。 15.7 抽象基类和纯虚函数在基类中加入至少一个纯虚函数（pure virtual function），来使基类称为抽象（abstract）类。纯虚函数使用virtual关键字，并且在后面加上=0.如果某人试着生成一个抽象类的对象，编译器就会制止他。 当继承一个抽象类时，必须实现所有的虚函，否则继承出的类也将是一个抽象类。 纯虚函数的声明语法：1virtual void f() = 0; 这样做，等于告诉编译器在VTABLE中为函数保留一个位置，但在这个特定位置中不放地址（或者说是放不了地址），只要有一个函数在类中被声明为纯虚函数，则VTABLE就是不完全的。编译器不能安全的创建一个纯抽象类的对象，保证了抽象类的纯洁性，就不会被误用了。 注意，纯虚函数禁止对抽象类的函数以传值方式调用。 这也是防止对象切片（object slicing）的一种方法。通过抽象类，可以保证在向上类型转换期间总是使用指针或引用。 纯虚函数防止产生完全的VTABLE，但这并不意味着我们不希望对其他一些函数产生函数体。我们常常希望调用一个函数的基类版本，即使它是虚拟的。把公共代码尽可能靠近我们的类层次根的地方，这是很好的想法。 也就是说下面的纯虚函数定义了 15.7.1 纯虚定义在基类中，对纯虚函数提供定义是可能的。我们仍然告诉编译器不允许产生抽象基类的对象，如果想要创建对象，则纯虚函数必须在派生类中定义。 好处一： 然而我们希望一段公共代码，使一些或所有派生类都能调用，而不必在每个函数中重复这段代码。 如下面的代码：12345678910111213141516171819202122232425262728293031// Pure virtual base definitions#include &lt;iostream&gt;using namespace std;class Pet&#123;public: virtual void speak() const = 0; virtual void eat() const =0; // Inline pure virtual definitions illegal: //! virtual void sleep() const = 0 &#123;&#125;&#125;;// OK, not defined inlinevoid Pet::eat() const&#123; // Do something&#125;void Pet::speak() const&#123; // Do something&#125;class Dog : public Pet &#123; void speak() const &#123; Pet::speak(); &#125; void eat() const &#123; Pet::eat(); &#125;&#125;;int main() &#123; Dog d; d.speak(); d.eat();&#125; Pet的VTABLE依然空着，但这个派生类中刚好有一个函数，可以通过名字调用它。 好处二： 这个特点的另一个好处是，它允许我们实现从常规函数到纯虚函数的改变，而无需打乱存在的代码。（这是一个处理不用重新定义虚函数的类的方法） 隐约觉得这个功能很强，让我联想到了静态函数，你看它直接通过类名调用就很厉害。这应该又涉及到另外的机制了吧。 15.8 继承和VTABLE当实现继承和重新定义一些虚函数时，编译器对新类创建一个新的VTABLE表，并且插入新函数的地址，对于没有重新定义的虚函数使用基类函数的地址。无论如何，对于被创建的每个对象（即它的类不含有纯虚函数），在VTABLE中总有一个函数地址的全集，所以绝对不能对不在其中的地址进行调用（否则结果将是灾难性的）。 当派生类继承了基类中的虚函数之后又增加了新的虚函数。可以知道VTABLE中增加了新的虚函数。 然而在这里，编译器只对指向基类对象的指针工作。即基类的虚函数是指向基类对象指针的编译器唯一允许调用的函数。 这跟我的理解是一致的，使用指向基类的指针并不能够调用子类新添加的函数时理所应当的。 只有基类对象的指针，那么编译器也不知道这个指针指向的内容是不是派生类，所以编译器通过防止我们对只存在于派生类中的函数做虚函数调用来完成工作。 但是当我们知道指针实际上指向哪一种特殊对象时，还想要去使用的少数情况时，则必须类型转换这个指针。 这就是运行时类型辨认（Run-Time Type Identification, RTTI） 问题。 RTTI是有关向下类型转换基类指针到派生类指针的问题（向上和向下是相对典型类图而言的，典型类图以基类为顶点）。向上类型转换是自动发生的，不需强制，因为它是绝对安全的。向下类型转换是不安全的，因为这里没有实际类型的编译时信息，所以必须准确的知道这个类实际上是什么类型。 15.8.1 对象切片对象切片实际上是当它拷贝到一个新的对象时，去掉原来对象的一部分，而不是使用指针或者引用那样简单的改变地址的内容。 15.9 重载和重新定义在第14章中，我们看到重新定义一个基类中的重载函数将会隐藏所有该函数的其他基类版本。 而当对虚函数进行这些操作时，情况会有点不同。 编译器不允许我们改变重新定义过的函数的返回值（如果该函数不是虚函数，则是允许的）。12345678910class Base &#123;public: virtual int f() const &#123;&#125;&#125;class Derived3 : public Base &#123;public: // Can not change return type: //! void f() const &#123; // do something&#125;&#125; 如果重新定义了基类中的一个重载成员函数，则在派生类中其它的重载函数将会被隐藏。 虚函数还写函数重载这个想法我还真没想到。 有的时候这种情况还真有，也许是考虑不足的缘故，当试着写了一个共通的虚函数，这个虚函数并不能适应所有的情况，比如说参数个数或者类型不匹配的情况，就会写出将父类继承来的虚函数进行重载的情况。 这里需要理清的的是，我们是因为什么才引进的虚函数。 我自己的理解是，是为了一劳永逸，调用一处的代码（使用父类虚函数调用）然后传递子类指针，子类的虚函数实现就被执行。 但是发生上面的虚函数重载情况怎么说？ 首先，需要理解虚函数重载之后发生了什么，即上面所说的，该函数的重载，使得该函数的所有其他版本被隐藏。救我自己的观察来看，造成的现象是： member function does not override any base class virtual member function 并没有重写任何基类函数？！ no override available for virtual member function from base &#39;BaseFunction&#39;; function is hidden 基类虚函数没有被实现，函数被隐藏？ 上面的这是编译器给出的警告信息，并不是错误。从信息来看，意思完全不一样。完全成了同名的函数，跟基类完全没有关系似的。 override Specifier override Specifier 1function-declaration override; 对基类的虚函数进行重载时，加override会出编译错误(修改参数或者const修饰符等) 试图重载基类的非虚函数时，加override会出编译错误 都是上面官方链接的例子。 final Specifier final Specifier 12function-declaration final;class class-name final base-classes 15.9.1 变量返回类型上面显示了我们不能重新定义过程中修改虚函数的返回类型。通常是这样的，但也有特例，我们可以稍稍修改返回值类型。如果返回一个指向基类的指针或引用，则该函数的重新定义版本将会从基类返回的内容中返回一个指向派生类的指针或引用。 返回确切类型更通用些，而且在自动进行向上类型转换时不丢失特定的信息。然而，返回基类类型通常会解决我们的问题，所以这是一个特殊的功能。 这个感觉就像是编译器会做返回值的类型检查，对于指针而言，返回基类类型指针的函数得到了一个派生类类型的指针，由于继承的特性，所以这是成立的。反过来应该就不行。 15.10 虚函数和构造函数编译器在构造函数的开头部分秘密地插入能初始化VPTR的代码。正如第14张所述，如果我们没有为一个类显式创造构造函数，则编译器会为我们生成构造函数。如果该类含有虚函数，则生成的构造函数将会包含相应的VPTR初始化代码。这有几个含义。 首先，这涉及效率。内联（inline）函数 的作用是对小函数减少调用代价。如果C++不提供内联函数，则预处理器就可能被用来创建这些“宏”。然而预处理器没有访问或类的概念。因此不能被用来创建成员函数宏。另外，有了由编译器插入的隐藏代码的构造函数，预处理宏根本不能工作。 上面这段话看得我不知所谓，事实来说C++提供了内联函数。我不太理解预处理宏是什么，最后一句为什么那种情况下预处理宏不能工作的具体原因是什么？ 当寻找效率漏洞时，我们必须明白，编译器正在插入隐藏代码到我们的构造函数中。这些隐藏代码不仅必须初始化VPTR，而且还必须检查this的值（以免operator new返回零）和调用基类构造函数。放在一起，这些代码可以影响我们认为是一个小内联函数的调用。特别是构造函数的规模会抵消函数调用代价的减少。如果做大量的内联函数调用，代码长度就会增长。而在速度上没有任何好处。 当然也许并不会立即把所有这些小构造函数都变成非内联，因为它们更容易写为内联构造函数。但是，当我们正在调整我们的代码时，记住，务必去掉这些内联构造函数。 所以这些内联构造函数是可以删除的？还是说变成非内联？ 15.10.1 构造函数调用次序所有基类构造函数总是在继承类构造函数中被调用。 15.10.2 虚函数在构造函数中的行为对于在构造函数中调用一个虚函数的情况，被调用的只是这个函数的本地版本。也就是说，虚机制在构造函数中不工作。 这种行为有两个理由。在概念上，构造函数的工作是构造一个对象。在构造函数中此时可能只是部分形成对象–我们只能知道基类已被初始化，但并不能知道是那个类从这个基类继承来的。然而，虚函数在继承层次上是“向前”和“向外”的进行调用。它可以调用在派生类中的函数。如果我们在构造函数中也这样做，那么我们所调用的函数可能操作尚未初始化的成员，导致灾难的发生。 第二个理由是机械的。当一个构造函数被调用的时候，它做的首要事情之一是初始化它的VPTR。然儿它知道它属于“当前”类，即构造函数所在的类。当编译器为这个构造函数产生代码时，它使用的VPTR必须是对于这个类的VTABLE。VPTR的状态是由最后被调用的构造函数确定的。 这就是为什么构造函数调用是按照从基类到最晚派生类的顺序的另一个理由。 另外，许多编译器认识到，如果在构造函数中进行虚函数调用，应该使用早捆绑，因为它们知道晚捆绑将只对本地函数产生调用。无论哪种情况，在构造函数中调用虚函数都不能得到预期的结果。 15.11 析构函数和虚拟析构函数构造函数是不能为虚函数的。但析构函数能够且常常必须是虚的。 构造函数有一项特殊的工作，就是一块一块的组合成一个对象。它首先调用基类构造函数，然后调用继承顺序中的更晚派生的构造函数（同样，它也必须按此方法调用成员对象构造函数）。类似的，析构函数也有一项特殊工作，即它必须拆卸属于某层次类的对象。为了做这些工作，编译器来生成代码来调用所有的析构函数，但它必须按照与构造函数调用相反的顺序。 应当记住，构造函数和析构函数是类层次进行调用的唯一地方（因此，编译器自动的生成适当的类层次）。在所有其它函数中，只有这个函数会被调用（非基类版本），而无论它是虚的还是非虚的。同一函数的基类版本在普通函数中被调用（无论是虚的还是非虚的）的唯一方法是显式的调用这个函数。 如果这个指针是指向基类的，在delete期间，编译器只能知道调用这个析构函数的基类版本。这听起来很耳熟，虚函数被创建恰恰是为了解决这个问题。幸运的是，就像除了构造函数以外的所有其他函数一样，析构函数可以是虚函数。 上面的指针指向基类的例子中，如果使用的delete，会依次调用自身的析构函数，然后调用基类的析构函数。前提是:基类的析构函数是虚函数。 这正是我们所期望的。不把析构函数设为虚函数是一个隐匿的错误，因为它常常不会对程序有直接的影响。 但要注意它不知不觉的引入存储器泄漏（关闭程序时内存未释放）。同样，这样的析构操作还有可能掩盖发生的问题。 我靠这到底想让我怎么写？！ 即使析构函数像构造函数一样，是“例外”函数，但是析构函数可以是虚的，这是因为这个对象已经知道它是什么类型（而在构造期间则不然）。一旦对象已被构造，它的VPTR就已被初始化，所以能发生虚函数调用。 15.11.1 纯虚析构函数尽管纯虚析构函数在标准C++中是合法的，但在使用的时候有一个限制:必须为纯虚析构函数提供一个函数体。 不像其他的纯虚函数，我们不要求派生类中提供纯虚函数的定义。 1virtual ~AbstractBase() = 0; 析构函数的纯虚性的唯一效果是阻止基类的实例化。如果有其他的纯虚函数，则它们会阻止，否则，纯虚析构函数会执行这项操作。所以当虚析构函数是十分必要时，则它是不是纯虚的就不是那么重要了。 15.11.2 析构函数中的虚机制在析构函数中，只有成员函数的“本地”版本被调用；虚机制被忽略。 在构造函数的情况下这样做是因为类型信息还不可用，然而在析构函数中，这样做是因为信息（也就是VPTR）虽存在，但不可靠。（可能派生的对象已被析构）。 15.11.3 创建基于对象的继承利用多态性，强制容器中的所有对象从一个基类中继承而来，随后调用虚函数（虚析构函数）来解决所有权问题。 这种解决方法使用单根继承（singly-rooted hierarchy）或基于对象的继承（object-based hierachy）。 事实上，除了C++，每种面向对象的语言都强制使用这样的体系，这个基类由该语言的创建者生成的。C++中认为，强制使用这个公共基类会引起太多的开销，所以便没有使用它。 这里需要警惕多重继承（multiple inheritance）。多重继承是非常复杂的，应尽量少用这一功能。 创建包容Object的容器是一种合理的方法–如果使用单根继承（由于语言本身或需要的缘故，强制每个类继承自Object）。这时，保证一切都是一个Object，因此使用容器的时候并不是十分复杂。然而在C++中不能期望这适用于每一个类，所以如果有多重继承就会出现问题。在第16章中会看到模板可以使用更简单更灵巧的方式处理这个问题。 15.2 运算符重载就像对成员函数那样，我们可以使用virtual运算符。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 对于一个处理矩阵向量标量的系统，这三个成分都是派生自Math类// Polymorphism with overload operators#include &lt;iostream&gt;using namespace std;class Matrix;class Scalar;class Vector;class Math&#123;piblic: virtual Math&amp; operator*(Math&amp; rv) = 0; virtual Math&amp; multiply(Matrix*) = 0; virtual Math&amp; multiply(Scalar*) = 0; virtual Math&amp; nultiply(Vector*) = 0; virtual ~Math() &#123;&#125;&#125;;class Matrix : public Math&#123;public: Math&amp; operator*(Math&amp; rv)&#123; return rv.multiply(this); // 2nd dispatch &#125; Math&amp; multiply(Matrix*)&#123; cout&lt;&lt; "Matrix*Matrix"&lt;&lt;endl; return *this; &#125; Math&amp; multiply(Scalar*)&#123; cout&lt;&lt;"Scalar*Matrix"&lt;&lt;endl; return *this; &#125; Math&amp; multiply(Vector*)&#123; cout&lt;&lt;"Vector*Matrix"&lt;&lt;endl; return *this; &#125;&#125;;class Scalar : public Math&#123;public: // 内容省略，跟Matrix类的实现基本一致&#125;;class Vector : public Math&#123;public: // 内容省略，跟Matrix类的实现基本一致&#125;;int main()&#123; Martix m;Vector v;Scalar s; Math* math[] = &#123;&amp;m, &amp;v, &amp;s&#125;; for (int i =0 ;i &lt; 3; i++)&#123; for (int j = 0;j&lt;3;j++)&#123; Math&amp; m1 = *math[i]; Math&amp; m2 = *math[j]; m1*m2; &#125; &#125;&#125; main()中的问题在于，表达式m1*m2包含了两个向上类型转换的Math引用，因此不知道这两个对象的类型。一个虚函数仅能进行单一指派–即判定一个未知对象的类型。 本例中使用的判定两个对象类型的技术称之为多重指派（multiple dispatching） ，一个单一虚函数调用引起了第二个虚函数的调用。在完成第二个调用的时候，已经得到了两个对象的类型，于是可以执行正确的操作。 15.13 向下类型转换（downcasting）C++提供了一个特殊的称为dynamic_cast的显式类型转换（explict cast），它就是一种安全型向下类型转换（type-safe downcasting）的操作。当使用dynamic_cast来试着向下类型转换一个特定的类型，仅当类型转换是正确的并且是成功的时，返回值会是一个指向所需类型的指针，否则它将返回0来表示这并不是正确的类型。 123456789101112131415#include &lt;iostream&gt;using namespace std;class Pet &#123; public: virtual ~Pet()&#123;&#125; &#125;;class Dog : public Pet &#123;&#125;;class Cat : public Pet &#123;&#125;;int main() &#123; Pet* b = new Cat; // Upcast Dog* d1 = dynamic_cast&lt;Dog*&gt;(b); Cat* d2 = dynamic_cast&lt;Cat*&gt;(b);&#125; 当使用dynamic_cast时，必须对一个真正多态的层次进行操作–它含有虚函数–这是因为dynamic_cast使用了存储在VTABLE中的信息来判断实际的类型。 这里基类含有一个虚析构函数，这就足够了。 无论何时进行向下类型转换，我们都有责任进行检验以确保类型转换的返回值不为0。 dynamic_cast运行时需要一点额外开销；不多，但如果大量执行（程序设计有问题），就会影响性能。有时在进行向下类型转换的时候，我们知道正在处理的是何种类型，这时使用dynamic_cast产生的额外开销就没有必要，可以通过static_cast来代替它。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;class Shape &#123;public: virtual ~Shape() &#123;&#125;;&#125;;class Circle : public Shape &#123;&#125;;class Square : public Shape &#123;&#125;;class Other &#123;&#125;;int main()&#123; Circle c; Shape * s =c; //Upcast: normal and ok // More explicit but unnecessary s = static_cast&lt;Shape*&gt;(&amp;c); // (Since upcating is such a safe and common operation, the cast becomes cluttering) Circle* cp = 0; Square* sp = 0; // Static Navigation of class hierarchies requires extra type information: if(typeid(s) == typeid(cp)) //C++ RTTI cp = static_cast&lt;Circle*&gt;(s); if(typeid(s) == typeid(sp)) sp = static_cast&lt;Circle*&gt;(s); if(cp != 0) cout&lt;&lt;"It is a Circle"&lt;&lt;endl; if(sp != 0) cout&lt;&lt;"It is a Square"&lt;&lt;endl; // Static navigation is ONLY an efficiency hack; // dynamic_cast is always safer.However: // Other* op = static_cast&lt;Other*&gt;(s); // Conveniently gives an error message,while Other *op2 = (Other*)s; // does not&#125; RTTI允许我们得到向上类型转换时丢失的类型信息。dynamic_cast实际上就是RTTI的一种形式。这里typeid关键字（在&lt;typeinfo&gt;中声明）用来检测指针类型。RTTI的内容远不止typeid，我们也可以想象它能通过虚函数简单合理的实现我们自己的类型信息系统。 RTTI用于判定类型，static_cast用于执行向下类型转换。但要注意，这个设计中，处理效率同dynamic_cast是一样的，并且必须检测那些实际成功的类型转换。 如果类层次中没有虚函数（这是一个有问题的设计），或者如果有其他的需要，要求我们安全的进行向下类型转换，与使用dynamic_cast相比静态的执行向下类型转换会稍微快一点。另外，static_cast不允许类型转换到该类层次的外面，而传统的类型转换是允许的，所以他们会更安全。但是静态的浏览类层次是有风险的，所以除非特殊情况我们一般使用dynamic_cast。]]></content>
      <categories>
        <category>C++编程思想</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4-SplineComponent学习]]></title>
    <url>%2FUE4-%E5%90%84%E7%A7%8D%E6%8E%A7%E4%BB%B6%E6%88%96%E8%80%85%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[内容太少我决定把这篇合并一下，记录一些UE4中的插件亦或者某个功能的使用方法等等。偶然发现了一个很有趣的控件，Spline Component，感觉会很有用就记下来了。 Spline Using Splines &amp; Spline Components | Live Training | Unreal Engine 这是四年前的视频你敢信？！ 记录一下这个视频里出现的常用的关于Spline的操作函数。 Functions1.GetNumSplinePoints Store number of Spline points. 在Spline的Component中输入Get就能看到好多和其相关的函数。 2.AddSplinePoint Spline Mesh在C++中使用Spline从Actor中获取SplineComponent12345AActor* Object;USplineComponent * comp = Object-&gt;FindComponentByClass&lt;USplineComponent&gt;();float splineLength = comp-&gt;GetSplineLength(); 原本我是把这个Spline控件放在了一个Actor上面，然后更新DistanceAlongSpline的变量值来控制Actor在Spline上的位置，但是我却忽视了Actor移动的时候这个Spline也在移动，所以没有按照预期的进行。只有将Actor和spline分开，放到另外一个Actor上了。 Gameplay Tag UE4 Gameplay Tagを使ってゲームプレイ時のタグ管理をより扱いやすくする 其它 Everything you always wanted to know about Unreal Engine physics (but were afraid to ask) 100 UE4 Tips and Tricks | Unreal Fest Europe 2019 | Unreal Engine]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4-Material学习]]></title>
    <url>%2Fue4-material-learning%2F</url>
    <content type="text"><![CDATA[关于UE4中的材质，也有好多能说的，这里记录一些遇到的关于材质的知识点作为知识储备。 MaterialMaterial nodeShadowPassSwitchMaterial Parameter Collections Material Parameter Collections 材质应用 UE4 : 水彩 Post Process Material マテリアルとマテリアルインスタンスの仕組みと問題点の共有 (Epic Games Japan: 篠山範明) #UE4DD 猫でも分かるUE4のポストプロセスを使った演出・絵作り]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4-Performance提升]]></title>
    <url>%2Fue4-performance%2F</url>
    <content type="text"><![CDATA[主要记录一些能够查看UE4的性能工具和提升性能的一些手段记录。 我在知乎看见一篇文章整理的非常好： Performance and Profiling(UE4优化) Unreal 4 性能入门指南 根据这个再根据自己在工作中遇到的问题进行进一步细致的总结吧。 发现了BasePass的消耗很高，查一下。 1. Optimization关于一些渲染流程的说明： CEDEC2016: Unreal Engine 4 のレンダリングフロー総おさらい 上面的文章我之前有总结过一些，但是并没有完全理解。 1.1 Emulate HMD performance下面有提到VRSDK的设置（v-sync）会使得帧数锁在90fps那里，如果小于90fps就会直接降到45fps，不能够正确的测试处理时间。 我们可以模拟VR的绘制： Launch witch -emulatestereo Set resolution 2160x1200 Set r.screenpercentage 140 具体的做法如下： 在Editor Preferences &gt; Play &gt; Play in Standalone Game &gt; Additional Launch Parameters中填入 -emulatestereo Start with Standalone Mode and Set Resolution to r.SetRes 2160x1200 or r.SetRes 2160x1200f r.screenpercentage 140 1.2 Ready Profiling Play in Standalone Make sure the Editor is set to NOT update in realtime Minimize the Editor Make sure to turn off Frame Rate Smoothing[Project Settings] Turn off VSync[r.vsync 0] 使用r.ScreenPercentage 10命令，如果程序突然加速，说明性能瓶颈在GPU上。 引用来自下面的视频： UE4 Performance and Profiling 关于开始优化前的准备问题，流程可以参考一下[CEDEC2017] UE4プロファイリングツール総おさらい（グラフィクス編） 里面的内容。每次最好快速浏览一下。 然后是在准备Profile一定要先烘焙光照，要不然我真不知道在优化个什么鬼。因为在这个地方踩坑了。有位大佬在项目工程里放了一个范围超级大的Lightmass Importance Volume 导致UE4在烘焙的时候总是让Swarm一直卡在ExportScene阶段。(这里参考了Why is Swarm taking forever to export scene?) 1.3 VR Instanced Stereo这个可以在Edit &gt; Project Settings &gt; Rendering &gt; VR 中开启。 目的是为了让双眼的画面同时渲染。减少Draw Call。 于是我试了试，并没有变快..反而感觉慢了，因为瓶颈本来不是CPU么。使用应该有条件的。 VR Instanced Stereo 1.4 Rendering Pipeline刚刚好，趁着这个机会，顺便把渲染流程给描述出来，也就是每个阶段做了什么，既然要优化，就要知道做了设么，什么顺序做的。 至于流程的话参考了CEDEC2016 Unreal Engine 4 のレンダリングフロー総おさらい这篇文章。 关于这篇文章详细的解说下面PrePass章节部分有链接。 这个网站相当的 UNREAL ART OPTIMIZATION 官方网站的GPU Profiling 1.4.1 Z PrePassPrePass DDM_AllOpaque(Force by DBuffer)这个PrePass是不是上面的Z PrePass还有待确认，因为我是在GPUProfiler中看到的这个，也许是Z PrePass的一部分。 我看到的不是单单的PrePass，而是PrePass DDM_AllOpaque(Forced by DBuffer)。 这个Pass是用来先行计算Depth-Buffer的，在BasePass把数据写G-Buffer之前，把深度通过测试的像素留下，达到减少处理的目的，但是不是一定会减少。 这个可以ON/OFF，也可以开启之后指定物体经不过经过该处理。 所以说PrePass的目的是为了减少BasePass的处理负荷。 我在项目中发现的特点是：在所有的View0/View1中的处理中，还是Dynamic的时间最长。上面也有提到当动态的顶点，skeleton动画比较多的时候就会这样，可以试试关掉PrePass或者把顶点动画的物体不经过该Pass处理会不会减轻一些负担。但是在此之前，我应该学会如何使用Profile工具。 我来更新了，这个地方果然是我瞎说的。之前说的都划掉，先来说前半部分。 PrePass DDM_AllOpaque是什么？ 在这篇文章里有简短的提到[UE4]GPU Visualizer (GPU Profiling) Specification: PrePass DDM_… Sense Early rendering of depth(Z) from non-translucent meshed. Required by DBuffer decals. May be used by occlusion culling. Engine -&gt; Rendering -&gt; Optimizations -&gt; Early Z-pass. Cost affected by Triangle count of opaque objects. Depending on Early Z settings: Overdraw and complexity of Masked materials. 好，是这个东西，但是为什么要做这个处理不知道。再来看后半部分。 Forced by DBuffer是什么？ 英文意思很好理解，但是DBuffer是个什么我总是找不到。最后还是在上面（或者下面？）提到的那个神一样的SlideShare的介绍文章［CEDEC 2016］UE4を扱うアーティストがつまづき易いポイントはここだ。Epic Gamesが解説する注意点と回避法中找到了类似的定义： DBuffer DecalsまたはDeferred Decalとは，デカールをG-Bufferとは別の，「D-Buffer」と呼ばれるデカール専用特殊バッファに描画しておき，G-Bufferを用いてのライティングやシェーディングは，D-Bufferの内容も反映しながら行うという流れになる。デカールの描画結果がG-Bufferに統合されてしまうと，これが原因で前出のような問題が出てしまう。これを回避するために専用バッファを用意したというわけだ。 ただ，D-Bufferの利用に加えて，描画系も今までより処理のパスが増えるため，描画負荷が高くなるのがネックといったところ。 負荷は高くなるが正確なデカール表現が行えるDBuffer Decalsを導入すべきなのか。あるいは別の表現を選んでDBuffer Decalを避けるかは，よく検討して決めたほうがいいようだ。 具体的意思要专门展开关于DBuffer Decal的文章，总而言之就是当你决定使用DBuffer Decals的时候，并在（Project Setting/Rendering/Lighting中）开启了DBuffer Decals功能时候，那么上面的PrePass DDM_AllOpaque就会被强制执行。由于某种原因（文章中表示是Pre-Lighting阶段的描画需要）后续在别的文章中展开。 上面关于PrePass DDM_…的内容貌似也在UE4 Graphics Profiling: All Categories Guide (Rendering Passes)中有提及，这是是我之前就收藏过的，但是我并没有很仔细的看。。。 关于Deferred Decal的讨论，本来想要在其它章节写，但是暂时先整理一下, [UE4] Deferred Decal中提到的几个设定： 1234[SystemSettings]r.EarlyZPassMovable=1r.EarlyZPass=2r.DBuffer=1 我本来是想找是谁打开了DBuffer的设定，结果发现DBuffer是默认引擎开启的？！至于上面的问题，由于Dbuffer而强制计算的PrePass的操作，在我关掉DBuffer之后还是存在。 关于UE4中的Unreal Engine 4 Console Variables and Commands Name Help r.EarlyZPass Whether to use a depth only pass to initialize Z culling for the base pass. Cannot be changed at runtime.Note: also look at r.EarlyZPassMovable0: off1: only if not masked, and only if large on the screen2: all opaque (including masked)x: use built in heuristic (default is 3) r.EarlyZPassMovable Whether to render movable objects into the depth only pass. Movable objects are typically not good occluders so this defaults to off.Note: also look at r.EarlyZPass r.DBuffer Enables DBuffer decal material blend modes.DBuffer decals are rendered before the base pass, allowing them to affect static lighting and skylighting correctly.When enabled, a full prepass will be forced which adds CPU / GPU cost. Several texture lookups will be done in the base pass to fetch the decal properties, which adds pixel work.0: off1: on (default) 这里插播一条Decal performance question： This is from the docs: Performance The mesh complexity of the objects affected by the decal is not affecting the performance. The decal performance depends on the shader complexity and the shader box size on the screen. We can further improve the per decal performance. Ideally the bounding box of the decal is small to get better per pixel performance. This can be done manually. An automated method is possible but a good designer can also adjust the placement to improve performance further. Current limitations We currently only support deferred decals and they only work on static objects. Normal blending is currently not wrapping around the object. Mip map computation is not done yet so you might see 2x2 block artifacts on object borders. Streaming is not yet hooked up so make sure the texture is not streamed. Masking decals (not affecting other object) is not fully implemented. 1.4.3 Base Pass关于base pass的总结： UNREAL ART OPTIMIZATION - Base Pass Responsible for • Rendering final attributes of Opaque or Masked materials to the G-Buffer • Reading static lighting and saving it to G-Buffer • Applying DBuffer decals • Applying fog • Calculating final velocity (from packed 3D velocity) • In forward renderer: dynamic lighting Cost affected for • Rendering resolution • Shader complexity • Number of objects • Number of decals • Triangle count 在basepass阶段做了许多工作，其中Shader Complexity 是影响性能的一个很重要的因素。 1.4.3.1 Optimization如何优化这个问题首先要知道那个地方需要优化。 Shader Complexity: 在view-mode下可以查看shader的复杂度。 Stat: 在Material Editor里面有stat window查看pass的数量 Rendering Resolution: 可以查看和影响G-Buffer和其他贴图的质量。 stat RHI: 查看G-Buffer的内存占用 英文文章读起来不如中文的快，那么容易理解，但是有些话翻译成中文的话不知道为什么就变了味道。还是多读几遍人家的文章吧。 1.4.3.2 GPU VisualizerBasePass-Dynamic BasePass 0 = Opaque Meshes. BasePass 1 = Alpha Masked Opaque Meshes for Z-depth. BasePass Dynamic = Animated Vertices such as Skeletal, GeoCache(Alembic),etc. 在上面我只看到了Dynamic，而其他的是Static EBassPassDrawListType=0和Static EBasePassDrawListType=1意思是不是一样的我也不确定。 于是我查了查EBasePassDrawListType12345678910// Source UnrealEngine4源码：Runtime\Render\Private\BasePassRendering.cppEBasePassDrawListType DrawType = EBasePass_Default;// The definition of the typeenum EBasePassDrawListType&#123; EBasePass_Default = 0, EBasePass_Masked, EBasePass_MAX&#125; 看这个声明貌似上面的是对的。 还有一个我有点在意的是在VR的模式下会出现两种 View0 View1 VR眼镜不是有两个镜片么，就对应了两个摄像机。 所以Dynamic处理占用时间，是因为顶点动画比较多。 1.4.4 Pre-Lighting1.4.5 Lighting Lighting Passes Unwrapping UVs for Lightmaps UNREAL ENGINE - Unwrapping UVs for Lightmaps 1.4.5.1 GPU Visualizer这个是在ProfileGPU命令中出现的GPU Visualizer视图中的光照部分GPU消耗情况。 这里需要澄清的是，我按照渲染流程顺序题的标题，但是这个GPU Visualizer中的内容未必就是这个阶段做的事情，也许的确是这个阶段做的，但是我不知道。我只是看见名字相同，就整理到一起罢了。 层级关系： Lights DirectLighting NonShadowLightings IndirectLighting ShadowLights 大致上是这样的。 ShadowLights -&gt; … -&gt; ShadowProjectionOnOpaque这个项目下处理占用了好多的时间。这是在一个Stationary类型的Spot光源下，产生的大量的计算。关键字有PerObject和PerShadow。 一个Spot光源的出现在直射光的项目下面我就已经很吃惊了。顾名思义，这应该是阴影投影在不透明物体上的处理。当然直射光被设置为StationaryLight，需要动，所以每一帧更新都要重新计算阴影位置。 1.4.6 Reflection UNREAL ENGINE - Reflections Reflection Environment UNIREAL ENGINE - Reflection Environment Planar Reflection UNREAL ENGINE - Planar Reflection 1.4.7 Translucency按照处理顺序的话透明处理绝对不是那么靠前，之后应该调整一下顺序。 Separate Translucency把半透明的处理写到其他的Buffer中。 Project Settings &gt; Engine &gt; Rendering &gt; Translucency 我似乎有看过一点这方面的文章。 r.SeparateTranslucencyScreenPercentage XX: 指定该buffer的解像度 r.SeparateTranslucencyAutoDownsample: 自动降低解像度 1.4.8 PostProcess1.4.9 Shadow阴影这一部分的内容有很多，顺序也需要之后调整。 Fake Shadow多在角色模型中使用，比如人物脚下一团黑影代表着阴影那样。 Capsule Shadow SkeletalMesh: Capsule Direct(Indirect) Shadow 等等 1.5 Command Introduction记录一些常用的命令和里面的参数解读。 stat SceneRenderingRenderQueryResult关于这个参数，我也不太完全确定，在网上搜了也没有什么具体的答案。搜来搜去看到了OcclusionCulling感觉很像，但是按照这个方向去优化了一下试了试并不是很理想，貌似不是并不是一个概念，而且OcclusionCulling这个参数在另外一个命令，貌似是stat InitView中有貌似。 看到有人理解的是： RenderQueryResult是GPU完成整个一帧的渲染最后要做的事情。这个条目耗费时间很长说明GPU在这一帧内没有空闲，一直在工作。 感觉还说的过去。 2. Bluerint优化像Blueprint和C++是由CPU处理的Game阶段的处理。 Tick Event如果不需要的话，将Actor中的Tick Enable 设置为Off。亦或者调整Tick Interval的数值减少每一帧的调用。 SpawnSpawn处理不一定非要在一帧之内完成，可以分散到下下帧，由于间隔时间很短所以不会暴露什么。 但是分帧完成一个动作我还没见过这种操作，之后有时间找找看吧。 Nativizing Blueprint这个我也不太懂，真要用的时候再看吧。 Nativizing Blueprint 3. Landscape Optimization自作大型的场景的时候就会用到Landscape，但是问题是在Statistics中查看的结果，这个东西的无论是顶点数还是资源大小还是光照贴图的大小都是场景里耗费最高的。 关于Landscape的制作也不是随意的。 Introduction to Landscapes - #6 Unreal Engine 4 Level Design Tutorial Series 这个视频涉及到了如何合理的制作Landscape，还有其他的系列视频关于如何使用Landscape的工具的。 再就是官方文档了： Landscape Technical Guide 解释了各种参数的意义和推荐设置。 还有就是一些具体细节的调整： Navigation不用的话关掉 Collision不用的话关掉 LOD设置调低 4. HTC ViveVive的刷新率只有90Hz。 这是什么概念？每秒刷新90帧的能力，这跟游戏能够达到的帧率有很大不同。 这里就有疑问了，如果游戏的帧率高于显示器（VR）的刷新率会怎么样。 会造成撕裂(tearing)。 GPU活儿干多了，比如说应该把一帧的图像交给显示器，结果交付了一帧还多的数据（显示器来取数据的速度慢了一拍，本应该取走的一帧数据被显卡二次更新中途，）。产生了画面撕裂。 V-Sync被用来解决这个问题，垂直同步(Vertical Synchronization)通过建立一个不让在显示器刷新前将后备缓冲中的画面拷贝到显示缓冲中的规定来解决这个问(有条件的双倍缓冲)。如果FPS高于刷新率的话没有问题，后备缓冲的更新完成后，系统处于等待状态。当显示器刷新后，后备缓存拷入显示缓存，显卡则可以在后备缓存中描画新的画面。 游戏的帧率低于显示器（VR）的刷新率会怎样 如果打开了垂直同步，那么帧数直接减半。理论上讲，双缓冲的VSync，FPS将是一组不连续的整数，其等于刷新率/n。 这就是为什么我总是看Vive的帧率被锁在45帧的原因。 那么进入正题，UE4中的Smoothed Frame Rate Range有什么用。 Smoothed Frame Rate Range What exactly does “Smooth Frame Rate” do? With Frame Rate Smoothing, the application is determining what range is acceptable for frame rate wandering,so you can cap your frame rate to between Min and Max allowable frame rates.Since this is application based,it will make these changes before any hardware vsync changes. 举例来说，如果设置了Max60f，Min40f的话，当超过60帧会保持在60帧，当低于60帧而高于40帧的时候会保持帧数，但是低于40帧的时候就会降到30帧。 得益于现在的显卡很多具有自适应的垂直同步功能。 当然上面的内容只是我看文章得到的，并没有实际试验过。 然后吧，我读到了一篇文章。 Unreal* Engine 4 VR应用的CPU性能优化和差异化：第一部分 这里面提到了另外，因为VR是强制开启垂直同步的，所以只要一帧的渲染时间超过11.1ms，即使只超过0.1ms，也会导致一帧需要花两个完整的垂直同步周期完成，使得VR应用很容易因为场景稍微改变而出现性能大降的情形。这时候可以用“–emulatestereo”指令，同时把分辨率(resolution)设为2160x1200，屏幕百分比(screenpercentage)设为140，就可以在没有接VR头显及关闭垂直同步的情况下分析性能。 好的。 5. UE4中的一些概念Instanced Static Mesh关于这个东西，我纠结了好久。我是从foliage这个东西接触到它的。因为foliage刷出来的东西就是这个类型，生成一些随机的树啊花啊草啊就很方便，但是同时带来了性能消耗。 Foliage Instanced Meshes 为什么说带来了性能消耗呢，其实除了方便之外还有其他的好处。 减少了Draw Call 据我的理解：一个Actor的渲染对于CPU来说就得生成一个draw call，所以庞大的Actor的数量会拖CPU的后腿，减少draw call是优化性能的方向之一。 但是与此同时，一个draw call的数据不充分就导致GPU做额外的工作。也就是我遇见的InstancedStaticMesh这个东西产生的影响。 剔除有两种剔除方式： Frustum Culling Occlusion Culling 对于InstancedStaticMesh来说，第一种视椎体剔除是可以降看不见的部分剔除的。而第二种遮挡剔除，对于它来说就完全不起作用了，反而加重了GPU的负担。 我这么认为的证据是，在我分析一个用满是foliage制作的大场景中，我试着： ToggleDebugCamera: 命令行打开Debug摄像机，找到想要看的位置 FreezeRendering: 我忘记上面的命令是在哪里看到的了，在我暂停了渲染之后移动摄影机之后发现，在摄像机之外的内容被剔除掉但是在摄像机之内的所有InstancedStaticMash都还在。即下面的文章中提到的： Unreal* Engine 4 Optimization Tutorial, Part 2 One thing to know about instanced static meshes is that if any part of the mesh is rendered, the whole of the collection is rendered. This wastes potential throughput if any part is drawn off camera. It’s recommended to keep a single set of instanced meshes in a smaller area; for example, a pile of stone or trash bags, a stack of boxes, and distant modular buildings. 如果将Foliage的部分做的很大，那么所有的内容都会被渲染，哪怕是一小部分进到了摄像机的视野里。 还要一种方式是在Editor中，不是运行的状态，输入命令： r.VisualOccludedPrimitives 可以实时的查看被遮挡的物体的轮廓，上面的例子中，并看不见InstancedStaticMesh被遮挡的轮廓，因为他们是一体的，只要一部分出现在了视野里就会被渲染。 这里我突然就产生了对遮挡这个功能的疑惑，遮挡剔除这个部分对Instanced类型的物体做的不是很好，或者说是根本无能为力。按照我之前的理解，对看不见的片元，CPU和GPU不会去渲染才对，但是结果是，遇见这种类型的，都会被渲染，看不见的片元被渲染浪费了大量的GPU的能力和处理时间。GPU并没有认为这是一个物体，把出现在视野内的片元渲染，看不见的片元舍弃，而是全部听从了CPU的命令进行全部的渲染。 这个是我之前的理解。 但是对于视野内的物体，遮挡剔除就完美的降被遮挡的非Instanced物体给剔除掉了，这是事实。 遮挡剔除究竟是CPU的工作还是GPU的工作？ 关于OcclusionCulling的一些问题 UE4のOcclusion Cullingで良く聞かれる質問1: Occlusion Culling自身の処理負荷を減らしたい - だらけ者だらけ UE4のOcclusion Cullingで良く聞かれる質問2 Occlusion Cullingによりオブジェクトが1フレーム消失することがある - だらけ者だらけ 上面是关于遮挡剔除的一些问题的文章。重点是在第二篇。 这里提到了一些遮挡剔除的特性： 当摄像机的移动超过了一定的阈值OcclusionCulling就会Off CameraRotaionThreshold(Default 45.0) CameraTranslationThreshold(Default 1000) 另外，r.AllowOcclusionQueries 的ON/OFF 可以手动切换。 也可以通过扩大Occlusion的Bound来提前渲染object OCCLUSIN_SLOP r.ExpandAllOcclusionTestedBBoxedAmount 进入摄像机视野的一瞬间扩大OcclusionBound： r.ExpandNewlyOcclusionTestedBBoxsAmount(Default=0.0f) 简单的Profiling stat SceneRendering stat InitView Stat SceneUpdate 命令应该别的地方有讲过。但是这里我注意到的是在stat InitView命令里，有一个处理占了我很多时间 Render Query Result查了也不是很明白 RenderQuery Result is when the render thread stalls waiting for the GPU to finish the Occlusion Query, and return the results to the render thread, so that it knows what to render. At the same time, the game thread is stalled waiting for the render thread. This can be turned on or off with the console command r.AllowOcclusionQueries 0 - off 1 - on 看了也不太懂系列。 什么是Occlusion Query? GPU Gems- Chapter 29. Efficient Occlusion Culling 我下了PDF，可以看。 如何正确的使用 UE4 Optimization : Instancing 我觉得这个人的每个视频都值得我刷几遍。 Culling Distance Foliage Culling Distance Culling Distance Volumn UE4 Performance and Profiling实际上准确的标题名字应该是 UE4 Performance and Profiling | Unreal Dev Day Montreal 2017 | Unreal Engine 这其实是一个视频，我尝试的边看边做笔记，结果足足整理了三页，虽然是就是抄的英文，等之后有时间再记录下来吧。 现在要将这些内容整理一下，同时也温习一下视频的内容。 1.CPU/GPU Profiler我觉得有必要区分这两种Profiler，因为我最近接触的总是GPUProfiler，搞得我都不知道CPU要怎么Profiling了。 2.Profiling in a Build算是准备优化之前的准备工作吧。 Minimize the noise that can interface with profiling Turn off everything you are not using Turn off v-sync r.vsync 0 Turn off Framerate Smoothing Make a Test build Testing in a Development build inflates the Draw thread with noise 尽可能的关闭噪声（noise），前两项是必须要做的，但是第三项，我也不太清楚我理解对不对，开发的时候使用的是Development mode，所以尽可能的减少噪音就直接build工程（即Shipping mode）来optimization。 但是吧，还能不能用stat一类的命令来debug了我还真没试过。 3.Profiling from within the Editor可能就是上面的补充吧，其实我也是这么做的。在Editor中Optimization肯定会有noise。 前面也有提到具体怎么做(虽然是VR的，但是应该都一样)这里就简单抄一下。 Play in Standalone Make sure the Editor is set to NOT update i realtime Minimize the Editor VR &gt; Editor Preference &gt; Play &gt; should minimize Editor on VRPIE Make sure to turn off Frame Rate Smoothing Turn off VSync 4.General Process Identify the bottleneck Game Thread Render Thread CPU GPU Often jumps back and forth as you optimize Use r.ScreenPercentage 10 to quickly check if you are GPU bound 最后一条很有用。 Game Thread Code or Blueprint CPU Render Object count,draw calls,culling GPU Render Shaders, overdraw,light 5.Measuring in Milliseconds Use stat unit,not just stat fps Largest number shows you the likely bottleneck Milliseconds per frame Frame: total time to finish each frame Game: C++ or BP gameplay operations Draw: CPU render time GPU: GPU render time You can also use stat unitGraph,whitch shows a line graph playback. Mostly useful for spotting repeating hitches ScreenPercentage前面有提到使用这个命令来模拟VR的性能，还有就是使用这个命令来快速确认游戏的性能瓶颈是不是GPU。 Mostly useful to measure problems unrelated to Game Thread Use stat unit to show milliseconds Use r.ScreenPercentage 10 Or any number smaller than 100 Reduces number od pixels sent to the GPU If things get faster,you were GPU bound If they dont get faster,you were CPU bound 6.Show FlagsOne of the simplest ways to look for problems is to turn off partsof your scene. Helps know when to look into reducing LODs Less translucency Adjust lighting show assetType or showFlag.assetType 0-1 Staticmeshes Skeletalmeshes Particles Lighting Transluncency Reflectionenvironment Many more listed in docs 7.Diagnostic Tools-Realtime stats and view modesStat commands stat fps stat unit stat scenerendering stat gpu stat engine stat streaming stat emitters stat lighting Stat SceneRendering Only place to see draw calls Draw call is a single request to GPU to draw something Prime candidate for CPU slowdown on lower-end machines and also on mobile(less of a concern with Metal and Vulkan) Also good palce to see time for: Shadows Decals Post Processing Lighting 这个命令挺重要的。 Stat GPU Relatively new 4.15 Realtime readout from GPU Gives highlights, but not details Makes i very good to quickly target trouble spots Use the full GPU profiler if you want to target individual things Example:if you want to find specific lights that are casting shadows Optimization View ModesShader Complexity Show how much your shhaders are costing on the GPU Good way to see overdraw issues Overdraw is when a pixel must be drawn multiple times One of the most common content issues for optimization Graph at the bottom shows where the pixel and vertex shaders are in terms of performance If you see a lot of red and white,reconsider your approach 下面的话来自于官方文档里的 View Modes Shader Complixty Mode is used to visualize the number of shader instructions being used t calculate each pixel ofour scene.It i a generally a good indicating of how performance-friendly your scene will be. In general, it is used to test overall performance for your base scene, as well as to optimize particle effects, which tend to cause performance spikes with a large amount of overdraw for a short period of time. Quad Overdraw Helps show how you are using your polygon count on the screen Can help show where meshes should be LOD-ed down Too much green shows areas that should be simplified Anything more than green is starting to get costly, commonly translucency overdraw Very useful for MSAA on Forward Rendering,as the number of poly edges dramatically affects performance Quad Overdraw in-depth Your GPU breaks the view up into quads 2*2 groups of pixels This is more efficient than performing all operations on all pixels Very small, or very long, thin geometry wastes pixels Regular, large polygons make the best use of pixel quads, best use of GPU Model with regular trangles and LDD aggressively When you are looking at an opaque object on the deferred render, and you see a lot of green ,that means all 4 pixels of that quad had to be recalculated over and over. you should probably be using lower LODs. *毫无意义的分割线 Shader Complexity + Quad Overdraw Combines two powerful view modes into one USeful to get an idea of expensive shader anf geometry at a glance You will still need the individual settings to help diagnose specifics Liht Complexity Visualizes the cost of scene lighting As lights overlap, the colors shift from cool to warm to white Only shows cost of lighting, not shadowing Obviously, white is bad Great way to see where you should be lowing light radii By flipping this on and off, you can quickly see if the cost of any given light is “worth it” Lightmap Density Shows the density of texels for lightmap purposes Color shifts from cool to warm an density increases Most things can be blue Shadow maps don’t often need to be very high res Keep this as low as possible Cost adds up quickly Stationary Light Overlap Only a maxium of 4 stationary lights can affect any given object Beyound that,any other lights fall back to Movable(fully dynamic) This view mode helps track down where that might be happening Reminder to keep lighth radii as small as you can get it Do you have a stationary sun? Congratulations! That’s one of the four lights! LOD Coloration This mode shows the current mesh LODs in use by color coding them Very fast way to through ypur scene and verify that things are LODing when they should be Interestingly, mode clearly shows that the trees are not LODing at all in this project Was able to diagnose frame drop instantly using this mode 8.Profilling ToolsCPU Profiling Integrated tool to take apart a segment od your gameplay and see wat’s happening on each tick Very useful way to profile Blueprint performance Measures a segment of time Within that segment, can look a individual frames or averages Requires two special Stat Commands stat startfile &amp; stat stopfile Tese generate a log file between the interval of the commands Profiller allows deep analysis that log Step down into world tick and see individual Blueprint functions Can be used for CPU(Game and Draw) and GPU 捕获下来的日志可以在UE4的Session Frontend中展开分析。 GPU Profiling Three method to profile GPU functions stat GPU command in tne viewport Recorded file log in the Session Frontend GPU Profiler Can dump out to either the log or its own UI Great way to visualize the cost of: Base pass Lighting Shadows Post processing Tracking Slow Frame stat dumpHitches The command is used to dump any hitched over a given time in milliseconds out to the log Use command t.hitchThreshhold 0.xx to set value (0.05 is default) memReport -full Full breakdown of how memory is being used There’s a great blog post on how this works 虽然我还没有尝试过但是我可以使用上面的命令来找到游戏运行时候突然消耗非常高的那一帧究竟做了什么。 startFPSChart and stopFPSChart You can use the commands startFPSChart/span&gt; and stopFPSChart/span&gt; to create a diagram of framerates over time You can call these at start and end of a Level Sequence to automatically read out the frame rates along a given course, as defined by a cinematic 这里使用完这个命令之后会输出日志文件，需要使用别的软件把日志文件转化为图表。我用了GoogleDrive上的Excel做的。 9.Blueprint Optimizations - Or:Keeping the Kids from Eating the Crayons Blueprints make it easy for folks to assemble gamepaly logic Best results often come with engineer mentorship Common challenge Reliance on Tick functionlity Over-use of expensive functions(iterating on many objects) Abuse of hard reference Reliance on Ticking Blueprints Tick means should on every frame Blueprints should almost never need Tick Remember to uncheck Enable Actor Tick in Class Defaults! This is on by default so that the Tick event will work Alternatives to Tick Timers Timelines Manually enabling/disabling Tick on demand Make sure to adjust Tick Frequency 0.0= every frame Expensive Functionality Some functions are inherently expensive Get All Actors of Class Spawn Anything that needs to iterate over a large group of objects or properties Try not to use these if at all possiple If you are doing it to get a reference, consider having the referenced class pass itself up so the referencing object does not need to query Use TSets instead of arrays If you must use them, do so as seldom as possible Perferably only once,such as at Begin Play Heavy ConstructionScripts can murder spawn times. Consider placing in the level beforehand Hard References in Blueprint It is very easy for Blueprints to generate references to each other When you load a Blueprint, every other Blueprint it references must be loaded And the Blueprints referenced by those And so on,and so on.. This will not slow dowwn in-game performance, but it can eat away at memory and load times Some studios have thought the Editor just ran slow Turns out they were loading moost(ot all) of their game on startup Avoiding hard references: Avoiding casting operations unless you are certain you need them and know that it won’t cause issue For instance, if a Pickup class can only interact with the player, it might be fine to have it cast to Player But having the Player class references every other type of pickup and interactive object in the game, you will likely see problems Instead, use Blueprint Interfaces Try to get into the mentailty of not needin a very specific reference type Send your messages via an interface to a more generic class If they land on something inplementing the interface, grate! If not,no big deal Other Blueprint Optimizations Avoiding doing too much of any one thing(like with any scripting language) Too much functionality in a sngle class Break things up Use a class hierarchy But on that note, also avoid… Class hierarchies that are too deep Too many components within a class Too much high-end math Use the Math Expression node- it’s optimized to speed things up When all else fails for BP performance: GO NATIVE! At Epic, many of our Blueprints derive from generic C++ classes Yours should, too! Keep all the heavy functionality in code, leave the lighter stuff for Blueprint What Actors are Ticking? Did you lose track of what’s ticking? Use dumpticks Dumps a list of all ticking Actors out to the log, telling you how many tick functions are called Also shows how many enabled and disabled ticking Actors are in the scene 10.Draw Thread OptimizationCPU Rendering Considerations Bottlenecks at the Draw thread are often caused by doing too much: Too many draw calls Occlusion queries - see above Simulating too many particles Adding too many lights - often hits the GPU harder Generally the best way to speed up the Draw thread is to do less Find every way you can to put fewer things on the screen Generally this means either being very clever with content or using the integrated tools within UE4 start combining objects Actor Merge Tool Located under Window &gt; Developer Tools Combines selection of meshes in to new asset, replacing originals Can also combine Material via Simplygon Works best with many meshes having the same Material The Actor Merge tool works best with many meshed that have the same materials as possible.If you try to combine 20 meshed and each has its own Material every materail,you are not benefiting from the tool because every material is going to make a draw call anyway. Instanced Static Meshes Mechanism for generating multiple instances of a given mesh, with each considered part of the same mesh object. Can only be created throuth code or Blueprint at this time, often via the Construction Script Very easy to create a Blueprint set that helps generate this Placement Blueprint that is used to preview where mesh will be Radius based ISM Blueprint that gathers transforms from Preview BPs and populates the instances with itself. Be careful of Editor Utility class BPs-they’re Editor only! Also consider Hierarchical Instanced Static Meshes Handle their own occlusion/visibility Hierarchical LOD Hierarchical LODs allow multiple meshed to be combined and then reduced as a single mesh Will also combine textures into atlases. reducing overall Material demands Very useful for buildings and cities, groups of large meshes that need to be viewed at extreme distance Requires Simplygon implementation 11.GPU Optimizations - What to do about all those pixelsVertex Shader Optimizatin Be careful how much you make use of World Position Offset Often cheaper than the alternative methods of vertex animation Vertex color can eventually get costly On Paragon, we ended up stripping it and adding it back per instance Pixel Shader OptimizationsPixel Shader Don’ts Too much math Too many textures Too many procedural functions noise Too many Material layers Reliance on lfs(if statements) Both sides have to calculate Pixel Shader Dos Use textures for lookups instead of mesh Compress greyscale maps into single textures Minimize Layer usage Use Switch Parameters to turn off what you don’t need Material Instruction Counts Always pay attention to Material instruction counts Caution: the number indicated is not accurate until you click Apply Sometimes it’s best to re-compile the Material just to be safe Dealing with Overdraw Overdraw is one of the leading causes of GPU slogging Minimize the geometry area for overdraw Adding vertices is almost aways cheaper than relying in overdraw For example, on A Boy and His Kite,we ended up cutting the grass planes to almost exactly match the outline of the grass texture alpha Make use of Particle Cutout property This is found under the Cascade Required Moudle Feed it a texture, it automatically snips the spite Also works in subUVs,with a different cutout for every frame Managing Texture Resolution Author texture at whatever resolution you like,but keep in mind you may not always use full resolution Use the Texture Streaming view to see what level of mips you’re using for any given texture You can use the Statistics panel set to Texture Staticstics to see what levl of mips you are using at current levels Then use the Texture Editor to force mip bias Or better yet,reimport at lower resolution Lighting Considerations Dynamic lights are expensive (but somewhat cheaper in deferred) Small,unshadowed lights are the cheapest! You can have lots of these Minimize number of dynamic lights Minimize number of things dynamic lights have to effect Minimize dynamic light radii -tighter is better Cast shadows from as few dynamic lights as possible Dynamic shadow casting lights are the most expensive in UE Watch out for Stationary Light Overlap The fallback to dynamic lighting is extremely expensive Bake whenever you can Don’t assume you need dynamic lights Use Mesh Distance Field shadows at distance Watch out for dense shado cascades Many artifacts are cleaned up with Shadow Bias,but be gentle Keep Lightmap Res as low as you can Use the view mode,keep it blue as much as possible Avoid Light Function unless you really need them Consider IES profiles, but understand they also have a cost Lit translucency gets expensive, use with caution Cull shadows early (at close distance as possible) Cull dynamic lights as early as possible Spot lights are cheaper than Point lights Don’t be afraid to completely fake shadows We do this a lot, especially for VR Replication Optimization Common problems for networking: Doing too much Doing it too much Replicate as little as you can, as seldom as you can Use net.* commands to check what’s going on Must be run on the sever Use cheat net.* to run the command on the server from the client Use net.DumpRelevantActors to see what is currently replicating This command features some improvements as of 4.19 There are a lot of these net.* commands - check online for full list *毫无意义的分割线 Network Relevancy View Mode(4.19)… 我已经不知道他在讲什么了。。 12.Content StreamingTexture Streaming Textures streaming into and out of your scene at inopportune times cause visible pops As of 4.15 we have some tools for texture streaming diagnostics Texture streaming view mode Primitive Distance Accuracy Mesh Densities Accuracy Material Texture Scales Accuracy Required Texture Resolution stat streaming Primitive Distance Accuracy Visialization system for texture streaming Enable users to see what mips the system things they should be using, allowing for intelligent mip limits Red = 2 or more mips too few Orange = 1 mip too few White = the right degree of mips Cyan = 1 mip too many Green = 2 or more mips too many This setting can be adjusted using the StreamingDistanceMultiplier property Mesh UV Densities Accuracy This uses the density of a mesh’s UVs Visualizes how those UV densities are distributing to densities are contributing to streaming data Use the same paradigm as Primitive Distance Accuracy Red = 2 or more mips too few Orange = 1 mip too few White = the right degree of mips Cyan = 1 mip too many Green = 2 or more mips too many Fixing this requires the UVs on each mesh to be adjuested Material Texture Scales Accuracy This view mode samples all textures and feeds back the worst culprits for over-streaming and under-streaming Data is based on streaming affected by textures that have had their UVs scaled Helps diagnose streaming errors caused by UV scaling Required Texture Resolution This mode shows te required resolution for the given texture, indicating how many mips under or over it is Helps show the delta between the ideal resolution for the texture-what the GPU wants to show-and what is the GPU wants to show- and what is currenrly avaliable Red = 2 or more mips too few Orange = 1 mip too few White = the right degree of mips Cyan = 1 mip too many Green = 2 or more mips too many Stat Streaming Realtime metrics on texture streaming memory usage Breaks down texure streaming memory into 3 pools Texture Streaming Wanted Level Streaming Level streaming is an ideal way to control what content is in use in your game What you currently need is streamed in, what you don’t is streamed out Be careful how much you stream at once! You may need negate some of the benefit if you have over-referenced your content within code or Blueprint Bonus: Level Streaming as Collaboration Level Streaming is also the primary way for level artists to work together Different aspects are separated into different levels Not just different physical zonesWorld Composition Specialized streaming system designed for large worlds Will not work with old-school level streaming volimes But WILL work with Blueprint streaming Pro Tips: You can very easily make a Blueprint that functions just like a Level Streaming volume and does exactly the same thing, only better. UE4中的各种特性的优化Collision Optimization关于碰撞体的优化，第一印象都是去掉碰撞体，就像我之前操作的那样，去 ViewMode -&gt; Visbility Collision 中找到可以看见到的但是没有用到的碰撞体。 然而我偶然看见一个工具，叫CollisionAnalyzer，貌似很有用处。 Collision Analyzer位置位于 Window -&gt; Developer Tools -&gt; Collision Analyzer [UE4] コリジョンのデバッグ―Collision Analyzerを使おう！ 我突然意识到对于碰撞体的优化，应该是对CPU的处理的优化吧，毕竟碰撞处理的话都是逻辑一样的计算，但是我也不太确定啊。 Profile Data Visualizer这篇文章真的是太长了，尽管我有在排版上面下了功夫，但还是显得很乱。在渲染的各个阶段我应该也有写出这个GPUProfile的一些部分的内容，但是这个Profile中的一些内容我并不知道该怎么分类，于是我便想把这些内容总结到一起。首先是这个Profile的整体结构。 ProfileDataVisualizer(FRAME) Scene UpdateSceneObjectData UpdateGlobalDistanceVolume SlateUI FRAME Leaf Evnets 上面是这个视图的结构，因为是VR，有些内容会连续重复出现两次，应该就是里面的View0和View1的区别吧，两个镜片，即摄影机的话有些操作就必须做两次。有些内容我应该有在这篇文章的其他部分有展开就直接省略。 下面就对其中总是耗费很多时间的项目进行一些调查。 Update Global Distance Volume参考了这个问题Update Global Distance Field Volume taking longer than usual The global distance field is updated if any of the features using it are enabled: Distance field particle collision DistanceToNearestSurface material node Shadow casting movable skylight It also updates if Ray Traced Distance field shadows are enabled, but that’s a bug. You can workaround it by forcing global distance fields off with ‘r.AOGlobalDistanceField 0’. I’ll assume you are actually using a feature that requires it. The global distance field is a cache around the camera that has to update if the camera moves a lot, or if you have a moving static mesh which has bAffectDistanceFieldLighting enabled. The bigger the static mesh, the more expensive the update will be. Use ‘r.AOGlobalDistanceFieldLogModifiedPrimitives 1’ to track down which objects it is and disable bAffectDistanceFieldLighting on them. 在视图中仔细观察它的结构： UpdateGlobalDistanceFieldVolume CacheType MostlyStaic Clipmap0 CacheType MostlyStaic Clipmap1 CacheType MostlyStaic Clipmap2 CacheType MostlyStaic Clipmap3 CacheType Movable Clipmap0 GridCull TileCullAndComposite 128x128x128 CompositeHeightfelds CacheType Movable Clipmap1 CacheType Movable Clipmap2 CacheType Movable Clipmap3 在上面的回答的追加内容中： So I put a skylight back in, set it from moveable to stationary and it has solved the performance issue. Could this potentially be a but as you told me Shadow Casting Moving Skylights cause it to be updated, however it appears that any moving skylight causes the update to the global distance field. Thanks for the hint that lead to the answer :) 有提到SkyLight的光是Stationary类型的话，会缓解一下这个处理的时间。 于是我试着找会影响这个操作的几个概念都是什么意思，算是拓展。 Distance field particle collision参考了Using Particle Collision Mode for Distance Fields 感觉很有用。 RayTraced Distance Field Soft Shadows参考了RayTraced Distance Field Soft Shadows LOD Optimization (未整理) UE4 LODs for Optimization -Beginner- GPU Performance for Game Artists这是上面的视频里大力推荐的一篇文章。有时间我也得看一下，去理解一下整理一下。 GPU Performance for Game Artists Tech Art Aid videos on Youtube这个在油管上的视频我一直在看了，在这儿记录一下网址： UE4 Graphics Profiling Optimization需要之后整理关于Fortnite的一些优化方法，我觉得应该能学到一些什么： Optimizing UE4 for Fortnite: Battle Royale - Part 1 | GDC 2018 | Unreal Engine 几篇感觉很不错的关于优化的知乎文章: [GDC16] Optimizing the Graphics Pipeline with Compute 上面文章里的PDF我已经下载下来了。老地方找。 [Siggraph15] GPU-Driven Rendering Pipelines Performance and Profiling（UE4优化） 我感觉下面的知识我至少应该了解，这里贴上一些链接，以便自己找： Precomputed Visibility Volume Proxy Geometry Overview PRECOMPUTED VISIBILITY VOLUMES Software Occlusion Culling 这个带有中文的教程我觉得非常好有时间把这个整理成一个系列吧: Unreal Engine 4 优化教程第三部分 Unreal* Engine 4 VR应用的CPU性能优化和差异化：第一部分 英特尔软件工程师帮助实施 Unreal Engine* 4.19 优化 Epic Landscape Production 这篇我应该有记录但是为了以防万一再记录一次。 BasePass]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Performance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4光照学习调查笔记]]></title>
    <url>%2FUE4%E5%85%89%E7%85%A7%E5%AD%A6%E4%B9%A0%E8%B0%83%E6%9F%A5%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[提高VR帧数的工作，需要对各个流程有所了解。光照，渲染等等，这篇文章就是用来记录我在试图理解光照流程中遇到的知识点。 光照在UE4的官方文档中有很多说明，我只记录一些我可能会忘记的。 我在别的优化文章里面多少有提到关于光照的内容。 Light Mobility Light MobilityStationary lights这种光源是位置不变但是它的brightness和color等想要变化的那种光源。 However,it should be noted that runtime changes to brightness only affect the direct lighting.Indirect (bounced) lighting, since it is pre-calculated by lightmass, will not change. 这里有三个需要我理解的地方。 Direct Lighting ( √ ) Indirect (bounced) Light Lightmass 所有来自于Stationary Light的indirect lighting (应该是间接光照吧) 和间接阴影(indirect shadowing)会存储在Lightmap（光照贴图）中。直接光照阴影会存储在阴影贴图中(Shadowmap)。 All of the indirect lighting and shadowing from Stationary Lights is stored within the lightmap.Direct shadows are stored within the Shadowmap.These lights make use of Distance Field Shadows, meaning that their shadows can remain crisp even fairly low Lightmap Resolution on lit objects. 当使用了低质量lightmap解决方案的时候，因为Stationary lights直射光产生的直接阴影是存储在Shadowmap中的，所以仍然还可以产生比较清晰的阴影。 这里需要深入理解的是： Shadowmap Lightmap Direct Lighting The direct lighting of stationary lights is rendered dynamically using deferred shading.This allows the brightness and color tobe changeable at runtime, along with a light function or IES profile. 应该就是直接光源，stationary light的直接光照是使用延迟渲染。 这里我应该理解的是 Deferred shading(该回忆了) IES profile Direct Shadowing Realtime shadowing of light sources has a major performance cost. A fully dynamic light with shadows will often cost twenty times(20x) as much to render than a dynamic light without shadows. For this reason, stationary light have the ability to have static shadowing on static object, but with some limitations. 关于阴影，光照的实时阴影是影响性能的一个主要参数。stationary light能产生静态阴影，在静态物体上。但是有限制。 Static ShadowingOn Opaque Lightmass generate distance field shadow maps for stationary lights on static objects during the lighting rebuild. Distance field shadow maps provide very accurate shadow transition even at low resolution, and with very little runtime cost. Like lightmaps, distance field shadow maps require uniquely unwrapped UVs on all StaticMeshes using static lighting. 当stationary light对不透明静态物体生成阴影的时候，在lighting rebuild阶段生成distance field shadow maps 。 Lighting must be built to display distance field shadows, otherwise whole scene dynamic shadows will be used for previewing. 这里我并没有找到有能够显示distance field shadow的编译选项。 Only 4 or fewer overlaping stationary lights can have static shadowing, because the lights must be assigned to different channels of a shadowmap texture. This is a graph coloring problem, so there are often fewer than 4 overlapping allowed due to topology. Shadowing cannot affect the overlap test, so the sunlight typically requires a channel from the entire level it is in, even the underground areas.这一句话应该是说阴影不会影响overlap测试，所以即使是在地下世界里的场景，有sunlight的情况下都要给sunlight预留一个channel。 就像上面所说的，尽量避免stationary lighting的overlapping。在StationaryLightOverlap视图中，可以查看stationary lighting的重合程度。如果光源的图标变成了红色的X就表明它不能容纳更多的channel了。 On Translucency Translucency also receives shadowing very cheaply with Stationary lights - Lightmass precomputes a shadow depth map from static geometry which is applied to transluency at runtime. This form of shadowing is fairly coarse only captures shadowing on the scale of metres. 不透明的物体也可以接收来自Stationary Light的光照阴影，代价也不是很高。但是这种阴影很粗糙。 Shadow depth map The resolution of the static shadow depth map is controlled by StaticShadowDepthMapTransitionSampleDistanceX and StaticShadowDepthMapTransitionSampleDistanceY in BaseLightmass.ini, with a default setting of 100 meaning one texel every meter. Dynamic Shadowing Dynamic objects(like StaticMeshComponents and SkeletalMeshComponement with Mobility set to Movable) must integrate into the static shadowing of the world from distance field shadowmaps. This is accomplished with Per Object shadows. Each movable object creates two dynamic shadows from a stationary light : a shadow to handle the static world casting onto the object, and a shadow to handle the object casting onto the world. 动态物体（movable）必须整合到来自distance field shadowmap的世界静态阴影(The static shadowing of the world) 中去,这个经由Per Object shadows来完成(每一个物体的阴影计算？)。每一个标记为movable的物体会创建两个来自StationaryLight的动态阴影，一个用来处理静态世界在该物体上的阴影，另外一个用来处理该物体在世界里面的阴影。 这意味着当动态物体的数量很多的时候，使用动态光是更好的选择。 Per Object shadows used by movable components apply a shadowmap to the object’s bounds, therefore the bounds must be accurate. For Skeletal meshes this means they should have a physics assets. For partial systems, any fixed bounding box must be large enough to contain all particles. Direction light dynamic shadowing Directiong Stationary Lights比较特殊，因为它通过Cascaded Shadow Maps(级联阴影贴图)和static shadowing支持整个场景的阴影的生成。当场景中存在许多animating foliage会很有用；当在player的周围存在许多动态的阴影，但是并不想花费太大的代价去使用许多cascades覆盖很大的视野范围。动态阴影将会随着距离的提升一点点渐隐到静态阴影中，这样的过度通常难以区分。 可以改变 DirectionalLightStationary 的Dynamic Shadow Distance StationaryLight 的范围来控制过渡的距离范围。 这里我不理解的概念： Cascaded Shadow Maps Animating foliage Movable components will still create PerObjects shadows even when using Cascaded Shadow Maps on a directional light.This behavior is useful with small Dynamic Shadow Distance, but incurs unnecessary cost with larger distance. To disable PerObject shadows and save performance, disable Use Inset Shadows For Movable Objects on the light. Indirect Lighting和静态光照一样，StationaryLight将间接光照存储在光照贴图内（lightmap）。间接光照不能像直接光照那样运行中改变光照的brightness和color。这意味着即使在light build中将Visible取消，间接光照还是会被存储在光照贴图当中。 IndirectLightingIntensity的光照属性可以被用来控制大小和开关，在光照的编译阶段。 However there is a post process volumn setting called IndirectLightingIntensity which lets you scale the contribution of the lightmap for all light, which can be changed at runtime from a blueprint. 上面的很好理解就不解释了。 Use Area Shadows for Stationary LightsDirectional Light可以打开这个属性，但是要保证这个直射光照的Mobility是Stationary。 When the Use Area Shadows for Stationary Lights option is enabled,the Stationary Light will use area shadows for the precomputed shadow maps. Area shadows are shadows that get softer the further they are from caster. Note that Area Shadows will only work on Stationary Lights and you might have to increase some objects lightmap resolution to get the same shadow quality and sharpness. 总的来说就是这个属性会让阴影变得比较柔软，更贴近现实一些。 Movable Lights动态光照不会把数据烘焙到光照贴图里，并且没有任何间接关照（currently）。 阴影阴影是动态光照里最昂贵的花销之一，光照内的mesh的图元数量和三角形数量是影响性能的指标。 Movable lights setup to cast shadows use whole scene dynamic shadows, which have a significant performance cost.The performance cost comes primarily from the number meshes affected by the light,and the triangle count of those meshes. Shadow Map Caching 选中所有产生动态阴影的动态光 确保Mobility是Movable，并且Cast Shadows属性选中 Backtick( ` ) 打开console输入 Stat Shadowrendering 查看实时动态阴影的花销 再次打开console，键入 Sr.Shadow.CacheWholeSceneShadow 0关掉dynamic shadow caching 注意CallCount 和 InclusiveAug 再打开console，键入 r.Shadow.CacheWholeSceneShadow 1 打开dynamic shadow caching you can control the maximum amount memory used by the Shadow Map Cache using r.Shadow.WholeScenceShadowCacheMb Limitations关于使用限制： By default,caching can only happen when an object meets the following requirements: Primitives have their mobility Mobility set Static or Stationary. Materials used in the level do not use World Position Offset. Light need to be either a Point or Spot light, have its Mobility set to Movable, and have Shadow Casting enabled. Lights have to remain at one location. Material that use animated Tessellation or Pixel Depth Offset can cause artifacts as their shadow depths are cached. 最后一条不太理解，需要继续调查： Tessellation Pixel Depth Offset Actor Mobility这里插一条概念，关于Actor的Mobility属性。 Actor Mobility 文档上有写，所以我就少写一点。 当我知道了StationaryLight的属性的影响的时候，主要会让我产生混乱的是当StaticMesh的mobility属性是Stationary的话怎么办 For Static Mesh Actors,this means that they can be changed but not moved.They do not contribute to pre-calculated lightmaps using Lightmass and are lit like Movable Actor when lit by a Static or Stationary Light.However,when lit by a Movable Light, they will use a Cached Shadow Map to reuse for the next frame when the lighting is not moving. 大体上就是StationaryLight下的StationaryMobility的StaticMeshActor,没什么太大的意义。 Lightmass Lightmass Global Illumination Lightmass生成像区域阴影，漫反射交互等等的复杂光照交互的光照贴图。通常被用来预计算一部分的静态光照和StationaryLight的光照。 Feature for Static and Stationary lightsDiffuse InterreflectionDiffuse interreflection is by far the most visually important global illumination lighting effect.Light bounces by default with Lightmass,and the BaseColor term of your material controls how much light(and what color)bounces in all directions. This effect is sometimes called Color Bleeding.Diffse Interreflection is incoming light reflecting equally in all directions,which means that it is not affected by the viewing direction or position. Indirect Lighting CacheLightmass为静态物体生成间接光照的光照贴图，动态物体也同样需要，解决方案是使用Indirect Lighting Cache。但是从UE4 4.18版本之后默认实现就被Volumetric Lightmap 取代了。 Volumetic Lightmaps Volumetric Lightmaps 在光照的编译阶段所有的点预计算的光照会被存储在Volumetric Lightmap中，之后在实时运算中被用来dynamic objects的间接光照插值运算。 工作方式： 在光照的编译阶段，Lightmass会在整个场景中放置lighting samples 并且计算它们的间接光照。 当开始渲染动态物体的时候，Volumetric Lightmap会以插值的方式为每一个被渲染的像素提供预先计算好的间接光照。 if no built lighting is available(meaning the object is new or has moved too much), lighting is interpolated to each pixel from the Vloumetric Lightmap for Static objects until lighting is rebuild. 上面的那句话我不太理解就直接抄了英文。 Enabling Volumetric Lightmap Visualization在view视图中找到： Show &gt; Visualize &gt; Volumetric Lightmap 可以查看，貌似必须是编译好光照之后才能看的见。 有着越远离几何体密度越低的特点。 这里提到了Lightmass Important Volume这个蛮重要的东西。 Stationary Light的阴影 Stationary Light の影について 参照上面的文章进行的一些总结。 Static Mesh Shadow Stationary Light的阴影贴图是由各自的StaticMesh保持的 这个可以在Stat的NumSM/TextureSM条目里查看 ULightComponent::ReassignStationaryLightChannels Stationary Light的ShadowMap是经由G-Buffer之后的光照计算阶段生成的 再稍微具体一点来说就是：StaticMesh在LightBuilt之后，有了StationaryLight阴影贴图，然后在BasePass阶段，把这个ShadowMaps的值拷贝到G-Buffer中的一个PrecomputedShadowFactors的float4类型的值中去，在写进G-Buffer中之后，在光照计算阶段，光照通过读取自己持有的Index对应的PrecomputedShadowFactor的值来计算像素的阴影。 Movable Object动态物体在StationaryLight的阴影又是什么样子的？ 先是以点光源为例，DirectionalLight使用的是CascadeShadow，有一些不同。 StationaryLight为每一个MovableMesh计算阴影贴图，并把ShadowMap的数据存储到一张巨大的阴影贴图中。 之后逐个对其所有的Mesh的渲染进行阴影的计算。（实际的渲染阶段的阴影计算？） 总结为： Movable Mesh的Stationary Light阴影的计算Cost = 光照范围内的Movable Mesh数 * 每一个物体阴影的生成和渲染cost（PerObject？之前貌似在哪里见过） Stationary Light的阴影，每一个Movable Mesh都会被计算。 像是废话。 Stationary Light的阴影，对于Movable Mesh而言，它会一个一个的进行阴影贴图的计算，然后一个一个的进行渲染。 用实际的数据来展现就是： 在ProfileGPU命令打开的Profiler中的这一项： ShadowDepthFromOpaqueProjected 可以看到Movable Mesh在Stationary Light下的每一个阴影贴图计算的时间，一般都是0.01我感觉。 终于知道这个是什么意思了。 还有这一项： ShadowProjectionOnOpaque 可以看到对于每一个Movable Mesh，Stationary Light的实际的阴影计算所消耗的时间。 （我觉得我应该去复习一下渲染流程了。） 这就会在StationaryLight的光照范围内加入大量的动态物体会使得处理时间变长的原因。 而另一方面，Movable Light对于Movable Mesh阴影的处理不是以每一个动态物体为单位而是以光照为单位，对这个光照范围内的所有物体打包计算。 因此当Movable物体很多的时候，动态光照的方案要优于StationaryLight方案。 Directional Light的阴影上面的都是对点光源和聚光灯的光源来说的不包含直射光。 Directional Light基本上是用Cascade Shadow Map进行的。级联阴影贴图。 在ProfileGPU中的具体项目是： ShadowDepthFromOpaqueProjected WholeScene split1 WholeScene split2 WholeScene split3 ..(maybe) 有一个让处在Cascade Shadow以外的Object以点光源一样进行阴影计算的方式： Cascade Shadow Map &gt; Inset Shadow For Movable Objects 这意思是CascadeShadow是有范围的？ 通过调整 Dynamic Shadow Distance Stationary Light 的距离可以让物体不使用Cascade Shadow。 总结： Static Mesh：Stationary Light事先计算阴影，由各静态mesh保持，当开始渲染的时候直接读取值处理负荷很小。 Movable Mesh：Stationary Light对每一个动态Mesh计算阴影，当动态物体很多的时候，优先选择Movable Light。 Lighting needs to be rebuilt光照烘焙，一般的情况下这个提示是要烘焙光照，但是我遇到了烘焙光照之后还有这个提示的问题。是在我删除掉场景里的所有FoliageStaticMesh之后。 DumpUnbuildLightInteractions在Command Line中输入上述的命令，可以在OutputMessage里面输出需要烘焙的对象信息。 Light Map光照贴图这个部分能说的东西实在时候太多了，要理解的东西也非常多，LightMap具体是个什么东西，用来存储什么数据？搜LightMap的时候又会出现其他的概念，LightMass又是什么？ LightMass在上面也有提到一点。 Unwrapping UVs for Lightmaps当试着搜LightMap的时候，就会出现这篇官方文档-Unwrapping UVs for Lightmaps Lightmass这个有我下载的PDF，有时间总结一下。 Lightmassの仕組み ~Lightmap編~ (Epic Games Japan- 篠山範明) 这篇文章提到的： LightMap和ShadowMap是以Actor为单位各自保持的。 可以在Statistics中的StaticMeshLighting info中看到Actor的各自持有的TextureLM和TextureSM。 LightingTroubleshootingGuide LightTroubleshootingGuide]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的各种文件操作]]></title>
    <url>%2FC%2B%2B%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[说到LOG的制作那么文件读写就肯定有大费周折了，当然不是我大费周折，我用的人家现成的东西。但是读起来其实挺费劲的，谁让我这么菜呢。 打开文件_sopen_s, _wsopen_s打开文件以供共享。 参考官方文档： _sopen_s,_wsopen_s 操作文件_lseek将文件指针移动到指定位置 官方文档： _lseek, _lseeki64 _write将数据写入文件 官方文档： _write 关闭文件_close关闭文件。 关于这些函数的用法在我最近读的plog里面都有，有空再仔细整理一下吧。 还有一些其他的用法调查一下就知道了，想了想花时间写一下也好但是收益不大，暂时先记下吧。 errno]]></content>
      <categories>
        <category>C++</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么要用size_t]]></title>
    <url>%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8size-t%2F</url>
    <content type="text"><![CDATA[总的来说就是为了提高代码的可移植性，有效性或者可读性。 Why size_t matters 之后整理一下这篇文章的内容。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[new与malloc的区别]]></title>
    <url>%2Fnew%E4%B8%8Emalloc%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[new/delete与malloc/free显而易见的区别是，前者会调用对象的构造/析构函数，而后者不会。 再仔细说明就是new的操作是新建对象 ，而malloc只是分配一块内存而已。 在Stack Overflow上有更为详尽的说明，有时间的话好好整理一下。 What is the difference between new/delete and malloc/free?]]></content>
      <categories>
        <category>C++</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的运算符重载]]></title>
    <url>%2FC%2B%2B%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[运算符重载(operator overloading)只是一种”语法上的方便“（syntactic sugar).也就是说它只是另一种函数调用的方式。 运算符重载有成员与算符和非成员运算符之分，那么这个之间有什么区别呢，应该选择哪一种呢？ 总的来说，如果没有什么差异，它们应该是成员运算符。这样做强调了运算符和类的结合。当左操作数是当前类的对象时，运算符会工作的很好。 但有的时候左侧操作数是别的类对象。这种情况通常出现在输入输出流重载operator&lt;&lt;和&gt;&gt; 时。因为输入输出流是一个基本C++库。 这里就说到了关键了。为了应付各种数据类型的输出，输入输出流的重载就很重要了。 1// 代码之后贴 这里我先暂停一下，说一说为什么要认识运算符重载这个问题。 举例来说，cout这个类是我学C++最早接触的对象了之一了，但是却很不是理解。其实即就是cout对&lt;&lt;运算符进行了重载。 我自己创建了一个Record类，希望这个类能对接在&lt;&lt;后面的数据进行一些操作，比如说接收数据什么的。12Record &lt;&lt; 2;Record &lt;&lt; "str string"; 想这样把后面的数据接收保存在类内变量中。就这样我遇见了下面的代码:12345678// 在Record类内template&lt;typename T&gt;Record&amp; operator&lt;&lt;(const T&amp; data)&#123; m_message &lt;&lt; data; return *this;&#125; 代表着混沌势力的模板登场了（对我来说)。这里就涉及到了函数模板的问题。我看到上面的代码的时候第一反应是，这段代码能直接用？ 答案是肯定的，像类模板的使用那样，指定明确的模板参数类型来特化函数模板使用是可行的，也就是我觉得应该这样做的，但是让编译器从函数的参数中推断出它们的类型将会更方便。 后面的内容就更多了，在别的模板章节中展开更好。 回到上面的代码，m_message &lt;&lt; data 的m_message是什么类型合适呢？是ostringstream。是C++标准库的东西，这样就省得自己一个一个重载数据类型了。方法是个好方法，但是最后我没用上。因为要处理宽字符的问题，涉及到宽窄字符互相转换的问题，试来试去总是出问题，我就Pass掉了，全部交给UE4里的FString类型和TEXT（）来处理了。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++-制作一个静态的单一实例]]></title>
    <url>%2FC%2B%2B-%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E7%9A%84%E5%8D%95%E4%B8%80%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[制作单一实例，就会想到Singleton，单例模式。在C++里面如何制作一个唯一的一个实例，我只是有一个想法，然后付诸实践。也许这个想法或许是错的。但是重要的是我将这个想法付诸实践的过程，这个过程中我明白了许多知识点，只是不想忘记而已。 指定需要单例化的类首先要选一个适合的类进行单一实例化。举例来说我现在正在制作一个日志系统，故而我希望有一个唯一的实例Logger来管理关于日志的一切。所以我声明了以下： 12345678910111213// Logger.hclass Logger&#123; Logger(); ~Logger();&#125;// Logger.cpp#include "Logger.h"Logger::Logger()&#123;&#125;Logger::~Logger()&#123;&#125; 像这样子。 制作一个单例模板关于这个单例模板其实我也不太清楚具体是为什么而制作的，只是我在学习plog这个日志库的时候看到就学了。首先它是一个模板，怎么用为什么要这么用，需要我理解模板的使用。 12345678910111213141516171819202122232425262728293031template&lt;class T&gt;class Singleton :NonCopyable&#123;public: Singleton() &#123; if(m_instance == NULL) &#123; m_instance = static_cast&lt;T*&gt;(this); &#125; &#125; ~Singleton() &#123; if(m_instance != NULL) &#123; m_instance = 0; &#125; &#125; static T* getInstance() &#123; return m_instance; &#125;private: static T* m_instance;&#125;template&lt;class T&gt;T* Singleton&lt;T&gt;::m_instance = NULL; 先把出现的NonCopyable类的出现放在一边，讨论一下这个模板。 这个模板有一个私有静态属性，类型为T，而且在构造函数里面进行了像下类型转换，使用`static_cast，这个算是骚操作么，我也不太清楚。还有注意取得这个属性的指针函数是静态的，也就是有准备把这个单一实例声明为静态的。 总结一句话来说就是我们得到使用了这个模板并实例化成功的静态实例的指针引用。 引用这里让我有些不舒服的是引用这个词，按照我所理解的，引用和指针并不是一样的： 引用（reference）（&amp;）就像能自动的被编译器间接引用的常量型指针。 关于这一部分我应该是需要用大量的时间去理解的。在C++编程思想第一卷第十一章的-引用和拷贝构造函数里面有较为详细的说明。之后也会有提到。 静态类成员关于静态类成员，Static Members of a C++ Class 里面的说明应该很详细了。 要点在于: 静态类成员只有一份拷贝，无论类被实例化了多少次。 静态类函数只能调用静态类成员。 可以使用类公开的静态成员和静态函数，甚至类没有被实例化。 类静态成员没有this指针，可以用&lt;类名&gt;::&lt;静态成员&gt;来获取。 静态类成员必须在类外初始化 这个是我制作的单例模式的关键理解部分。 关于NonCopyable类这个类可谓是突然出现在我的面前，一查却发现大有来历。就是一个防止类被复制的类。123456789class NonCopyable&#123;protected: NonCopyable()&#123;&#125;private: NonCopyable(const NonCopyable&amp;); NonCopyable&amp; operator=(const NonCopyable&amp;);&#125; 这个地方涉及了许多拷贝构造函数相关的东西，C++编程思想第一卷第十一章-引用和拷贝构造函数的内容，之后需要好好理解。 静态实例实装经过上面的洗礼，我试着写成下面这样：123456789101112class Logger : public Singleton&lt;Logger&gt;&#123;private: static Logger logger;private: Logger(); Logger(const Logger&amp;); ~Logger();&#125;Logger Logger::logger = Logger(); 我在类里面声明了一个自身类的静态实例。加上继承来的静态方法可以取到这个静态实例。然后定义了它。 这里有一个问题就是，当我在类外面定义logger的时候，Logger Logger::logger = Logger();,编译报错了，因为当时我没有加上Logger(const Logger&amp;);这句话。 这句话是什么呢，貌似就是所谓的拷贝构造函数。并且被设置成了私有的。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++编程思想-第16章-模板介绍]]></title>
    <url>%2FC%2B%2B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC16%E7%AB%A0-%E6%A8%A1%E6%9D%BF%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[记下关于模板的知识与理解。 继承和组合提供了重用对象代码的方法，而C++的模板特征提供了重用源代码的方法。 截止到最近为止我对模板的理解也就之停留在表面:作为一种类型的容器。比如说实现一个可以存储任类型的Stack，有一些共同的操作，当你想使用的时候放入具体的类型进行实例化(instanation)。容器，貌似很好理解的样子。 这也是文章开头所提的到的部分，最最简单且易为理解的部分。 小tips： staic int a[100];这样的写法，编译器会将这个static数组初始化为0. 模板介绍(第十六章)16.3模板语法template这个关键字会告诉编译器，随后的类定义将操作一个或更多未指明的类型。当由这个模板产生实际类代码的时，必须指定这些类型以使编译器能够替换他们。123456789101112131415161718192021using namespace std;template&lt;class T&gt;class Array&#123; enum &#123; size = 100; &#125;; T A[size];public: T&amp; operator[]（int index)&#123; require（index &gt;= 0 &amp;&amp; index &lt; size, "Index out of range"); return A[index]; &#125;&#125;int main()&#123; Array&lt;int&gt; ia; Array&lt;float&gt; fa; // ......&#125; 这时，编译器两次扩展了Array模板【这被称为实例化(instantiation)】，创建两个新的生成类（generated class），可以把它们看做Arrray_int和Array_float（不同的编译器对名称有不同的修饰方法）。这些类就像是手工创建的一样，只是这里是当定义了对象ia和fa后由编译器来创建这些类。我们还会注意到，编译器避免了或者连接器合并了类的重复定义。 16.3.1非内联函数定义希望有非内联函数定义的时候，这时编译器需要在成员函数定义之前看到template声明。 1234567891011121314template&lt;class T&gt;class Array &#123; enum &#123; size = 100; &#125; T A[size];public： T &amp;operator(int index);&#125;;template&lt;class T&gt;T&amp; Array&lt;T&gt; ::operator[](int index)&#123; require（index &gt;=0 &amp;&amp; index &lt; size), "Index out of range"; return A[index];&#125; 关于内联函数和非内联函数的定义在别的章节会有提到。在此不赘述。 在引用模板的类名的地方，必须伴有该模板的参数列表，这样在按照模板生成实例的时候，因为模板参数中的参数修饰类名，以便为每一个模板实例产生唯一的类名标识符。 因此模板的参数列表在引用模板类名的时候，也要有一席之地。 模板的非内联函数定义之前一定要加上template声明。 16.3.1.1头文件 即使是在创建非内联函数定义时，我们还是把模板的所有声明和定义都放入一个头文件中。这似乎违背了通常的头文件规则：“不要放置分配存储空间的任何东西”（这条规则是为了防止在连接期间的多重定义错误），但模板定义很特殊。在template&lt;…&gt; 之后的任何东西都意味着编译器在当时不为他分配存储空间，而是一直处于等待状态直到被一个模板示例告知。在编译器和连接器中有机制能去掉统一模板的多重定义。所以为了使用方便，几乎总是在头文件中防止全部的模板声明和定义。 16.3.3模板中的常量 模板参数并不局限于类定义的类型，可以使用编译器内置类型。这些参数值在编译期间变成模板的特定示例的常量。我们甚至可以对这些参数使用默认值。 12345678910111213141516171819202122232425262728293031323334353637383940414243template&lt;class T, int size = 100&gt;class Array&#123; T array[size];public： T&amp; operator[](int index)&#123; require(index &gt;=0 &amp;&amp; index &lt; size, "Index out of rande"); return array[index]; &#125; int length() const &#123; return size; &#125;&#125;;class Number &#123; float f;public: Number(float ff = 0.0f) : f（ff) &#123;&#125; Number&amp; operator=（const Number&amp; n)&#123; f = n.f; return *this; &#125; operator float() const &#123; return f; &#125; // ???? friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Number&amp; x)&#123; return os &lt;&lt; x.f; &#125;&#125;;template&lt;class T, int size = 20&gt;class Holder&#123; Array&lt;T, size&gt;* np;public： Holder() : np(0) &#123;&#125; T&amp; operator[](int i) &#123; require(0 &lt;=i &amp;&amp; i &lt; size); if(!np) np = new Array&lt;T, size&gt;; return np-&gt;operator[](i）； &#125; intlength() const&#123; returnsize； &#125; ~Holder() &#123;delete np;&#125;&#125;;int main()&#123; Holder&lt;Number&gt; h; // ......&#125; 上面的例子中的size的值没有房放在类中，但是对他的使用就如同是成员函数中的数据成员。 我记录下来上面这段代码的原因还有一个就是懒惰初始化(lazy initialization).上面的Holder中有一个指向Array的指针，而不是指向类型Array的嵌入对象。该指针在构造函数中不被初始化，而是被推迟到了第一次访问的时候。还有等等的稀有的用法。 这个章节还有许多其他内容，但是貌似跟我现在急需要理解的内容相差甚远，暂时保留。 第二卷第五章 深入理解模板关于模板的使用问题，在真正的使用模板之前一定要先让编译器看到模板的声明和定义，比如说在同一个文件里写一个类继承一个模板的时候，模板的声明和定义不能在类的下方，应该先写模板再用。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的强制类型转换-cast]]></title>
    <url>%2FC%2B%2B%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-cast%2F</url>
    <content type="text"><![CDATA[实在是遇见太多次了，遇见了还看不懂，再不整理就过分了。关于C++中的强制类型转换问题。这次的主角是:stati_cast,dynamic_cast,const_cast,reinterpret_cast。 static_cast提笔要写，先看别人的总结 When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used? 这里我遇见的情况就是static_cast的重要的用法。继承类型的向下类型转换。下面来看看我遇见的神仙代码：123456789101112131415161718192021222324252627template&lt;class T&gt;class Singleton : NonCopyable&#123;public: Singleton() &#123; assert(!m_instance); m_instance = static_cast&lt;T*&gt;(this); &#125; ~Singleton() &#123; assert(m_instance); m_instance = 0; &#125; static T* getInstance() &#123; return m_instance; &#125;private: static T* m_instance;&#125;;template&lt;class T&gt;T* Singleton&lt;T&gt;::m_instance = NULL; 一个单例模板类，读代码的时候，按照这个模板被实例化的是他的子类，顺便这个子类所具有的instance的引用就变成它自己了。我什么时候也能写出这么优秀的代码。 还有其他的强制类型转换，遇见的时候具体分析吧。 const_cast在做各种数据类型匹配的时候，遇到了这样的问题：123// UE4 C++FString text = "111";TCHAR* t_text = *text; 上面是想把FString类型转化为TCHAR*类型的数据。 但是上面的会报错，原因是无法将const THCAR*转化为TCHAR*。那就直接加上关键字const就解决了。但是问题是这个t_text是我设置的即将要传入另外一个函数的参数，它要是设置为常量类型的话就没法传参了。 把常量指针变成普通的指针，就是我接触到const_cast的起因。但是关于它的使用，可不是一句话就能总结的。 const_cast实现的原因在于C++对于指针的转换是任意的，它不会检查类型，任何指针之间都可以进行互相转换。 去const限定12const TCHAR* t_text = "1234";TCHAR* text = const_cast&lt;TCHAR*&gt;(t_text); 将常量指针转化为了正常指针，但是正常情况下不会做这种弱智操作。正常声明就行了，但是有的时候要传参的情况传的不是常量怎么办，那只好强制转换了。 去const限定的操作绝对不是为了修改它的内容，既然声明了常量还要修改那为什么还要声明为常量。既然声明了常量就要贯彻到底。绝对不对const数据进行重新赋值。 根据别人的文章内容，强行修改常量的值会产生未定义行为（Undefined Behavior）,这种行为由编译器决定如何处理。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的文字编码与文字存储类型]]></title>
    <url>%2FC%2B%2B%E4%B8%AD%E7%9A%84%E6%96%87%E5%AD%97%E7%BC%96%E7%A0%81%E4%B8%8E%E6%96%87%E5%AD%97%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[在准备把函数名字输出的时候遇到了输出乱码的问题。12TCHAR* text = "DLL内容テスト。";UE_LOG(LogTemp, Log, TEXT("TEXT: %s"), text); 在我写这段代码之前我连TCHAR是什么类型都不知道，经过一番的调查，关于文字编码和文字的数据存储类型，了解到了很多。 源码的存储格式关于源码的存储格式，在我现在的地方，使用的大多是日语系统因此在什么都不动的情况下使用的是日语的默认 Japanese(Shift-JIS) 格式。至于怎么确认存储格式的话，在一些编辑器中应该就可以查看。 在Visual Studio 2017中改变文件存储格式 File -&gt; Save as -&gt; 下面Save旁边的箭头 -&gt; save with encoding -&gt; replace -&gt; Encoding 一般比较喜欢的就是Unicode(UTF-8) 就是了，毕竟兼容了英文字母之外的字符。 比如最前面把函数名字输出却遇到了乱码的的方，如果将源码存储为UTF-8格式，就不会出现乱码了。 C++中的字符存储类型关于字符的存储问题，首先要分清楚各种字符的存储类型。 char普通的8位字节类型。 wchar_t宽字符类型，表示范围要远大于char类型，表示类型有16位与32位，具体环境具体判断。Unicode编码字符一般以wchar_t类型存储。 为了让编译器识别Unicode字符串，必须在前面加一个L :1wchar_t * text = L"这是中文字符"; 看到这个L，让我想起了现在看的一个日志开源库里的一段糟心的代码：12345678910#ifdef _WIN32# define _PLOG_NSTR(x) L##x# define PLOG_NSTR(x) _PLOG_NSTR(x)#else# define PLOG_NSTR(x) x#endif// UsagePLOG_NSTR("context"); 简单来说就是一个把字符串添加L的宏，刚开始看到的时候糟心的不行。这段内容使用Unicode编码的意思，但是这里有一个问题： 添加了L也就是说是使用Unicode编码，使用wchar_t数据类型存储。接着上述例子，PLOG_NSTR宏接收的如果不是简单的英文字母而是汉字或者日语，简单地输出会正确的输出吗？ 此时源码的存储格式是否支持Unicode编码会产生影响吗？ Shift-JIS格式的源码配合英文字母是能够正确输出的(源码是DLL) 1234PLOG_NSTR("line@");// outputline@ Shift-JIS格式的源码配合日文内容也是能够正确输出的(源码是DLL) 1234PLOG_NSTR("line内容テスト@");// outputline内容テスト@ 当在UEEditor中实验的时候，Shift-JIS的格式源码没有正确输出。 结论：源码的存储格式应该存储为Unicode格式。在字符编码想要支持Unicode和ANSI两种格式的时候应该添加类似以下的宏123456#ifdef _UNICODE#define __T(x) L##x#define _T(x) __T(x)#else#define _T(x) x#endif 关于为什么不直接使用添加L的宏的原因是：防止数据变量声明和定义时的类型冲突。使用宏避免char与L的宽字符存储类型冲突。 在tchar.h文件中可以找到关于__T(x)宏的定义，貌似不包含这个文件的时候，自己定义也可以。 TCHARTHAR是对上述两种字符存储类型的统一，参考以下：12345#ifdef UNICODEtypedef wchar_t TCHAR;#elsetypedef char TCHAR;#endif 当程序定义了UNICODE的时候TCHAR就是宽字符存储类型即wchar_t，当未定义的时候就是普通的char数据类型。 UE4中的字符类型转换当对字符的存储类型有了一些了解，就来看看他们之间的转换吧。先列出一些参考文章： Charactor Encoding C++宽字符当我觉得我能理解并分别和使用C++中的宽字符的时候，现实告诉我还是太天真了。 先看看这篇文章： 彻底解密C++宽字符 写了很多我看不懂的，就是很复杂。我有照着别的示例程序试着写了一下宽窄字符转换，但是英文还好，没看出来什么变化，但是把日语从const char* 变成const wchar_t*的时候乱码还是乱码。 我使用的是mbstowcs函数来实现的，微软的官网文档也有介绍。官方推荐的是使用mbstowcs_s这个函数。有机会的话可以再试试。 应该有更深层次的原因，只不过我放弃了。借用4的FString和TEXT()宏来解决了。 我在plog中看到的宽窄字符转换跟下面的很像说不定好用：12345678910111213// Unicode字符集下可用//--------------------------------------------------------宽字符串转换到窄字符串char* pC = NULL; wchar_t wStr[20] = L"宽字符串"; int iLen = WideCharToMultiByte( CP_ACP,0,wStr,-1,NULL,0,NULL,NULL); if( iLen &gt; 0 )&#123; pC = ( char* )HeapAlloc( GetProcessHeap() ,0 ,iLen ); if( !pC ) return; WideCharToMultiByte( CP_ACP ,0 ,wStr ,-1 ,pC ,iLen ,NULL ,NULL ); printf( "%s \n", pC ); HeapFree( GetProcessHeap() ,0 ,pC );&#125; 123456789101112//--------------------------------------------------------窄字符串转换到宽字符串char cStr[20] = "这是窄字符串";wchar_t* pWideString = NULL;int iLenWide = MultiByteToWideChar( CP_ACP ,0 ,cStr ,-1 ,NULL ,0 ); if ( iLenWide &gt; 0 )&#123; pWideString = ( wchar_t* )malloc( iLenWide * sizeof(wchar_t) ); if( !pWideString ) return 0; MultiByteToWideChar( CP_ACP ,0 ,cStr ,-1 ,pWideString ,iLenWide ); MessageBox( NULL, pWideString , 0 , 0 ); free( pWideString ); &#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识DLL-在UE4与Unity中使用DLL]]></title>
    <url>%2Fuse-dll-in-ue4-unity%2F</url>
    <content type="text"><![CDATA[记录自己逐步认识和掌握DLL的过程。包含了创建DLL，在UE4中使用DLL，在Unity中使用DLL。 新建DLL工程先新建一个简单的DLL工程，然后在里面添加内容，方法可以参照： Linking Dlls 导出函数添加了具体的库的功能之后，需要将函数导出供外部使用。1234567891011121314#pragma once#define DLL_EXPORT __declspec(dllexport)#ifdef __cplusplusextern "C"&#123;#endif int DLL_EXPORT ExportFuncName()&#123; return 0;&#125; // ......#ifdef __cplusplus&#125;#endif 像这样，上述的函数就被导出，能够被外部调用了。 导出函数的时候遇到的问题当我在UE4中使用inline这个关键字的时候，给我报错了。 我在DLL导出函数的时候，导出的函数前面加了inline关键字，所以把导出函数的定义跟声明都写在了头文件里。发生了什么呢？ 在UE4中我获取到了DLL Plugin中的dll库，得到了DLL的Handle，但是准备使用这个Handel取出里面的函数的时候，取出来的是空。函数名什么的都是正确的情况下。 发生上述的情况下我试着去掉DLL中的导出函数的inline声明，声明和定义分开在头文件和cpp文件，就解决了。 回归第一句的事实，貌似UE4C++中对于inline关键字是不支持的。哪怕是动态库中导出来的函数。 UE4Editor中调用DLL在文章最开始的地方提到的链接已经说明的很清楚了。 要点在于: 把制作好的DLL放到特定的文件夹中，一般是Plugin文件夹里面建立一个Plugin。 创建一个类继承BlueprintFunctionLibrary这样蓝图也能使用 声明的函数要是静态的（static） 调用DLL中的函数的步骤是: 定义一个函数指针用来接收DLL中导出的函数(Use typedef to declare a method to store the DLL method) 声明一个Handle来保持与DLL的连接（void* v_dllHandle) 都不为空的时候调用导出来的函数。 123456789101112131415161718192021222324typedef int(*_getFunc)(int a, int b);_getFunc m_getFuncFromDll;void * v_dllHandle;void ULOGBlueprintFunctionLibrary::DLLFunc(int a, int b）&#123; FString dllfilepath = FPaths::Combine(*FPaths::ProjectPluginsDir(), TEXT("DLLLibrary"), TEXT("DLLName.dll")); if(FPaths::FileExists(dllfilepath)) &#123; v_dllHandle = FPlatformProcess::GetDllHandle(*dllfilepath); if(v_dllHandle != NULL) &#123; FString procName = "FunctionName"; m_getFuncFromDll = (_getFunc)FPlatformProcess::GetDllExport(v_dllHandle, *procName); if(m_getFuncFromDll != NULL) &#123; m_getFuncFromDll(a,b); &#125; &#125; &#125;&#125; 使用的方法就像上述。 DEBUG DLL关于DLL的DEBUG的问题，直接在工程里面DEBUG的方法我没有头绪。目前的方法是： 选中Build的模式为Release，x64然后编译。在工程文件夹中找到编译完毕的dll文件导入到调用的工程里面进行调用测试。 UE4中打包第三方库你看上面使用动态链接库的方法多么简单啊，只要找到dll就可以对这个库进行使用了。按照上面的方法，无论在UE4Editor上运行几次，你都会满意的没有话说。 是的，在UE4的Editor上运行的话。 当你觉得差不多了咱们打包一下游戏吧。 File -&gt; Package Project -&gt; Windows -&gt;Windows(64-bit) 打完包了都不知道发什么了什么，知道发现dll的内容根本没法调用。是的，上面的一顿操作，当你打包整个工程之后会发现，准备好的dll并没有被一起打包进工程里。 原因就在于UE4并没有提供自动打包第三方库的功能，需要手动打包。敢情上面的dll的一顿操作只是针对Editor模式好用，当你准备打包应用程序的时候就不行了。算了，不生气。 UE4的编译工具(Build Tools) Build Tools 为什么UE4不能把第三方库内容自动打包呢？这就要从UE4引擎的编译模式来说起了。 从官网的内容来看的话，BuildTools分为三个Topics 1.UnrealBuildTool UnrealBuildTool (UBT) is a custom tool that manages the process of building Unreal Engine 4 (UE4) source code across a variety of build configurations. Read BuildConfiguration.cs to explore various user-configurable build options. 这个应该非常重要的概念了，也经常见到这个工具，但是具体的内容日后再挖。 Understanding Unreal Build ToolTopics1： Targets Targets UnrealBuildTool(以后简称UBT) Topics2: Modules Modules UE4 モジュールについて UE4 Moduleについて 一つの UE4 プロジェクトで複数のゲームモジュールを扱う 【UE4】モジュール追加 ModuleRules(XXX.build.csファイル)について Topics3: Build ConfigurationTopics4: IWYUTopics5: Project Files for IDEsTopics6: Versioning of Binaries2.UnrealHeadTool3.AutomationTool打包第三方库上面的是对于UE4编译系统的理解，而真正需要做的是具体是什么呢? 针对之前的内容我大致的总结了一下，慢慢补充: 将DLL（第三方库）和项目一起打包 .uplugin中的&quot;Modules&quot;模块的&quot;Type&quot;从&quot;Developer&quot;更改为&quot;Runtime&quot; 就我自己的观察结果来看，这个属性不更改的话，打包之后（Package化）连Plugin的尸体都不会给留，在打包后的工程中找不到想要的DLL 指定平台编译（不是必要条件但是要是用错了平台的话肯定是要吃苦头的） 123456789// uplugin文件&quot;Modules&quot;: [&#123;&quot;Name&quot;: &quot;USBCamDirectShow&quot;,&quot;Type&quot;: &quot;Runtime&quot;,&quot;LoadingPhase&quot;: &quot;Default&quot;,&quot;WhitelistPlatforms&quot;: [&quot;Win64&quot;, &quot;Win32&quot;] ←これを追加&#125;] 工程文件结构补充(Module分布),Win64平台 1234567891011121314151617181920212223242526272829303132Project |- Binaries |- ... |- Plugins |- PluginNameA |- Binaries |- ThirdParty |- PluginNameALibrary |- Win64 |- Source |- PluginNameA |- Private |- Public |- PluginNameA.Build.cs |- ThirdParty |- PluginNameALibrary |- PluginNameALibrary.Build.cs |- PluginNameALibrary.tps |- LibrarySource |- PluginNameA.uplugin |- ... |- Source |- Project |- Project.h |- Project.cpp |- ProjectBuild.cs |- ... |- Project.Target.cs |- ProjectEditor.Target.cs |- Project.sln |- Project.uproject |- ... 我只列出了比较重要的内容，对于理解打包第三方库来说的。相比于默认的（创建工程的时候）文件结构来说，唯一不同的地方是在Plugins的文件夹下面的插件中的Binaries和Source文件夹出现了ThirdParty文件夹。当然这个文件夹也不是我创建的。那么我也不是凭空就知道正确的结构。要点就在于UE4提供了第三方库的插件使用模板。 有效使用UE4提供的第三方库的插件使用模板。可以参考下面的第二个链接。Edit -&gt; Plugins -&gt; NewPlugin打开创建新的插件窗口。拉到最下边有一个Third Party Library的模板，创建使用。当然这还只是开始。不过这个时候已经有了雏形，大体的插件文件结构已经构建完成，不需要再去额外的创建文件，只要适当的修改文件就好了。 确保第三方库（DLL）的路径。下面是第三方库的编译设置文件(Build.cs)中的内容 12345678910111213141516171819202122232425262728// 位于上述目录结构中的PluginAnameLibrary.Build.cs// Fill out your copyright notice in the Description page of Project Settings.using System.IO;using UnrealBuildTool;public class test1Library : ModuleRules&#123; Type = ModuleType.External; if (Target.Platform == UnrealTargetPlatform.Win64) &#123; // Add the import library PublicLibraryPaths.Add(Path.Combine(ModuleDirectory, &quot;x64&quot;, &quot;Release&quot;)); PublicAdditionalLibraries.Add(&quot;ExampleLibrary.lib&quot;); // Delay-load the DLL, so we can load it from the right place first PublicDelayLoadDLLs.Add(&quot;ExampleLibrary.dll&quot;); // RuntimeDependencies.Add(new RuntimeDependency(Path.Combine(ModuleDirectory, &quot;x64&quot;, &quot;Release&quot;, &quot;ExampleLibrary.dll&quot;))); // RuntimeDependencies.Add(dll_path); string dll_runtimePath = Path.Combine(ModuleDirectory, &quot;..&quot;, &quot;..&quot;, &quot;..&quot;, &quot;Binaries&quot;, &quot;ThirdParty&quot;, &quot;test1Library&quot;, &quot;Win64&quot;, &quot;ExampleLibrary.dll&quot;); RuntimeDependencies.Add(dll_runtimePath); &#125; else if(Target.Platform == UnrealTargetPlatform.Mac) &#123; PublicDelayLoadDLLs.Add(Path.Combine(ModuleDirectory, &quot;Mac&quot;, &quot;Release&quot;, &quot;libExampleLibrary.dylib&quot;)); &#125;&#125; 第一眼看上去全是懵的，这都是啥？直到现在我也没有能全理解。但是大体的内容我猜的就是保证第三方库的位置。按照代码中的路径依次填充准备好的dll文件，虽然lib文件也设置了，但是估计也不会用到，用的时候再说，此次首要目的是打包dll文件。至于其他的平台的设置，根据要求把。这里重要的是加入了RuntimeDependencies这个依赖项。 这个依赖项的内容或许会在上面的UnrealBuildTool章节中详细展开，或者下面的各种验证章节中展开。 这一部分主要是对dll进行配置，添加依赖项，保证dll在打包过后依然存在，同时也可以在这个Module(Module的概念参考上面，我的理解就是每一个Module都需要一个Build.cs文件)里加入dll的源码或者dll的源文件，但是如果加了源文件并且使用了源码的话，那么使用dll的意义应该也不存在了吧。 插件源码配置。这个部分是对dll的内容进行调用的，或者说为dll的调用提供接口。 1234567// 文件结构Source |- PluginModule |- Private |- Public |- PluginModule.Build.cs |- ThirdParty 如何制作一个扩展插件。这个需求我不知道要如何来描述为好，总之就是上面的插件Module为我们提供了调用接口后，我要如何在另外一个Module中调用这个接口。即如何在工程的主Module中使用扩展的插件Module中的接口。 An Introduction to UE4 Plugins 这个是一个神一样的Wiki，手把手教你制作一个plugin或者说是扩展的Module。跟这篇我完全不知道在讲什么的Linking Static Libraries Using The Build System的这篇Wiki比起来真是一个天上一个地上。不少老外都在diss这篇。 当我差不多理解了上面的内容，也成功的让我的dll在打包后也成功输出了。但我还是想吐槽一句，UE4 的编译系统（UBT）这个东西让我这个初学者感觉到了恶心。为什么，为什么我找不到这个东西具体的Manual？还要去看各种UE4引擎的源码去猜呢？ 【UE4】プラグインのTypeをRuntimeにしたのにShippingでパッケージ化するとロードされないとき ［UE4］プラグインをパッケージ化しよう！ 各种验证，各种现象RunTimeDependencies.Add(String path)这个东西加进去的，首先要保证路径正确由函数名字就可以明白这个是为dll库添加运行时依赖的，也就是确保运行时按照这个路径下能找到dll文件。但是这里有需要注意的问题。这个依赖项的作用，据我简单实验观察得到的结果是 被路径指定的文件在打包后会被一起打包 这非常重要。因为非常头疼的事情就是在打包的时候，dll并没有被带上。自己copy进去？我没有实验过不知道好不好用，但是肯定是会被打的。 比如说上面的例子中按照该路径添加了这个依赖，那么在打包后，这个路径就会被保存下来，当然文件也会存在，而之后的代码中按照原本的路径来取得dll也是没有问题的。 那么这里就有了路径留哪个文件夹的问题。Binaries？Source？ 个人倾向于Binaries文件夹，毕竟dll算是2进制文件，放到这个文件夹里不会产生歧义。但是第三方库的生成往往不是UE4的工作，而是VS中编译好（参考上面）生成。我只好在binaries文件夹的相应路径中复制一份。（Source里更倾向于放置源码，放进去源码的话貌似也可以使用，毕竟都一样嘛） 这个依赖非常关键，它让你的dll在工程打包的时候能够一起被打包。 在我写下这么多文字的时候，就隐隐约约的察觉到了一个问题。我是因为写好的插件直接就放在了一个叫Plugins的文件夹里面了，与这个插件相对的Build.cs文件是一点都没有写。上面提到的又是扩展插件又是Module的，在一个Module里面提供dll的调用接口，为什么我现在工作的Module里不能提供？ 肯定是可以的。原因应该就是我没有给自己的Plugin文件写任何的编译依赖，导致没有没打包。若是被打包进工程，能找到dll的话肯定能使用了啊。 关键就是上面的这个依赖项的添加。 Packaging Plugin with third party Dll How do I add thirdparty library? How do you statically link an external DLL/dylib to your project? UNREAL ENGINE: INCLUDING A THIRD-PARTY LIBRARY (ON THE EXAMPLE OF THE POINT CLOUD LIBRARY AND BOOST) [TUTORIAL] [DOWNLOAD] Adding third party DLL path for plugin 为了搞懂如何打包第三方库，以及做了各种的实验所参考的文章。 UE4: バイナリー配布や実行時リンク向けのライブラリーを UE4 プロジェクトへ組み入れる方法を mecab で解説 Using thirdparty libraries in our UE4 mobile/desktop project UE4のカスタムプラグイン作成時におけるThirdPartyライブラリの取り込み方 Plug-ins &amp; Third-Party SDKs in UE4 UE4でのPlugin開発記録メモ(FMessageDialogでダイアログ表示編) 还有就是感谢UE4的源码了，我翻了许多源码内的各种插件的使用，终于脑海里有了大概的印象。 IpluginManager::Get()这个类是干什么的以后补上，我见到的是用它来取得Plugins的路径：1FString BaseDir = IPluginManager::Get().FindPlugin("PluginName")-&gt;GetBaseDir(); 需要注意的是使用这个类的时候除了要补上头文件#include IPluginManager.h之外，还要把依赖加进Module里面。1PrivateDependencyModuleNames.AddRange(new string[] &#123; &quot;Projects&quot; &#125;); 要不然项目编译不会通过。 IPluginManager::Get() Linker error - Not finding implementation C# SYstem.IO.SetAttributes File.SetAttributes(String, FileAttributes) Method Json数据解析 Parsing Json files 各种路径获取 Packaged Game Paths, Obtain Directories Based on Executable Location 获取绝对路径123FString RelativePath = FPaths::GameContentDir(); FString FullPath = IFileManager::Get().ConvertToAbsolutePathForExternalAppForRead(*RelativePath); Getting full path of project directory 文件夹创建 File Management, Create Folders, Delete Files, and More 其他DLL中头文件的引入在使用plog 源码的时候尝试引入头文件的地方：12// for example#include &lt;plog/Util.h&gt; 上面的引入会出错，而把尖括号换成双引号后就好了。 关于这两者的区别： 用尖括号来指定文件时，预处理器是以特定的方式来寻找文件，一般是环境中或编译器命令行指定的某种寻找路径。这种设置寻找路径的机制随机器，操作系统，C++实现的不同而不同，要视具体的情况而定。 用双引号来指定文件时，预处理器是以“由实现定义的的方式”来寻找文件。它通常是从当前的目录开始寻找，如果没有找到，那么include命令就按与尖括号同样的方式开始寻找。 要说DLL不支持尖括号的查找也不是，内置的一些库还是可以使用尖括号来include的，难不成自己添加的文件就要使用双引号吗？ 另外关于头文件返回上一级路径的写法：1#include "../Util.h" 函数名字前面加上&amp; In C++, when the ref-sign(&amp;) is used before the function name in the declaration of a function it is associated with the return value of the function and means that the function will return by reference. Use of ‘&amp;’ operator before a function name in C++ C++类构造函数初始化列表 Constructor member initializer lists 可以参照以上的文章，主要是可以在声明的同时初始化，在构造函数里面的知只是赋值操作，不是所谓的初始化。 比如说类中想要拥有const类型的变量的话，可以利用构造函数的初始化函数列表来给类中常量赋初值。 C++中的函数指针C++运算符重载C++中的流要把流与字符串分开来看，流是对象，可以用来处理字符串。 stringstreamst(), c_str()函数深入理解char*与char[]的差别关于类中静态成员的理解这里需要强调理解的是，类中静态成员的存储位置是静态存储区，只有一个拷贝，无论类被实例化了多少个，静态成员只有一个，还有一些其他的重要的使用方式，之后整理。 extern “C” よくみる extern “C” {} と __cplusplus - はこべにっき mutex::lock mutex::lock - cpprefjp C++日本語リファレンス]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中得到函数名字]]></title>
    <url>%2FC%2B%2B%E4%B8%AD%E5%BE%97%E5%88%B0%E5%87%BD%E6%95%B0%E5%90%8D%E5%AD%97%2F</url>
    <content type="text"><![CDATA[应某个要求，需要在运行过程中打印出运行的信息，即所谓的LOG收集，此时希望一起打印出来的内容包含调用的函数信息。 在Python中就有这种库，直接能得到函数的调信息名字全部打印出来。但是在C++中就没有现成的库。 自己创建一个库？对我来说还是太早了。 在C++中得到函数名字 __func__可以得到函数名字。在函数里面调用输出就好。 123FString fun_name = FString(UTF8_TO_CHAR(__func__));UE_LOG(LogTemp, Log, TEXT("Function name is : %s), *fun_name); __FUNCTION__可以得到类名加函数名。 123FString func_name = FString(UTF8_TO_CHAR(__FUNCTION__));UE_LOG(LogTemp, Log, TEXT("Function name is : %s), *func_name); 以上是在UE4引擎中输出的结果，也有试过__PRETTY_FUNCTION__来输出但是出现了编译错误。 参考文章： 6.49 Function Name as Strings How to get function name in C++]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EffectiveC++-Chapter01-Accustoming-Yourself-to-C++]]></title>
    <url>%2FEffectiveC%2B%2B-Chapter01-Accustoming-Yourself-to-C%2B%2B%2F</url>
    <content type="text"><![CDATA[Effective C++的第一章内容总结。 条款01：View C++ as a federation of languages.(视C++为一个语言联邦) C Object-Oriented C++ Templete C++ STL 例如对内置（也就是C-like）类型而言pass-by-value通常比pass-by-reference高效，但当你从C part of C++移往Object-Oriented C++，由于用户自定义的（user-defined)构造函数和析构函数的存在，pass-by-reference-to-const往往更好。运用Template C++时尤其如此，因为彼时你甚至不知道所处理的对象的类型。然而一旦跨入STL你就会了解，迭代器和函数对象都是在C指针之上塑造出来的，所以对STL的迭代器和函数对象而言，旧式的C pass-by-value守则再次适用（参数传递方式的选择细节请见条款20）。 条款02：Prefer consts,enums,and inlines to #define.(尽量以const,enum,inline替换#define)123456class GamePlayer &#123;private: enum &#123; NumTurns = 5&#125;; // "the enum hack"补偿作法。以保证NumTurns在编译期间有正确的值 int scores[NumTurns]; // 本是定义的地方，NumTurns未必会有初值，编译器也许会报错&#125; 基于数个理由enum hack值得我们认识。第一，enum hack的行为某方面说较像#define而不像const，有时候这正是你想要的。例如取一个const的地址是合法的，但取一个enum的地址就不合法而取一个#define的地址通常也不合法。 认识enum hack的第二个理由纯粹是为了实用主义。许多代码用了它，所以看到它是你必须认识它。事实上，“enum hack”是template metaprogramming(模板元编程)的基础技术。 12345678#define CALL_WITH_MAX(a, b) f((a) &gt; f(b) ? (a) : (b))// 推荐的写法template&lt;typename T&gt;inline void callwithmax(const T&amp; a, const T&amp; b)&#123; f(a &gt; b ? a : b);&#125; 使用template inline函数（见条款30）也可以获得类似宏带来的效率以及一般函数所有可预料行为和类型安全性（type safety）。 请记住： 对于单纯常量，最好以const对象或enums替换#define 对于形似函数的宏（macs），最好改用inline函数替换#define 条款03：Use const whenever possible(尽可能使用const)]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EffectC++-导读]]></title>
    <url>%2FEffectiveC%2B%2B-%E5%AF%BC%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[Effective C++ 的导读章节的内容整理，知识点备忘吧。应该会将以后的章节归档到一起。 术语（Terminology)关于声明与定义应该有了初步的认识，在其他的C++学习章节有提到过这之间的区分。 定义式(definition)的任务是提供编译器一些声明式所遗漏的细节。对对象而言，定义式是编译器为此编译器拨内存的起点。 这里有一个对于初始化(initialization)的default构造函数的认知误区： default构造函数是一个可被调用而不带任何实参 这样的构造函数要不没有参数，要不就是每个参数都有缺省值 不是说构造函数就是没有参数的。 explicit关键字应用场景：123456789class B&#123;public: explicit B(int x = 0, bool b = true);&#125;;class C&#123;public: explicit C(inx x);&#125;; 在构造函数的前面加上explicit关键字可以防止被用来执行隐式类型转换(implicit type conversions)，但是仍可以被用来进行显式类型转换(explicit type cnversions). 比如说传参的时候，参数应该是一个类型B的对象1234567void doSomething(B bObject);B bObj1;doSomething(28); // 错误，int跟B之间没有隐式类型转换doSomething(B(28)); // 正确，有显式转型，即cast 虽然上述的使用是我之前知道的但是不知道为什么是正确的。为了防止构造函数被隐式类型转换，把构造函数声明为explicit是一个好的选择。 copy构造函数和copy assignment操作符 copy构造函数被用来“以同型对象初始化自我对象” copy assignment操作符被用来“从另一个同型对象中拷贝其值到自我对象” 1234567891011class Widget &#123;public: Widget(); // 默认构造函数 Widget(const Widget&amp; rhs); // copy构造函数 Widget&amp; operator=(const Widget&amp; rhs); // copy assignment操作符 ...&#125;;Widget w1; // 调用默认构造函数Widget w2 = w1; // 调用copy构造函数w1 = w2; // 调用copy assignment操作符 上述的代码应该足够说明用法，但是需要注意的是看见=的时候要注意：1Widget w3 = w2; // 调用copy构造函数 幸运的是“copy构造函数”很容易个“copy赋值”有所区别。如果一个对象被定义（例如以上语句中的w3)，一定会有一个构造函数被调用，不可能调用赋值操作。如果没有新对象被定义（例如前述的“w1=w2”语句），就不会有构造函数被调用，那么当然是赋值操作被调用。 STLTR1和BoostBoost]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++编程思想手抄]]></title>
    <url>%2FC%2B%2B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E6%89%8B%E6%8A%84%2F</url>
    <content type="text"><![CDATA[好久没有看书了，最近重拾看书的习惯，放着一大本的全局光照技术不看，想看看C++的内容。因为最近在调查一个工具，看那个人写的源码，深入看下去发现这个人写的代码是真的很好，跟我之前所在现场的时候看见的那个架构十分相似，但是一个是C#，一个是C++。 想要把那份源码记在脑子里似的，希望能够多过几遍，之后肯定会用的上的。 所以言归正传，聊聊现在看的书，C++编程思想。我会记下来我觉得非常有意义的话语，多看多读，能够印在脑子里面是最好，因为有些东西知道了就想会在代码中潜移默化的表现出来。 第一章 对象导言 在面向对象的程序设计中，答案是非常新奇的：编译器不做传统意义上的函数调用。由非OOP编译器产生的函数调用会导致与被调用代码的早捆绑(early binding)，对于这一术语，读者可能还没有听说过，因为从来没有想到过它。早捆绑的意思是，编译器会对特定的函数名产生调用，而连接器将这个调用解析为要执行代码的绝对地址。在OOP中直到程序运行时，编译器才能确定执行代码的地。所以，当消息被发送给一般对象时，需要采用其他的方案。 为了解决这一问题，面向对象语言采用晚捆绑(late binding) 的思想。当给对象发送消息时，在程序运行的时候才去确定调用的代码。编译器保证这个被调用的函数存在，并执行参数和返回类型的检查【其中不采用这种处理方式的语言称为弱类型(weakly typed) 语言】，但是它并不知道将执行的确切代码。 为了执行晚捆绑，C++编译器在真正调用的地方插入一段特殊的代码。通过使用存放在对象自身中的信息，这段代码在运行时计算被调用函数函数体的地址（这一过程将在15章中详细介绍）。这样每个对象就能根据这段二进制的内容有不同的行为。当一个对象接收到消息时，它根据这个消息判断应该做什么。 我们可以用关键字virtual声明他希望某个函数有晚捆绑的灵活性。我们并不需要懂得virtual的使用机制，但是没有它，我们就不能用C++进行面向对象的程序设计。在C++中，必须记住添加virtual关键字，因为根据规定，默认情况下成员函数不能动态捆绑。virtual函数（虚函数）可用来表示出现在相同家族中的类具有不同的行为。这些不同是产生多态行为的原因。 上面的话对我从新理解C++的面向对象的程序的理解是有帮助的。 比如说这段话对于virtual的理解，不是说遇到这种情况的话需要使用virtual关键字，而是清楚地描述了这种情况下，virtual关键字可以帮助我们来实现。以前只是知道这个关键字是用来声明虚函数，但是为什么要声明虚函数呢，什么情况下声明虚函数却不清楚。 第二章 对象的创建与使用这一章虽然都是大白话，但是对于底层的描述说到底还是不是完全理解的，所以需要细致的去理解。 2.1 语言的翻译过程计算机语言转化为机器指令需要翻译器 通常，翻译器分为两类：解释器（interpreter）和编译器（compiler）。 为什么要录下这段话是因为我以为翻译器只有编译器一种呢。Python使用的就是解释器。而C++使用的就是编译器。虽然解释器与编译器之间的界限也很模糊（听说的）。 但是C++的重点在与编译器的理解上。我也有一个独立写一个编译器的梦想…… 2.1.3 编译过程关于编译的过程我看的是云里雾，所以详细了调查了一些文章。 Building C Projects - Alex Smith关于编译过程的详细说明 1.Configuration（配置） 用户系统环境配置的详细参数信息。以便编译器适应不同的用户环境配置。 2.Standard dircetor detection（确定标准库位置） 3.Source file dependency calculation（确定依赖关系） 4.Header file location（确定头文件位置） 5.Header precompilation（头文件的预编译） 6.Preprocessing（预处理） 7.Compilation and assembly（编译） 8.Object file dependency calculation 9.Linking（连接） 编译器把外部函数的代码添加到可执行文件中。静态连接 与 动态连接。 10.Installing（安装） 11.Resource linking 12.Package generation（生成安装包） 13.Dynamic linking（动态连接） 时间关系就直接把编译过程的大概列出来吧。 某些语言（特别是C/C++）编译时，首先要对源代码进行预处理，预处理器（preprocesser） 是一个简单的程序，它用程序员（利用预处理器指令）定义好的模式代替源代码中的模式。预处理指令用来节省输入，增加代码的可读性。（C++程序设计并不鼓励多使用预处理指令，因为他可能引起一些不易发现的错误，这些将在本书的后面分析。）预处理过的代码通常放在一个中间文件中。 编译一般分两遍进行。首先，对预处理过的代码进行语法分析。编译器把源代码分解成小的单元，并把它们按树形结构组织起来。表达式“A+B”中的“A”，“+”和“B”就是语法分析树的叶子节点。 有时会在编译的第一遍和第二遍之间使用全局优化器（global optimizer） 来生成更短，更快的代码。 编译的第二遍，由代码生成器（code generator） 遍历语法分析树，把树的每个节点转化成汇编语言或机器代码。如果代码生成器生成的是汇编语言，那么还必须用汇编器对其汇编。两种情况的最终结果都是生成目标模块（通常是一个以.o或.obj为扩展名的文件）。有时也会在第二遍中使用窥孔优化器（peephole optimizer） 从相邻一段代码中查找冗余语句。 上述内容大致描述了编译过程，应该还涉及到了许多之前尚未完全理解的内容吧。 2.2 分段编译工具 程序可由多个文件构成，一个文件中的函数可能要访问另一个文件中的函数和数据。编译一个文件时，C或C++编译器需要知道在另一个文件中的函数和数据，特别是它的名字和基本用法，编译器就是要确保函数和数据被正确的使用。”告知编译器“外部函数和数据的名称及它们的模样，这一过程就是声明（declaration） 。一旦声明了一个函数或变量，编译器知道怎样检查对它们的引用，以确保引用正确。 这一段话告知了声明这一概念，为什么需要声明，声明用来做什么的。声明就是像编译器告知外部自己的存在以及如何使用自己。 2.2.1 声明与定义之前从未对这两个概念进行细致的区分，或者说根本没有去注意。理解这两个概念会发现，这两个概念，还蛮重要的… 声明（declaration） 是向编译器介绍名字-标识符。它告诉编译器“这个函数或这个变量在某处可以找到，它的模样像什么”。而定义（definition） 是说：“在这里建立变量”或“在这里建立函数”。它为名字分配存储空间。无论定义的函数还是变量，编译器都要为它们在定义点分配存储空间。对于变量，编译器确定变量的大小。，然后在内存中开辟空间来保存量的数据。对于函数，编译器会产生代码，这些代码最终也要占用一些内存。 上面的内容说明了声明跟定义的区别。声明就好比开店之前的宣传，编译器拿着传单知道了这家店的信息，使用情报，而定义就是真正的开店开业，是在上述传单的描述中真实存在的一家店。 在C/C++中，可以在不同的地方声明相同的变量和函数，但是只能有一个定义【有时这称为ODR（one-defifition rule,单一定义规则）】。当连接器连接所有的目标模块时，如果发现一个函数或变量有多个定义，连接器将报告出错。 相同的变量或函数可以多次声明，但是定义只能有一次。 定义也可以是声明。如果定义int x;之前，编译器没有发现标识X，编译器则把这一标识符看成是声明并立即为它分配存储空间。 2.2.1.4变量声明的语法关于变量的声明，由于文章的说明有些多，直接写下自己的理解： 1int a; 这只是一个非常常见的变量声明，这是声明？还是定义？ 这段代码有足够的信息让编译器为整数a分配空间，而且编译器也确实给整数a分配了空间。要解决这个矛盾，对于C/C++需要一个关键字来说明“这只是一个声明，它的定义在别的地方”。这个关键字就是extern，它表示变量是在文件以外定义的，或在文件后面部分才定义。 1extern int a; //声明一个变量但是不定义它 结果就是，对于变量来说简单的声明所提供的情报足以让编译器为其定义。想要停止这种编译器自动的行为就需要使用extern关键字来告诉编译器说我要晚一点再定义这个变量，你先知道有这么个变量就行了。 对于函数来说又是什么样子的呢？1int func1(int length, int width); 1extern int func1(int length, int width); 这两种声明方式有区别吗？ 因为没有函数体，编译器必定把它作为声明而不是函数定义。extern关键字对函数来说是多余的，可选的。C语言的程序设计者并不要求函数声明使用extern，这可能有些令人遗憾； 无论加还是不加，编译器都认为这种定义方式都没有足够的信息去定义一个函数，因此都会被视为声明。通过理解声明与定义的区别，应该可以灵活运用函数与变量的出现位置。 关于extern关键字使用的拓展，目的是加深理解这个关键字的作用。参看文章 C/C++中的extern关键字详解 extern除了告诉编译器这只是一个声明之外，还有一个作用是跟&quot;C&quot;一起连用的时候，是告诉编译器按照C的规则来办事。比如说下面的例子: 1extern "C" void fun(int a, int b); //出于上述的文章中的描述 按照C的规则来翻译这个声明的函数，貌似按照C++的翻译规则，编译器会将函数名变得跟fun不一样，要看编译器的”脾气”。这个跟C++的函数重载特性有关。下面的内容全是选自上面的文章： extern变量 在一个源文件里定义了一个数组:char a[6];在另一个文件里声明extern char *a; 这种声明可以吗？ 答案是不可以。程序运行会告诉你非法访问。原因是类型不同，指向类型T的指针并不等价于类型T的数组，不难发现，这是指针与数组使用中经常出现的盲区知识，若是对于指针的理解只有半吊子的水平还喜欢炫耀的话就会在此栽跟头。正确的声明应该是: 1extern char a[]; 在使用extern的时候应该严格对应声明的格式。 extern常常被用作全局变量来使用，利用其这种特性，在.h文件中使用extern来声明。 extern “C” C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用`extern “C进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。 这应该是在C++环境中使用C函数的时候应该注意的问题。 extern函数声明 原文中举了一个例子，总的来说就是extern对于函数来说就像上文提到的可加可不加，没有明显的区别，仅仅就是一个暗示，可能这个函数会在别的源文件里面定义。 当把全局变量的声明跟定义放在一起的时候，会因为#include的存在而产生重复定义的链接错误。所以：只在头文件中做声明，真理就是这么简单。当然不使用#include语句，将想要提供给外部接口的函数和变量全部使用extern来修饰也是一种方法。你用么，反正我不用。 extern和static （1）extern表明该变量在别的地方已经定义过了，这里要使用那个变量。 （2）static表示静态的变量，分配内存的时候，存储在静态区，不存储在栈上面。 stati作用范围是内部连接的关系，跟extern一样，修饰的部分是跟对象分开存储的，但是却不能被其他对象引用，而extern可以。static修饰的变量只允许对象本身使用。具体差别首先：static跟extern是一对”水火不容”的家伙，也就是说，extern和static不能同时修饰一个变量；其次，static修饰的全局变量声明与定义同时进行，也就是说你在头文件中使用static声明了全局变量之后，它同时被定义了；最后，static修饰的全局变量的作用域只能是本事的编译单元，也就是说它的全局只对本编译单元有效，其他编译单元则看不到它。如： 1234567891011// test1.hstatic char g_str[] = "123456";void fun();// test1.cpp#include "test1.h"void func1()&#123; cout&lt;&lt;g_str&lt;&lt;endl; &#125;// test2.cpp#include "test1.h"void func2()&#123; cout&lt;&lt;g_str&lt;&lt;endl; &#125; 以上的两个编译单元可以连接成功，你可以在各自的.obj文件中找到字符串&quot;123456&quot;的存在。虽然它们有相同的内容，但是存储的物理地址并不一样，就像是两个不同的变量赋了相同的值一样，而这两个变量分别作用于它们各自的编译单元。 一般定义static全局变量的时候，都把它放在原文件中而不是头文件，这样就不会给其他模块造成不必要的信息污染。 extern和const C++中的const修饰的全局常量有跟static相同的特性，即它只能作用于本编译模块中，但是const可以和extern连用来声明该常量可以作用于其他编译模块中，如extern const char g_str[];,然后在原文件中别忘了定义：const char g_str[] = &quot;123456&quot;; 所以当单独使用的时候它就与static相同，而当与extern一起合作的时候，它的特性就跟extern一样了。最后是该作者的提醒：123456const char* g_str = "123456"; // const修饰的是char*而不是g_str// 与下面的写法const char g_str[] = "123456";// const char* const g_str = "123456";` 上面算是对extern关联的一些拓展内容吧。 2.2.1.5包含头文件 #include预处理指令有两种方式来指定文件：尖括号（&lt; &gt;）或双引号。 #include &lt;header&gt;用尖括号来指定文件时，预处理器是以特定的方式来寻找文件，一般是环境中或编译器命令行指定的某种寻找路径。这种设置寻找路径的机制随机器，操作系统，C++实现的不同而不同，视具体的情况而定。 #include &quot;local.h&quot;用双引号时，预处理器以”由实现定义的方式“来寻找文件。它通常是从当前目录开始寻找，如果文件没有找到，那么include命令就按与尖括号同样的方式重新开始寻找。 包含iostream头文件要用如下语句 #include &lt;iostream&gt; 包含头文件的两种方式的区别。 2.2.2 连接 连接器把由编译器生成的目标模块（一般是带.o或.obj扩展名的文件）连接成为操作系统可以加载和执行的程序。它是编译过程的最后阶段。 2.2.3 使用库文件2.2.3.1连接器如何查找库当C或者C++要对函数或变量进行外部引用时，根据引用的情况会选择两种处理方式。 一是如果未遇到过这个函数或者这个变量的定义，就把它的标识符加到未解析的引用列表中，如果连接器遇到过他们的定义，就是已解决的引用。 二是如果连接器没有在目标模块中找到它们的定义，就去查找库。 库有某种索引方式，连接器不会去浏览库中的所有目标模块，而是浏览索引。如果找到了就把函数或变量定义所在的目标模块连接到可执行程序。 这里需要注意的是连接的是目标模块而不是整个库，因此在构造自己的库的时候，一个源码文件只有一个函数，可以减少程序包的大小。 2.2.3.2秘密的附加模块 当创建一个C/C++的可执行程序的时候，连接器会秘密连接某些模块。其中之一是启动模块，它包含了对程序的初始化例程。初始化例程是开始执行C/C++程序时必须首先执行一段程序。初始化例程建立堆栈，并初始化程序中的某变量。 连接器总是从标准库中查找程序中调用的经过编译的标准函数。由于标准库总可以被找到，所以只要在程序中包含所需的头文件，就可以使用库中的任何模块，并且不必告诉连接器去找标准库。 如果使用附加的库，必须把该库文件名添加到由连接器处理的文件列表中。 上面的内容给我揭示了一个盲区，貌似我之前的水平都没有接触到，标准库以外的内容。如果有一天我发现标准库的内容满足不了，我需要别的库的实现，除了在代码中引用之外，我还应该修改连接器维护的一个文件列表，把库的名字加进去。至于应该怎么做，不太清楚了。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的Casting]]></title>
    <url>%2FUE4%E4%B8%AD%E7%9A%84Casting%2F</url>
    <content type="text"><![CDATA[关于Cast To节点在Blueprint中能够做什么的问题。下面是官方文档中的说明。 Casting in Blueprint 其中的一句话： By using the Get Player Charactor node, then using a Cast To MyCharactor node(the special Charactor Blueprint), you can say if the Player Charactor is MyCharactor, let me access the Variables, Functions, Events or any other special functionality contained within that Blueprint.]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Blueprint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-rebases使用方法]]></title>
    <url>%2Fgit-rebases%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[git rebase的使用简介]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4:Error_Message整理]]></title>
    <url>%2FUE4-Error-Message%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[整理在学习UE4的过程中遇到的一些BUG。 syntax error:missing ‘;’ before ‘*’参考链接： syntax error: missing ‘;’ before ‘*’ (First Person Shooter C++ Tutorial) 加了一个关键字class就解决了。虽然不知道是为什么。 LogMaterial: Warning: Material /Game/MagicCircle/Materials/MT_Smoke.MT_Smoke missing bUsedWithInstancedStaticMeshes=True! Default Material will be used in game.#]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>UE4Error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为Actor添加Input事件]]></title>
    <url>%2F%E4%B8%BAActor%E6%B7%BB%E5%8A%A0Input%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在自己编写Actor的Component的时候想要加上input的事件，但是在UE4中加入这种事件不是那么简单的。这需要对Actor的层级关系有一些了解。 参考链接： C++Is there a way to get input from actor that isn a pawn/character ? Check Keyboard Event in code UE4-学习笔记之二 这篇文章感觉好厉害 &lt;&gt;GamePlay架构(四)Pawn 知乎文章，可以一看]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4-ConstructorHelpers::FObjectFinder]]></title>
    <url>%2FUE4-ConstructorHelpers-FObjectFinder%2F</url>
    <content type="text"><![CDATA[先来说一说这个问题的起源吧。最近想做一个类似于火焰的特效，是由大量的烟雾粒子组成的那种类似于烟雾的火焰。在制作大量烟雾粒子之前首先要制作出第一个粒子。 制作一个粒子表现的话首先要先实例化一个Instance，这个实例首先依附在一个Acor上。当然，像Unity的脚本函数一样，在Scene中制作一个Actor然后把脚本当做一个ActorComponent的方案是可行的。然后在脚本中使用this-&gt;GetOwner()即可以获取到这个Actor。可以使用this-&gt;GetOwner()-&gt;GetName()来获取到Actor的名字。 参考链接： Get actor from component in c++? 在这里遇见了一个问题。就是在使用UE的UE_LOG打印输出的时候发生了类型错误。 在UE_LOG中使用的都是基础类型，%d,%s等等。 GetName()函数返回的变量类型则是UE的FString类型 解决例子：12// Actor component .cpp fileUE_LOG(LogTemp, Log, TEXT("show value: : %s", *(this-&gt;GetOwner()-&gt;GetName())); 解决案参考： Log issue (passing a FString) Logs, Printing Messages To Yourself During Runtime 能够获取到Parent的Actor就可以根据自身的Actor来制作InstanceStaticMeshComponent了。 InstanceStaticMeshComponent使用方法参照： Using Instanced Static Meshes in C++? 下一步就是发生问题的地方，为制作好的InstanceStaticMeshComponent添加StaticMesh。 上网查查资料就有，这篇文章就行 QUESTION Apply Static Mesh to StaticMesh component 照着做本来不会出错的但是我一运行，UE4肯定Crash。 原因就在于题目所提到的关于ContructorHelpers::FObjectFinder的使用上。总结来说就是这个函数只能运行在类的构造函数中，或者构造函数里调用的函数中。 解决文章： How to use ConstructorHelpers::FObjectFinder? 这个回答中有提到。之后再整理。]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH原理知识普及]]></title>
    <url>%2FSSH%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A%2F</url>
    <content type="text"><![CDATA[SSH的原理与运用。 参考链接： SSH原理与运用（一）：远程登录 数字签名是什么？ What is a Digital Signature?]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中读取Texture2D的像素值]]></title>
    <url>%2FUE4%E4%B8%AD%E8%AF%BB%E5%8F%96Texture2D%E7%9A%84%E5%83%8F%E7%B4%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[目的是在UE中获取到一张Texture2D图片的所有像素值，并将这些像素值进行某些处理并保存到另外一个Texture中。 第一步：获取到Texture2D资源Unreal Engine 4 Documentation Referencing Assets 对于高速化来说异步加载资源也是好的解决方案 Ureal Engine 4 Documentation Asynchronous Asset Loading 参考的文章 Accessing pixel values of Texture2D First you need to understand that a texture is normally, a sum of multiple images called MipMaps. MipMaps are down-scaled versions of your images, always in steps of power of 2, so the original image, is, say, 512x512 - this would be the MipMap “0”, then the engine generates the MipMap “1” which is 256x256 and then MipMap “2” which is 128x128, this continues on down to 16x16 I think. The farther away the texture is rendered, the smaller version of the image is used. This means that you need to access the mipmap 0 of your texture. 对上面的答案进行了非常好的总结的文章 UE4 – Reading the pixels from a UTexture2D Reading data from UTexture2D 之后附上完整的代码UE4中的资源管理 Asset Management 拓展知识在代码中看到了static_cast这个语句，竟然不知道是做什么的。查了一下 C++中static_cast, dynamic_cast, const_cast用法/使用情况及区别解析 之后要好好整理一下。]]></content>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4的函数库]]></title>
    <url>%2FUE4%E7%9A%84%E5%87%BD%E6%95%B0%E5%BA%93%2F</url>
    <content type="text"><![CDATA[在UE4中总会遇见一些不知道是做什么的函数，这篇文章的目的是整理自己遇到的UE4的函数和类，和弄清函数和类的时候遇到的一些问题的解决。 UE4中的类UTexture2DTextureCompressionSettingsTextureMipGenSettingsUpdateResource() Functio作用UTextureRenderTaget2DUreal Engine 4 Documentation: UTextureRenderTarget2D 可以用来存储一个2DTexture数据的类，拥有着许多的成员，文件的位置： C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Classes\Engine\TextureRenderTarget2D.h C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Private\TextureRenderTarget2D.cpp 关于如何实例化这个类，我在网上并没有找到类似的实现，但是在UE4的Blueprint中可以找到一个名为Create Rendr Target 2D的node函数。试着找了一下这个节点的实现函数 C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Private\KismetRendngLibrary.cpp 其中有如下的实现代码：1234567891011121314151617UTextureRenderTarget3D* UKismetRenderingLibrary::CreateRenderTarget2D(UObject* WorldContextObject, int32 Width, int32 Height, ETextureRenderTargetFormat Format)&#123; UWorld* World = GEngine-&gt;GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull); if (Width &gt; 0 &amp;&amp; Height &gt; 0 &amp;&amp; World &amp;&amp; FApp::CanEverRender()) &#123; UTextureRenderTarget2D* NewRenderTarget2D = NewObject&lt;UTextureRenderTarget2D&gt;(WorldContextObject); check(NewRenderTarget2D); NewRenderTarget2D-&gt;RenderTargetFormat = Format; NewRenderTarget2D-&gt;InitAutoFormat(Width, Height); NewRenderTarget2D-&gt;UpdateResourceImmediate(true); return NewRenderTarget2D; &#125; return nullptr;&#125; 或许可以给与一些参照。 UMaterialInstanceDynamicUreal Engine 4 Documentation: UMaterialInstanceDynamic 这个类的作用按照字面意思来推测是用来创建一个动态的材质实例，在UE4的Blueprint中也有相应的节点函数：CreateDynamicMaterialInstance。函数位置 C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Private\KismetMaterialLibrary.cpp 其中的实现代码：1234567891011121314151617181920class UMaterialInstanceDynamic* UKismetMaterialLibrary::CreateDynamicMaterialInstance(UObject* WorldContextObject, class UMaterialInterface* Parent)&#123; UMaterialInstanceDynamic* NewMID = nullptr; if (Parent) &#123; // MIDs need to be created within a persistent object if in the construction script (or blutility) or else they will not be saved. // If this MID is created at runtime then put it in the transient package UWorld* World = GEngine-&gt;GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::ReturnNull); UObject* MIDOuter = (World &amp;&amp; (World-&gt;bIsRunningConstructionScript || !World-&gt;IsGameWorld()) ? WorldContextObject : nullptr); NewMID = UMaterialInstanceDynamic::Create(Parent, MIDOuter); if (MIDOuter == nullptr) &#123; NewMID-&gt;SetFlags(RF_Transient); &#125; &#125; return NewMID;&#125; 可以为该材质添加值的函数实现：1234567891011121314151617181920212223void UKismetMaterialLibrary::SetScalarParameterValue(UObject* WorldContextObject, UMaterialParameterCollection* Collection, FName ParameterName, float ParameterValue)&#123; if (Collection) &#123; if (UWorld* World = GEngine-&gt;GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull)) &#123; UMaterialParameterCollectionInstance* Instance = World-&gt;GetParameterCollectionInstance(Collection); const bool bFoundParameter = Instance-&gt;SetScalarParameterValue(ParameterName, ParameterValue); if (!bFoundParameter &amp;&amp; !Instance-&gt;bLoggedMissingParameterWarning) &#123; FFormatNamedArguments Arguments; Arguments.Add(TEXT("ParamName"), FText::FromName(ParameterName)); FMessageLog("PIE").Warning() -&gt;AddToken(FTextToken::Create(LOCTEXT("SetScalarParamOn", "SetScalarParameterValue called on"))) -&gt;AddToken(FUObjectToken::Create(Collection)) -&gt;AddToken(FTextToken::Create(FText::Format(LOCTEXT("WithInvalidParam", "with invalid ParameterName '&#123;ParamName&#125;'. This is likely due to a Blueprint error."), Arguments))); Instance-&gt;bLoggedMissingParameterWarning = true; &#125; &#125; &#125;&#125; 使用方法是在C++中声明一个材质1234567UMaterialInstanceDynamic* mMaterial;//将mMaterial的材质实例通过Blueprint传递过来mMaterial-&gt;SetScalarParamaterValue("TextureWidth",512);//这样便可以将换递过来的Blueprint中的名为`TextureWidth`(if exist)的Parameter赋值为512了 但还是有许多疑问。 UE4中的函数check()参考链接： When should I use Check()? AddInstance()UE4中的一些类型TextureAddress在Texture.h中看到了这个属性，不太清楚是什么属性，就查了一下。貌似是一种纹理寻址模式。因为有赋值为T_Clamp,Clamp让我有些回想起来在Unity中设置UV的时候有repeat跟clamp等等选项来着，需要调查一下。 D3D11_TEXTURE_ADDRESS_MODE(纹理寻址模式) TextureFilterSRGB是什么参考链接： sRGB - how to be? 【图形学】我理解的伽马校正（Gamma Correction）]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的static关键字]]></title>
    <url>%2FC%2B%2B%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[static 关键字可用于声明变量、函数、类数据成员和类函数。 之后需要好好整理一下，static关键字的用法。 参考链接： C/C++ 中的static关键字 The static keyword and its various uses in C++]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4的Plugin使用]]></title>
    <url>%2FUE4%E7%9A%84Plugin%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[制作UE4的插件相当于给UE4引擎添加新的功能模块。UE4的功能模块组成是由Module组成的，关于Module具体是什么，中文翻译就是模块，自己的理解中可以说是文件的单位了。 新建的插件代表着跟UE4本来的功能模块不是从属于一个Module，所以需要为自己制作的插件制作一个属性为Public的公开接口以供UE4引擎调用。 Plugin的Public公开权限一般一个Module中不想公开的源文件都会设置为Private权限，不允许外界的Module访问。要把权限公开，使得其他的模块能够访问的话需要以下两步。 头文件的位置 头文件(.h)放到[\Source\Public]文件夹中去 cpp实现文件放到[\Source\Private]文件夹中去 添加Export用的宏在类的声明中添加一个宏：&lt;大写字母的Module名字&gt;_API 例如：1234UCLASS()class SAYHELLO_API USayHelloFunction : public UBlueprintFunctionLibrary&#123; GENERATED_BODY()&#125; 这样一个名为SayHello的Module的class的权限就变成公开的了。 Tips： 上述的SAYHELLO_API的定义文件位置在Intermediate/Build/Win64/UE4Editor/Development/SayHello/Definitions.SayHello.h。里面定义了DLLEXPORT,DLLIMPORT。 UE会按照Module的单位生成DLL，&lt;ModuleName&gt;_API在自身的Module中会指定DLLEXPORT，在其他的Module中会指定DLLIMPORT。（啥意思？书上就写了这么多。。。） 参考资料： Unreal Engine 4 Documentation - Plugins Unreal Engine 4 C++ 插件介绍 ue4插件开发 Plugins顺着文章名字找过来，结果发现内容跟我想象的不太一样。那么就分为两部分，上面是介绍UE4插件的使用方式。这一部分是介绍UE4中用到的插件。 Impostor Bake Impostor Baker for UE4 Octahedral Impostors Github 这个插件在工程中使用过不过不太清楚是做什么的，不是我使用的部分，只是看到了。（需要整理）]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Plugins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的const修饰符]]></title>
    <url>%2Fc%2B%2B-const-modifier%2F</url>
    <content type="text"><![CDATA[C++中经常会看到const关键字来修饰很多东西，在这里把自己遇到的一些情况收集并整理一下。 参考链接 C++ Const Usage Explanation 关于C++ const 的全面总结 C++中的mutable关键字 C++ 中的 mutable 关键字 C++进阶–类型转换，你看我就够了]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的静态库与动态库]]></title>
    <url>%2FUE4%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[库(Library)是什么,库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。 本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种：静态库（.a、.lib）和动态库（.so、.dll）。所谓静态、动态是指链接。 需要知道的除了制作动态库与静态库，还要知道这两种库之间的区别。为什么要制作库。 参考链接： C++静态库与动态库]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的异步处理]]></title>
    <url>%2FUE4%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[能够熟练的使用UE4中的异步处理应该能够很好的利用程序运行的资源，和计算。除此之外还有并行的处理。目的是要理清UE4中的线程的同步异步，并行操作和标准C++中的线程同步异步，并行操作。 时间有限，暂时记录下关键字： UE C++ ThreadPool 异步处理相关函数： Async Lambda记法 AsyncTask ParallelFor123//函数的位置Engine/Source/Runtme/Cre/Pblic/Async/Async.hEngine/Source/Runtme/Cre/Pblic/Async/ParallelFor.h 异步辅助API FScopeLock]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的C++]]></title>
    <url>%2FUE4-C%2B%2B%2F</url>
    <content type="text"><![CDATA[UE C++拥有着自己的库，当然也可以使用C++的标准库(STL)，但是不同的地方还应该好好记载下来，同时也是对C++的一种复习。 1.值类型？指针？在标准C++中，类的声明可以12345ClassExample ObjName;/或者是ClassExample* ObjPtr; 而在UE4中为了统一值类型与指针的规则，想这种类的声明全部使用指针类型，不使用值类型。1UObject* o; 2.UE4生成类对象实例(Instance)直接上例子：12345678//声明UMyClass* MyClass;//生成实例MyClass = NewObject&lt;UMyClass&gt;();//或者MyClass = NewObject&lt;UMyClass&gt;(Owner); Tips: 在构造函数中不能使用NewObject&lt;T&gt;生成其他的对实例。会使程序Crash。如果想生成其他的Object的话使用FObjectInitializer::CreateDefaultSubobject&lt;T&gt;函数 123ASomeActor::ASomeActor(const FObjectInitializer &amp; ObjectInitializer) : Super(ObjectInitializer)&#123; SampleActor = ObjectInitialize.CreateDefaultSubobject&lt;ASampleActor&gt;(this, TEXT("SampleActor"));&#125; 3.Actor的实例化4.Actor的Component实例化1.在UE4C++中试着添加component1.添加SkeletalMeshComponent或许有一天我会再次遇见这个问题，就是想要用C++来写全部的东西。比如说在C++中为一个Actor添加ActorComponent（这个ActorComponent就是要写的C++本体了），这是很顺利。然后再为这个Actor添加一个SkeletalMeshComponent组件。 问题就出现在这里。 我天真的以为在这个ActorComponent中使用this-&gt;GetOwner()-&gt;GetRootComponent()然后创建组件就能成功了。 12// 其他的省略this-&gt;GetOwner()-&gt;GetRootComponent()-&gt;CreateDefaultSubject&lt;USkeletalMeshComponent&gt;(TEXT("SkeletalMeshName")); 然后UE4Editor就驾崩了。 CreateDefaultSubject直接用就行，不用加前面的一串限定，我还不知原因。把前面删了之后就不会崩溃了。而且去View试图中找Actor下面也确实有生成的SkeletalMeshComponent了。 于是我就SetSkeletalMesh之后发现，明明SkeletalMesh上面有值，也就是正确赋值了，Mesh不显示。 对比了一下终于发现这种方法生成的SkeletalMeshComponent，后面带了一个inherited的标识。 去搜了一下inherited skeletal mesh component doesnt show mesh 天杀的这种UE4程序级别的BUG也能被我碰到。都2019年了还没解决么。看样子是15年提的问题。 也许会有别的方式来为一个Actor在C++中创建SkeletalMeshComponent，但是我没有找到。想了想，还是直接用Blueprint吧，当然直接让Actor直接Add一个Component就能解决然后在C++中保留这个组件的ref就行，但是这样的话不是纯C++的话，为什么直接效率一些直接用BP吧。 为什么我C++中创建就是inherited的对象？是创建的姿势不对么… 我也试过用NewObject&lt;USkeletalMeshComponent&gt;来创建过，但可能是因为代码在构造函数里，还没运行，只是编译一下 UE4Editor就驾崩了。 5.从Content(Asset)中加载Object对象数据6.UE4中的容器7.UE4C++中的一些小知识点1.从SkeletalMeshComponent得到AnimationBlueprint123456789// USkeletalMeshComponent::GetAnimInstance()USkeletalMeshComponent * SkeMC = SkeMC_ptr;UAnimInstance* animIns = SkeMC-&gt;GetAnimInstance();// 拓展// Copy one anim instance to another charactorACharactor* ch = /*...*/;UAnimInstance * mi = GetMesh()-&gt;GetAnimInstance();ch-&gt;GetMesh()-&gt;SetAnimInstanceClass(mi-&gt;GetClass()); 2.运行时取得SkeletalMesh的Bone情报取得Bone情报能做什么呢？ 1.Get the name of all bones参考： Skeletal mesh overlap returns null bone 123456789101112131415USkeletalMeshComponent* SkelMeshComp = Cast&lt;USkeletalMeshComponent&gt;(GetMesh());if (SkelMeshComp) &#123; TArray&lt;FName&gt; BoneNames; SkelMeshComp-&gt;GetBoneNames(BoneNames); for (int i = 0; i &lt; BoneNames.Num(); i++) &#123; FBodyInstance* BodyInst = SkelMeshComp-&gt;GetBodyInstance(BoneNames[i]); if (BodyInst) &#123; UPhysicalMaterial* PM = BodyInst-&gt;GetSimplePhysicalMaterial(); EPhysicalSurface SurfaceType = UPhysicalMaterial::DetermineSurfaceType(PM); if (SurfaceType_Default != SurfaceType) &#123; PhysicBoneNames.Add(BoneNames[i]); &#125; &#125; &#125;&#125; 2.Get Socket Location搜了半天，又是Bone又是FbodyInstance什么的，结果直接获取bone的世界坐标的话有这个函数。 Get Socket Location C++和Blueprint都能用，自己以前也有试过在Skeletal加Socket，连自己加的Socket都能直接获取，方便了。 3.Animation切换就我自己所接触的动画处理而言，将动画的主体的状态跟动画的播放是分开的，也就是说存在一帧的延迟。 我不知道真正的游戏开发中的情况是什么样子的，不真正的去看人家的源码我是不会明白的…… 记录一下要点。 状态的切换和真正动画的切换存在一帧的延迟 真正动画的切换在UE4中有一个cross-fade支持 为什么要注意这个是因为动画中如果出现位移，而真正的位移跟动画应该是分开处理的，动画中有位移的话就得根据这段位移进行实际位移的调整来适应下一段动画。不然的话就会产生残留帧（产生跳帧的感觉），因此对于动画的调整就要精确到每一帧的地步，超级麻烦。 Unity和UE4都一样，为Animation的切换提供的过渡的功能，有的时候反而起了反作用。 但是吧，这种只是强行修复位移的效果终究不如使用真正流畅的动画素材要来的好，可能的话，还是制作正确的动画比较合理（拜托美工啦）。 3.Handling animation in C++把UE4中的关于Animation的处理，交给C++来做。就结论来说就是：做个C++类的AnimInstance以供AnimationBlueprint来继承。 我特么…暂时没有找到非要这样的做的理由。 Handling animations in C++ Animation Blueprint, Implement Custom C++ Logic Via Tick Updates Animation Blueprint, Set Custom Variables Via C++ 上面的教程和Wiki手把手教学，教你如何使用C++操作动画，但是并不是全部C++，动画跳转还是用的AnimationBlueprint。都已经用了AnimBP了…… (1) 暂停动画我尝试着找到停止AnimationInstance的tick函数的方法，但是失败了，后来发现在AnimationBlueprint附着的SkeletalMesh组件上有下面两个属性 Pause Anims Global Anim Rate Scale 控制动画播放和暂停，或者动画的播放速度。 4.使用C++制作Blueprint的Node Blueprints, Creating C++ Functions as new Blueprint Nodes 我有试着写过全局的输出LOG的函数，应该多少有这篇文章的内容，这篇应该介绍的很多，有时间整理一下。 5.在C++中生成BlueprintClass实例为什么要做这么蛋疼的事情?但也是的确事出有因，用蓝图写一些组件然后赋值真的太方便了啊…C++里写的话就得各种找组件然后Load各种素材找路径，在蓝图里一拽就解决了。 这里主要是利用了SpawnActor这个类。 UE4: C++ コード から C++ クラスまたは Blueprint のアクターを FindObject して SpawnActor する方法 上面这篇文章写得很好了，就是风格太花里胡哨了，看着有些累眼睛。 为了能先得到要实例化的BlueprintClass，我没有选择使用从ContentBrower里面Load素材的方法。而是选择了最方便的方法，当然上面的文章里也有提到。 12UPROPERTY(EditAnywhere, Category = "PawnBlueprintClass") TSubclassOf&lt;class AActor&gt; SunDevilBPClass; 公开一个类模板的属性，取得类模板。（前提是BlueprintClass继承了AActor类，当然这里填上你继承的类类型就好了）公开了这个属性之后，就可以在Editor的Detail面板里把想要实例化的蓝图类选进去。 还有一篇文章，或许也能作参考，但是我没有试过，之后有时间的话可以试一下。 C++でのブループリントクラス取得方法につきまして FActorSpawnParametersTSubclassOf TSubclassOf 上面用到的一个类，感觉挺重要的，需要总结一下这个类相关的东西。 疑问我会选择使用C++来生成蓝图类的原因除了我制作了一个C++管理类来生成蓝图类大量实例之外，还有就是对蓝图类初始化抱有疑问。 蓝图类的constructor中的内容，在把蓝图拖入场景这个操作中，会执行几次？ 假设这个蓝图类有一个C++的父类，同样是上面的操作，父类的构造函数会执行几次？ 我分别用输出log的方法输出一些内容，得到的结果很让人困惑。蓝图中的constructor跟真正意义上的构造函数又有不同貌似。然而让我不可思议的是，问题2中得到的结果是两次。拖到场景中生成了一个实例，但是父类的构造函数调用了两次。 要说不可思议问题1的constructor貌似执行了很多次（2次以上）。 8.UE4C++中遇到的一些问题调查1.Pointer to incomplete class type is not allowed在我使用一些组件指针的时候，想要得到组件的名称，使用-&gt;来调用函数的时候就出现了这个问题。 Pointer to incomplete class type is not allowed 上面的链接有解释。 An “incomplete class” is one declared but not defined.E.g. 最终的解决是，好好的把相应的头文件包含进去。不是说可以声明指针就代表这个指针就能调用这个指针代表的类中所有公开函数了。话说，没有好好的包含人家的头文件却能在文件中没问题的声明这个类型的指针，对我来说真是邪门了。UE4真是搞不懂了。 2.C++ Cross Reference即可以解释上面我遇见的问题的原因。包含指针声明不代表编译器能找到指针指向内容的定义。 头文件的交叉引用，我觉得我本来是遇不见的，或者说遇见了也会不屑一顾，不会去使用的。 但是凡事都有例外不是。 基本来说，程序中出现使用交叉引用的话，就是程序设计出现了重大的问题，基本上需要重新设计了。但是我非要用这种交叉引用是有原因的…当然因为我水平不行是最大的原因。 要怎么解决这个问题呢？ C++交叉引用问题 Resolve build errors due to circular dependency amongst classes 上面的两个文章链接，告诉我怎么解决交叉引用的问题。总结来说就是使用Forward Declaration。 我的解决方案就是对于相互引用的两个类A，B。分别置于不同文件A.h,A.cpp,B.h,B.cpp。我们的希望A中包含B的实例，但同时B中包含A的指针引用。 则此时对B来说，我就是在头文件中引用了A的指针，但是不实际使用A的内容（指针调用），于是就在B.h中添加class A的声明，但是不导入A的头文件。在B.cpp中引入A的头文件对指针加以使用。这样编译器就明白我到底在捣鼓什么了。 C++中前置声明的应用与陷阱 上面的文章解释了前置声明的原理，感觉讲的非常好。]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的智能指针]]></title>
    <url>%2FUE4%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[对于内存使用的了解，就不得不了解指针。UE4拥有跟C++类似的智能指针，在这里对虚幻4的智能指针库的内容进行一些总结跟提炼，同时也需要对C++的智能指针进行深入的了解。 UE4的智能指针智能指针并不能使用UPROPERTY()，TSharedRef,TSharedPtr,TWeakPtr等等。 参考链接： Unreal Smart Pointer Library C++的智能指针指针的使用伴随着内存泄漏(memory leak)的问题，可能会发生内存泄漏的情况有： new或者malloc出来的内存因为程序员的疏忽忘记释放 程序运行发生错误(throw)，未能执行内存释放程序 所以不是说只要程序员足够谨慎就能够避免指针造成的内存泄漏的问题。 C++11中的智能指针主要在用的智能指针有：unique_ptr, shared_ptr, weak_ptr。 这3种指针组件就是采用了boost里的智能指针方案。很多有用过boost智能指针的朋友，很容易地就能发现它们之间的关间：|std|boost|功能说明||—-|—-|—-||unique_ptr|scoped_ptr|独占指针对象，并保证指针所指对象生命周期与其一致||shared_ptr|shared_ptr|可共享指针对象，可以赋值给shared_ptr或weak_ptr。指针所指对象在所有的相关联的shared_ptr生命周期结束时结束，是强引用。||weak_ptr|weak_ptr|它不能决定所指对象的生命周期，引用所指对象时，需要lock()成shared_ptr才能使用。| 参考链接： C++11中的智能指针 三种智能指针的特性用法参考链接： C++11及C++14标准的智能指针 weak_ptrstd::weak_ptr是一个很好的解决悬空指针问题的方式。使用原生指针（raw pointers）的话不知道现在所引用的资源是否已经被释放。而使用std::shared_ptr来管理的话，std::weak_ptr只管使用，而不关心资源的使用情况，反正也不管理指向的资源。 因为本身std::weak_ptr并不能直接引用到对象，不会影响对象的自动释放，不会影响对象的引用计数，需要使用lock()来升级到std::shared_ptr来进行操作。 参考资料： C++ weak pointer When is std::weak_ptr useful? 比起直接使用new优先使用std::make_unique和std::make_shared参考链接： Item 21: 比起直接使用new优先使用std::make_unique和std::make_shared]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的函数回调实现]]></title>
    <url>%2FUE4%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%9B%9E%E8%B0%83%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[回调函数的含义，实际上我也不太清楚，搜回调函数得到的关键字有很多：闭包，代理，委托，Wrapper，等等。但有一点我很清楚，这些我都不太懂。 说是在不同的语言中有不同的叫法。其本质上就是一个函数指针，而在汇编层面，就是子程序代码的首地址。每一段编译器先放一个占位符，最后放入实际的值。 上面的话是Unreal用到一些编程技巧里的内容。 1.先理解什么是”函数回调” A “callback” is any function that is called by another function whitch takes the first function as a parameter. A lot of the time, a “callback” is a function that is called when something happens. That something can be called an “event” in programmer-speak. 摘自Stack Overflow： How to explain callbacks in plain english? How are they different from calling one function from another function? 实际的应用场景就类似：类A需要类B做一件事情，类B做完之后需要告知类A已经做完了这件事情，至于告知的具体方法(函数的具体实现)类A并没有事先告诉类B(编译期间)，等类B做完看一下类A留下的便条(绑定的事件)，根据信条里面的内容(函数的具体实现)来通知类A。 用简单的代码来表示CallBack就是： 1234567void A()&#123; printf("B work has done.")&#125;void B( void (A_prt) (void))&#123;&#125; 学了C++的虚函数之后，理解起来就是快 =。= 2.UE4中的函数回调(CallBack)C++中应该有许多种方式的回调，UE C++(UnrealEngine中的C++)则是使用的DELEGATE和EVENT来实现。 关于UE C++的代理，存在着以下的几种方式： 静态的Single-cast Delegates Dynamic Single-cast Delegates 静态的Multi-cast Delegates Dynamic Multi-cast Delegates 这几种代理的实现有什么不同需要后续整理，可以参考： What difference betweens delegates? 有的时候需要很好的利用一下UE4的官方论坛，像是Stack Overflow一样。 Dynamic Multi-cast DelegatesDynamic Multi-cast Delegates是唯一的一种可以和UE4的Blueprint联动的代理实现方式。 Dynamic Multi-cast Delegates的UE C++中的声明12345678910//File: CallbackExample.h//Class: ACallbackExampleDECLARE_DYNAMIC_MULTICAST_DELEGATE(FZeroInputDelegate); //没有参数的声明方法UPROPERTY(BlueprintAssignable, Category="UE C++ Book") //BlueprintAssignable属性使得这个代理在Blueprint中也取得到。 -&gt;此处在真正的工程中不应该写注释，会出编译问题FZeroInputDelegate TheZeroInputDelegate;DECLEAR_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FTwoInputsDelegate, float, FloatVal, int32, IntVal); //两个参数的声明方法UPROPERTY(BlueprintAssignable, Category="UE C++ Book")FTwoInputsDelegate TheTwoInputsDelegate; Tips: 参数最大允许有8个。参数的声明类似上述两个参数的声明，先是类型后是参数名。 参数不同的代理声明只需要将上述的数字换成相应参数的英文就可以，比如说八个参数的情况声明代理的语句就会变成：DELEAR_DYNAMIC_MULTICAST_DELEGATE_EightParams 这样制作的代理，可以在UE的Blueprint中获得到这个代理（似乎是作为Event）并进行实现了。别忘了指定Event与Target。即把这个代理委托给一个类的实例(Instance)。在Blueprint中似乎是以Event而存在的，Blueprint中实现的操作是把这个调用的Event登录到这个代理上去。这样在UE C++中调用这个代理，也会调用Blueprint中的事件，执行这个事件的实现部分。 调用Blueprint中的代理实现1234567// File: CallbackExample.cpp// Class: ACallbackExampleauto ACallbackExample::ExecuteDelegate(const float FloatVal, const int32 IntVal) -&gt; void &#123; TheZeroInputDelegate.Broadcast(); TheTwoInputsDelegate.Broadcast(FloatVal, IntVal);&#125; 官方参考链接： Dynamic Delegates EventsBlueprint Event与Blueprint Function关于事件与函数的区别，没有返回值的被叫做事件，有返回值的叫做函数。是否真实需要验证。在UE C++中可以登录Blueprint的事件，通过给UPROPERTY宏添加属性来完成。话说回来这个是函数，应该使用UFUNCTION宏才对，不知道为什么书上这么说。 用于事件声明的属性有两种，区别的方式是是否在UE C++中有默认的实现。 BlueprintImplementableEvent:没有默认实现 BlueprintNativeEvent:拥有默认实现 Blueprint Event,Blueprint Function在UE C++中的声明12345678910111213141516// File: CallbackExample.h// Class: ACallbackExample// BP EventUFUNCTION(BlueprintImplementableEvent, Category="UE C++ Book")void FloatInputEvent(const float FloatVal);UFUNCTION(BlueprintNativeEvent, Category="UE C++ Book")void VectorInputEvent(const FVector&amp; VecValue);// BP FunctionUFUNCTION(BlueprintImplementableEvent, Category="UE C++ Book")float IntInputFunction(const int32 IntInput);UFUNCTION(BlueprintNativeEvent, Category="UE C++ Book")TArray&lt;float&gt; VecArrayInputFuncion(const TArray&lt;FVector&gt;&amp; VecValues); Event的默认实现12345678910111213141516// File: CallbackExample.cpp// Class: ACallbackExample//static FVector TheVector事先声明的属性auto ACallbackExample::VectorInputEvent_Implementation(const FVector&amp; VecValue)-&gt;void&#123; TheVector = VecValue;&#125;auto ACallbackExample::VecArrayInputFuncion_Implementation(const TArray&lt;FVector&gt;&amp; VecValues)-&gt; TArray&lt;float&gt;&#123; TArray&lt;float&gt; Result; for (const auto&amp; Val : VecValue) Result.Emplace(FVector::Dist(TheVector, Val)); return Result;&#125; 以上的代码实装完成之后，继承了上面的CallbackExample类的Blueprint就可以在Blueprint Editor中对上述UE C++中的事件与函数进行重写了。 以上，是对UE中的代理与事件，在可用范围内的总结与实现。但是对于在什么情况下使用这一点上仍然有许多疑问。 UE C++之间简单的函数回调实现说实话，函数回调跟代理的概念我还是没太理清。在许多的实际应用上，有些操作你叫它代理也行，叫它函数回调也行。用自己的感受就好比是参考系不同一样。就像上面举的函数回调的例子来说： 函数回调就是类A想要在类B在运行中达成某种条件的时候调用类A提供的函数。这个时候类A是主参考系。 代理就是类B在运行中达成某种条件的时候想要通知类A，但是不知道方法，而且觉得这个方法还是由类A决定为好，于是就提供给类A一个纸条(代理)，类A要实现代理内容。这个时候类B就是主参考系了。 我是这样理解的，不知道是否正确。但是在UE4之中delegate的出现比较多，之后就用代理来称呼了。 在Blueprint和AnimationBlueprint中可以很容易的实现代理，利用Blueprint自带的Event Dispatchers就可以快速的实现。函数绑定的时候需要注意的是要Cast正确的对象。 在UE C++实现代理就稍微有些复杂。但还是很简单的。 为什么要使用Delegate和Event？关于代理的实现，就算明白了也需要知道需要在什么情况下使用代理，否则没有意义。 关于Event在UE4中的Blueprint中应没有委托这一说，全部是以Event的名字来称呼的。 Delegate的使用情况推测1面向对象的说法只是一种理想的情况，总会有想要实现别人功能的情况。比如说ClassA想要实现一个功能，但是明显这个功能是由ClassB负责的部分，要是自己来实现的话不好，所以自己的话，声明一个Delegate，想用的时候就把这个广播出去(Broadcast)，实现了这接口的内容会被调用。 只言片语： 现在我要对一系列数据进行排序，而排序算法可能比较复杂，我不会自己写，我想调用Array.Sort方法，微软为我们提供了快速排序算法。但是这里有一个问题——我要实现自定义排序规则，比如对于字符串，默认的是按字母顺序，但现在我想这样排序： 按字符串长度排序，只有当长度不同时，再按字母排序。 显然，微软不可能提供这样“个性”的排序方法，那是不是说，就必须让我们自己去写快速排序算法呢？不需要！我们只需要使用委托，就能实现这个要求：string[]strs=”I like C# very much”.Split();Array.Sort(strs,Rule);int void Rule(string first,string second){return first.Length==second.Length?first.CompareTo(second):first.Length.CompareTo(second.Length);} 显然，我并不需要知道快速排序算法的逻辑，我只需要告之排序规则，就实现了我的个性排序。 试问：如果没有委托，你如何解决这个问题？ C++中的代理实现代理应该涉及了许多知识，完全理解需要后续的更新整理。 参考链接： C++中实现委托（Delegate） C++实现Delegate Event实例(例子、example、sample) C++委托实现(函数指针，function+bind，委托模式) 高效C++委托的原理]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGl学习内容整理]]></title>
    <url>%2FOpenGl%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[主要是记录自己学习OpenGl内容。 OpenGL学习网站参考： Learn OpenGL Learn OpenGL中文翻译]]></content>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UnrealEngine着色器开发整理]]></title>
    <url>%2FUnrealEngine%E7%9D%80%E8%89%B2%E5%99%A8%E5%BC%80%E5%8F%91%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[整理自己在学习Unreal Engine 4着色器过程中遇到的问题和知识点。 Unreal Engine 4设定1. UE4的内置材质Shader函数库位置UE4Shader的编写入门反而相对比较容易，使用自带的各种函数库拉拉线竟然就可以完成。函数库的位置都在: 位置： C:\Program Files\Epic Games\UE_4.19\Engine\Shaders\Private UE4的安装文件夹中 2. Material.cpp文件位置 C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Private\Materials]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的粒子特效]]></title>
    <url>%2FUE4%E4%B8%AD%E7%9A%84%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[主要是用来记录学习虚幻引擎4的粒子的过程 Particles with Unreal Engine 4先是在UE4提供的官方教程中整理基础的知识点。官方Youtube视频。 Particle Particle Particle System Emitter Actor Particle System Component Cascade Emitter Emitter Module tips: 在Emitter(粒子发射器)的各个Module中，按住alt键拖动可以复制Module 按住shift可以共享Module，即只需要修改一个其他的都会被修改 Type Data Distributions]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Particles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于学习UE4的粒子系统过程中遇到的疑问]]></title>
    <url>%2F%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0UE4%E7%9A%84%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E7%96%91%E9%97%AE%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[UE4中需要了解的基础概念]]></title>
    <url>%2Fue4-basic-knowledge%2F</url>
    <content type="text"><![CDATA[为了记录自己在学习UE引擎过程中遇到的一些疑问点。亦或者是一些值得去记录的知识点。 UE4中常见的知识点C++与C#的不同之处时隔多年见到C++的第一个违和感是头文件，为什么需要写头文件这个问题我找了一些别人写的代码发现了一下几个规则： 在C++的头文件中SampleCode.h中一般都会预先定义一些东西 需要包含的其他头文件 123#include "Engine.h"#include "MyAppUtilities.h"... 定义需要使用的宏 预处理（C++的预处理器需要了解一下） 123//一般常量居多？#define PI 3.1415926... 定义类，类中包含该有的成员， 123456789class SampleClass&#123; //Attributes or functions public: protected: private:&#125; UE4中的C++不同的地方1.UCLASS()宏想要让类与UE4的类库联动的话，就需要这个宏。 UCLASS()大概的使用方法Sample Code:12345678910111213141516171819202122#include "Engine.h" //如果需要使用UE的library的话#include "MyAppUtilities.h"UCLASS()class UMyClass : public UObject&#123; GENERATED_BODY() public: //构造函数(公有的？) UMyClass(); UPROPERTY(BlueprintReadWrite, Category = "MyApp") int32 IntProp; UFUNCTION(BlueprintCallable, Category = "MyApp") float LengthOfSomething(const int32 index); private: TArray&lt;int&gt; IntArrayWork; //标准c++中的数组声明 //std::vector&lt;int&gt; IntArrayWork;&#125; 对于UCLASS()，如果需要继承UE的类库，则都要加上这个。最好声明的类名也以U开头为好？ 但是我觉得这种声明不是跟UE的类库搞混了吗，辨识度低我觉得应该没有这么智障的规则。好的，有这种规则好像。类似的其他的以E,F,I,T,S等等的字母作为变量名的开始。 关于在头文件中添加注释的问题，在UE4的执行中倘若添加了日语(应该中文也一样)的注释，有可能会发生问题。所以在头文件中尽可能的使用英文注释。还有应该避免在各种宏的后面直接追加注释。 就目前的问题来说在UFUNCTION宏的后面直接加入日文注释(UTF-8)的话，会有编译无法通过的问题。所以为了避免上述问题应该尽量： 头文件中使用英文注释 不要直接在各种UE4的宏后面(例如UFUNCTION后)直接添加注释。 UCLASS() 参数的含义CPPExampleActor.h123456789101112131415161718192021#pragma once#include "GameFramework/Actor.h"#include "CppExampleStruct.h"#include "CppExampleEnum.h"#include "CpExampleActor.generated.h"UCLASS(BlueprintType)class ACppExampleActor : public AActor&#123; GENERATED_BODY()public: UPROPERTY(BlueprintReadWrite, EdtAnywhere, Category="UE C++ Book") FCppExampleStruct MyStructProp; UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="UE C++ Book") ECppExampleEnum Type; UFUNCTION(BlueprintCallable, Category="UE C++ Book") float MyActorFunc(const float Input);&#125;; 通过指定UNCLASS()的参数，可以指定类的类型。 BlueprintType表示这个类可以作为Blueprint的变量来使用。 UPROPERTY()的声明，在这个Actor的Detail面板上可以看到该Category下有声明的MyStructProp和Type属性。 具体的BlueprintType的使用例子则仍需要调查。BlueprintType类型能做到的事情。 多个参数 1UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) ) 这个的使用含义现在还不清楚各自代表着什么意思。 USTRUCT()结构体CppExampleStruct.h1234567891011121314#pragma once#include "CppExampleStruct.generated.h"USTRUCT(BlueprintType)struct FCppExampleStruct &#123; GENERATED_BODY() UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="UE C++ Book") float Value; UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="UE C++ Book") int32 Index;&#125;; 构造体的声明名字最好以F开始。其他的基本上使用方法与类相同。 UENUM()枚举类型CppExampleEnum.h12345678#pragma onceUENUM(BlueprintType)enum class ECppExampleEnum : uint8 &#123; None = 0, Foo, Bar&#125;; 对于enum class ECppExampleEnum : uint8这种写法有些迷惑。 class是为了使枚举类型更安全。为什么安全，参考下面的链接。之后整理。 uint8是为了指定枚举器的基础类型。 参考链接: C++11的enum class &amp; enum struct和enum C\C++中的整形提升 C++标准文档-n2347 2.GENERAED_BODY()这一句话必须要写的原因需要调查 3.UPROPERTY() UFUNCTION()使用这个声明的属性跟方法UE的Blueprint可以使用。 UPROPERTY()宏UPROPERTY()的参数的含义 UPROPERTY()没有参数的情况，UE4的Blueprint和Level Editor都不能读取或者修改，但是却可以将这个变量纳入到UE4的GC对象中。比如： 12UPROPERTY()AActor* OwningActor; 这种情况，如果OwningActor拥有了实例化对象，不手动释放也是没有问题的。或者说注意别手动释放了，会出问题的。 UPROPERTY(EditAnywhere, Category=&quot;UE C++ Book&quot;,EditAnywhere属性表示在Level Editor中也可以操作这个属性。 那么Blueprint与Level Editor的差别在哪里，需要调查。 猜测的结果，Blueprint就是那个连来连去的蓝图，可以在那个蓝图的编辑器中取到属性。 Level Editor指的是操作的画面，在Level Editor中可以取到的意思应该是在Detail panel中直接设定或者读取值那样。 UPROPERTY(BlueprintReadWrite, Category=&quot;UE C++ Book&quot;),BlueprintReadWrite表示Blueprint可以读写。 其他的属性，还有meta属性可以查找下面的链接： Property Specifiers Metadata SpecifiersUFUNCTION宏12UFUNCTION(BlueprintCallable,Category = "UE C++")static float FunctionName(const float Variable); 像上面的使用方法，在函数的前面添加UNFUNCTION macro宏可以制作UE4的Blueprint编辑器的函数节点以供调用。在虚幻4的Blueprint编辑器中使用此函数。 4.TArray-UE4中的数组（重要）先上本家，官方文档TArray:Arrays in Unreal Engine。 再上中文翻译虚幻引擎中的数组–TArry:Arrays 5.C++中的静态函数static与UE C++(Unreal Engine C++)的静态函数在C++中的静态函数与非静态函数的执行确实是有差别的。 复习一下C++中的静态函数： static修饰变量 static修饰函数参考文章： C/C++ 中的static关键字 存储类 (C++) C++静态成员函数 C++ static静态成员变量 UE C++中关于静态函数的使用应该大同小异，但是也不排除有差别的可能性。 将来可能会派上用场的文章 クラスにスタティック変数を持たせたい 6.Blueprint函数node(节点)的输入与输出在UE C++中函数的参数对应Blueprint的node的输入pin，函数的返回值则对应着node的输出pin12UFUNCTION(BlueprintCallable,Category="classcategory")bool MyFunc(const int a,int b,const int&amp; c,int&amp; d) 上述的情况下a,b,c三个变量对应着node的三个输入pin，但是return value,d对应着node的输出pin。也就是说：没有const修饰的引用型参数会被分配到输出pin的阵营中。 这里便引申出几个问题 UE C++的函数参数为什么要使用const修饰，使用常量的必要性是什么 万一想要使用const修饰的引用型参数作为node的输入pin怎么办 想要增加node的输出pin的话，除此之外还有别的写法么 Blueprint支持的数据类型很有限 bool uint8 int32 float 7.UE4的Head FileUE4中的头文件有许多中，为了能够分清使用方法把遇到的头文件整理一下 Actor.h一般的写法是1#include "GameFramework/Actor.h" 一般是继承了UE4中的Actor类的话都需要包含这个头文件。 xxx.generated.h比如说1#include "CppGate.generated.h" 这个头文件是有UE4的UnrealHeaderTool自动生成的文件。如果类继承了UObject类并且想要在Blueprint中使用这个类的话，就需要include这个头文件。而且需要把这个头文件放到所有的头文件的最后才行。 8.UE4中的特殊容器1.FVector一个表示3D空间的向量。可以用来表示空间的一个点或者方向。 参考链接： FVector 9.类的初始值设定基础类型变量的初始化可以在声明的同时进行，以外的数据类型(FVector等)初始化需要在构造函数中进行。静态变量的初始化则需要在类外进行。123int ClassExample::static_var; //equle 0//or lik thisint ClassExample::static_var = 4; #pragma once vs include guard打开UE工程看到一些.h头文件的源码的时候看到了#pragma once有些困惑，不知道是做什么用的。于是调查了一下。 总体来说这两个命令都是为了避免同一个头文件被include多次 方式1：1234#ifndef __SOMEFILE_H_#define __SOMEFILE_H_...#endif 方式2：12#pragma once... #ifndef方式这种方式受C/C++语言标准支持，可以保证同一个文件不会被同时包含，也能保证内容完全相同的两个文件（或者代码片段）不会被同时包含。缺点是不同头文件中的宏的名字如果相同，会导致编译器找不到声明的问题。另外由于编译器每次需要打开头文件来判定是否有重复的定义，会导致编译的时间要长。 #progma once方式这种方式是保证“物理存在上”同一个文件不会被包含多次。而不是内容相同的两个文件。而且无法对一个头文件中一段代码做pragma once声明，只能针对文件。当然也不会发生第一种方式的宏名碰撞引发的问题。 使用哪一种方式见仁见智，有好处有坏处。根据情况使用。 附上别人的博客链接: #pragma once与#ifndef解析 时间线比较新的分析: インクルードガードとpragma once stackoverflow上关于上述两种方式的争论: #pragma once vs include guards? C++中的类与结构体参考链接： 详解C结构体、C++结构体 和 C++类的区别 开启HSLS语法高亮HLSL Tools for Visual Studio应该是HLSL的语法编辑器插件，有自动补全的功能，附上下载链接。但是并没有解语法高亮的问题。 下载链接： HLSL Tools for Visual Studio 在VS2017中开启语法高亮（syntax high lighting）虽然不是针对VS2017的解决方案，但是设定之后的确解决的这个问题： 设定顺序： 在VS2017中 Go to Tools -&gt; Options -&gt; Text Editor -&gt; Fie Extension 在这里选择编辑文件的扩展名与文法编辑器，然后添加保存。 这样设定应该里面有效果了。 参考链接： How to get syntax highlighting for alternate file extension for Visual Studio 2010 or 2013? UE4中使用的一些Tip1. 快速制作封闭空间快速挖空一个几何体的制作顺序： Modes panel -&gt; Geometry -&gt; Box -&gt; 设置尺寸 Details panel -&gt; Brush settings -&gt; Hollow 属性check 2.调整模型的模型坐标的原点根据模型的大小来调整模型坐标的原点，顺序： 双击UE4中导入的模型，打开材质编辑器(static mesh editor也叫Material Editor) 点击Show Pivot显示模型坐标，同时在左上角看见，模型的大小 在Detail panel中找到Transform，调整Import Tansiation的数值，移动坐标系 Tool bar -&gt; Asset -&gt; Reimport Model 之后就会发现模型坐标按照指示移动了 3.制作天空球(与雾)感觉要制作出天空的感觉同时还有雾的模糊的时候使用，可以看见太阳就是不知道能否模拟太阳的移动 顺序: 选定平行光源，开启Light -&gt; Atmosphere/Sun light 将Visual Effects -&gt; Atmospheric Fog 拖拽至场景中 Content Browser panel右下的View Options中开启Show Engine Content 在Engine Content中找到BP_Sky_Sphere并将其拖拽至场景中 在BP_Sky_Sphere的Details面板中的Directional Light Actor选定上面的平行光 4.UE4中的Volume应用在UE中使用Volume执行不同的任务可以解决很多问题，比如说： 给玩施加伤害 改变物理定律，在Volume中允许玩家悬浮等等 作为碰撞表面，不允许玩家进入 改变计算关卡光照和可见性方式 等等，出了直接使用Modes panel中的Volume工具之外，也可以直接将几何体笔刷(brush)转化为相应的Volume。Details -&gt; Actor -&gt; Convert Actor -&gt; Volume(that you want) 参考资料： Volume Reference 5.Z-FightingZ-Fighting又Depth Fighting，深冲突。就是贴图会出现闪烁的情况，与实际模型产生交叉融合 z-fighting的出现是的不同面上的像素在z-buffer中的值相近，导致前台取像素的时候一会去这个面的，一会取那个面的。改变照相机的near、far属性会涉及到z-buffer中的值的精度。因为在各个平台上z-buffer位数不同，因此改变near和far能给z-buffer中的值的浮点数部分尽量留出空间，消除z-fighting。 参考： z-fighting在unity中的解决方式 6.将选定的Actor合并为组使用Ctrl+G的快捷键可以快速把选定的Actor(场景的素材)合并为一组，下次选定的时候会选定为一组。便于移动或者复制。 使用Shift+G的快捷键会解除分组。当然这些操作都可以在选中Actor之后: Right Click -&gt; Group进行分组和分解 7.UE4中的Material和Material Function在UE4中偶然看到了这两个材质的声明，发现名字不太一样，需要调查一下。 UE C++中的需要注意的问题1.ConstructorHelpers类的使用就我的理解这个类可以在其他类的构造函数中实例化对象。自己的情况中多为获取在工程中的资源，并不是level中的Actor资源而是单纯的Content文件夹中的某个资源。123456789// 使用实例// SampleActorComponent.cpp中的构造函数USampleActorComponent::USampleActorComponent()&#123; PrimaryComponnetTick.bCanEverTick = true; static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; SampleAsset(TEXT("StaticMesh'/Game/StartrContent/Shapes/Shape_Plane.Shape_Plane'")); sample_mesh = SampleAsset.Object;&#125; 这样就能成功取到Content中的资源，当然不限于StaticMesh其他的类型UMaterial等等的类型都可以取到。需要注意的是 ConstructorHelpers类的使用必须是要在类的构造函数中进行（吃了不少苦头） SampleAsset的资源链接可以直接在UE4的Content文件夹右键资源copy reference中直接取到 关于更多的使用应该在另一篇博文中有拓展。 2.在C++类中为类添加用户输入响应在网上搜了一下如何给一个脚本添加键盘输入事件，也不是那么全，有价值的一个提问是这个 Check Keyboard Event in code 但是试了一下并不好用，就自己的理解来说，基本上想要键盘的输入的事件响应的基本上都应该去继承UE4的PawnActor类去了，而我自己就是想用键盘来调试而已。继承的类是ActorComponent，并不能实现他们的代码。后来找了一找还是有实现方法的。 首先要去UE4的Editor中的Project Settings中的input选项中将自己想要绑定的键位命名并登录。我起的名字就是PressedF等等。 然后就是在c++中实现绑定了：12345678910111213141516171819202122232425262728293031323334// SampleActorComponent.cppvoid USampleActorComponent::BeginPlay()&#123; // 因为要绑定一下键位的事件，所以需要在这里写 this-&gt;GetOwner()-&gt;EnableInput(this-&gt;GetWorld()-&gt;GetFirstPlayerController()); UInputComponent * myInputComp = this-&gt;GetOwner()-&gt;InputComponent; if(myInputComp) // check(myInputComp) &#123; SetupMyPlayerInput(myInputComponent); &#125;&#125;void USampeActorComponent::SetupMyPlayerInput(UInputComponent * myInputComponent)&#123; myInputComponent-&gt;BindAction("PressedF", IE_Pressed, this, &amp;USampleActorComponent::PressedMethod);&#125;void USampleActorComponent::PressedMethod()&#123; // 这里是按下键盘键位之后的动作内容&#125;// SampleActorCompoennt.hclass USampleActorComponent : public UActorComponent&#123; GENERATED_BODY()public: UFUNCTINN(BlueprintCallable, Category = "MyUE4Class") void PressedMethod(); // 这个在头文件的声明一定要使用UFUNCTION宏来修饰否则没有作用 void SetupMyPlayerInput(UInputComponent * myInputComponent);&#125; 完整的使用方法大概就是这样，应该有一篇文章介绍的很详细的但是关掉了页面不太好找了。 3.像Unity一样保存场景中的参照在Unity中把scene中的参照直接拖进脚本的声明公共变量以达到快速参照的目的，在UE4中也有类似的用法。123456789class USampleClass : public UActorComponent&#123; GENERATED_BODY()public: USampleClass(); UPROPERTY(EditAnywhere, Category = "Edit") AActor * targrtActor;&#125; 为属性添加UPROPERTY()宏让变量暴露给编辑器，然后在该脚本的Detail面板上wei该变量找到场景中的Actor参照。虽然不能拖拽了。 4.获取Actor上的Component不知道是不是UE4中获取Actor上的组件就这么麻烦还是我没找到，组件的获取并不是那么单纯的事情。12345// 获取名为targetActor身上的脚本组件（TArray&lt;USampleActorComponent*&gt; Comps;targetActor_p-&gt;GetComponents&lt;USampleActorComponent&gt;(Comps);// 这样Comps[0]的内容应该就是想要的组件的参照了 5.在UEC++中实现代理我在现实中都没怎么用到过得代理，我竟然一次用了这么多。在UE4中代理的制作感觉好简单好方便。之前有一个是在C++中声明代理，但是实现是在蓝图中的，叫Multi-Cast-Delegate好像。这次完全是在C++中声明在C++中实现代理。 再来复述一下代理的情况：一个类想要做一件事儿，但是这件事跟这个类的关系是只想知道这件事做了而已，具体做的内容完全不关心，这件事情的实现是另一个类的分工。这个时候只要在自己的类里面声明一个代理，当想要执行的时候通知那个类就行。就像是事件一样。 1.定义代理类型在UE4中引擎为我们做了大部分，而我们只要用就可以了。首先定义代理的类型。1234567891011#include "CoreMinimal.h"#include "SampleDelegateComponent.h" // 我们需要委托的类头文件声明#include "SampleActoomponent.generated.h" // 这个头文件是自动生成的，没有的话要手动补上去就是自己的文件名加上.generated.h，而且这个声明必须要在所有的声明的最后。原因不清楚DECLARE_DELEGATE(SampleDelegate)UCLASS()class USampleActorComponnet : UActorComponent&#123; // Class Contents&#125; 这样我们便声明了一个类型为SampleDelegate的代理了。 2.声明代理12// 在USampleActorComponent中的声明这个该类型的代理变量SampleDelegate sample_delegate; 3.绑定代理用上一条的方法获取到level中的Actor的参照，然后将代理绑定到这个想要代为我们执行的实例上去。123456789// 取得需要绑定的实例参照if(targetActor)&#123; // 获取到实例身上的脚本组件 TArray&lt;USampleDelegateComponent*&gt; Comps; targetActor-&gt;GetComponents&lt;USampleDelegateComponent&gt;(Comps); // 绑定代理 sample_delegate.BindUObject(Comp[0], &amp;USampleDelegateComponent::MethodWanted);&#125; 4.代理执行剩下的就是在想要的时候执行代理就好了。1sample_delegate.Execute(); 6.动态加载资源关于动态加载资源又是能说一箩筐的话题，这次只记录自己用到的。1UTexture2D * sampleTex = LoadObject&lt;UTexture2D&gt;(NULL, TEXT("Texture2D'/Game/Path..'"), NULL, LOAD_None, NULL); 参数啥的也不太清楚，用的时候按照这个方向查吧。之后的关于如何从零开始制作烟雾特效的教程里应该会出现。 7.动态改变物体材质参数关于UE4的材质，有好多的话要说，关于如何动态的改变一个物体材质的问题要是不是自己非要用C++写蓝图，估计也不会钻研的那么深。 首先是要动态的改变一个材质里面的参数需要我们创建一个动态的材质。也就是说我们需要得到场景中的物体的材质的实例参照，然后以这个参照为模板创建一个动态材质，再把这个修改了的动态材质赋给物体。 老规矩，上代码： .h文件1234// Class内，省略大部分框架代码// 头文件中声明材质UMaterial * target_material;UMaterialInstanceDynamic * target_material_dynamic; .cpp文件12345678910111213141516171819202122232425262728// 构造函数中使用ConstructorHelpers获取到物体的材质static ConstructorHelpers::FObjectFinder&lt;UMaterial&gt; targetMT(TEXT("PATH"));target_material = targetMT.Object;// 随后可以在BeginPlay函数中对动态材质进行初始化target_material_dynamic = UMaterialInstanceDynamic::Create(target_material, this-&gt;GetWorld());// 可以为材质中的变量赋值target_material_dynamic-&gt;SetScalarParameterValue("MaterialParaName",10);// 拓展复习~// 获取一个UStaticMesh上的组件的材质TArray&lt;UStaticMeshComponent*&gt;comps;this-&gt;GetOwner()-&gt;GetComponnets&lt;UStaticMeshComponent&gt;(comps);target_material = (UMaterial*)comps[0]-&gt;GetMaterial(0) // 指针类型强制转换这一步很重要// 更新材质结束之后要赋给物体mesh_comp = comps[0]mesh_comp-&gt;SetMaterial(0, target_material_dynamic);// 下面的是比较重要的一步// 在BeginPlay中实例化动态材质之后需要target_material_dynamic-&gt;AddToRoot();// 完后再EndPlay中将动态材质移除target_material_dynamic-&gt;RemoveFromRoot(); 这个也是吃了苦头的，因为自己非要用C++写，不用蓝图，这东西谁都不会告诉我啊。AddToRoot这个操作让UE的GC不会把我们创建的动态材质给回收掉。而使用的AddToRoot的东西在结束或者不想用的时候RemoveFromRoot，以便回收。哎呀没加的时候UE4崩的不要不要的。 8.UE_LOG输出奇奇怪怪的数据类型总是想输出些什么。使用UE_LOG可以在UE4的Editor输出运行的信息。但是C++嘛，你让它输出FString类型的东西，他不认识就不输出这个时候就像下面这样：1UE_LOG(LogTemp, Log, TEXT("output message %s"), *(FDateTime::Now().ToString())); 使用指针强制转换，我也不知道是个什么原理。 9.FTimerManager定时器定时器是个好东西。但是要怎么用呢？ 首先要获取到这个定时器，在世界中有这么一个定时器：12// 为什么要加 &amp; ，引用的作用应该就是我不知道，不加就报错。我也不知道我是怎么灵机一动加上就好用的。FTimeManager &amp;timer = this-&gt;GetOwner()-&gt;GetWorldTimerManager(); 然后声明一个Handle12// 在.h文件中声明一个Timer Handle供我们使用，一个Handle就是一个定时的名字应该FTimerHandle timer_handle; 最后开始定时：1timer.SetTimer(timer_handle, this, &amp;USampleActorComponent::TimerMethodWnted, 1.0, false); 参数的意思应该一目了然了。 UE4知识拓展主要用来记录一些常见但是需要理解的优先级不高或者不太常用的知识点的拓展。 1.Metadata Specifiers在UE4中的宏UFUNCTION()等等中会看到一些meta修饰符，有各自的用处。 Metadata Specifiers CallableWithoutWorldContext想要记录下这个meta的原因是，我想得到当前调用函数所在的Blueprint的名字。在C++中直接使用__Function__写个宏就可以直接得到调用函数的名字，但是在Blueprint中，没有宏当参数这么便利的方法，得顺便把self当参数传进去。 这就导致我想输出蓝图名字的时候，无论如何都得额外做一个把self传进去的操作。 但是有一天我发现，为什么UE4自带的Print函数就没有传这样的参，而且还把调用蓝图的名字输出来了。看代码就知道了。 在下面的源代码中可以找到UE4自带的Print函数声明定义： Engine\Source\Runtime\Engine\Classes\Kismet\KismetSystemLibrary.h Engine\Source\Runtime\Engine\Private\KismetSystemLibrary.cpp 会找到下面的声明：12UFUNCTION(BlueprintCallable, meta=(WorldContext="WorldContextObject", CallableWithoutWorldContext, Keywords = "log print", AdvancedDisplay = "2", DevelopmentOnly), Category="Utilities|String")static void PrintString(UObject* WorldContextObject, const FString&amp; InString = FString(TEXT("Hello")), bool bPrintToScreen = true, bool bPrintToLog = true, FLinearColor TextColor = FLinearColor(0.0, 0.66, 1.0), float Duration = 2.f); 实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869void UKismetSystemLibrary::PrintString(UObject* WorldContextObject, const FString&amp; InString, bool bPrintToScreen, bool bPrintToLog, FLinearColor TextColor, float Duration)&#123;#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST) // Do not Print in Shipping or Test UWorld* World = GEngine-&gt;GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::ReturnNull); FString Prefix; if (World) &#123; if (World-&gt;WorldType == EWorldType::PIE) &#123; switch(World-&gt;GetNetMode()) &#123; case NM_Client: Prefix = FString::Printf(TEXT("Client %d: "), GPlayInEditorID - 1); break; case NM_DedicatedServer: case NM_ListenServer: Prefix = FString::Printf(TEXT("Server: ")); break; case NM_Standalone: break; &#125; &#125; &#125; const FString FinalDisplayString = Prefix + InString; FString FinalLogString = FinalDisplayString; static const FBoolConfigValueHelper DisplayPrintStringSource(TEXT("Kismet"), TEXT("bLogPrintStringSource"), GEngineIni); if (DisplayPrintStringSource) &#123; const FString SourceObjectPrefix = FString::Printf(TEXT("[%s] "), *GetNameSafe(WorldContextObject)); FinalLogString = SourceObjectPrefix + FinalLogString; &#125; if (bPrintToLog) &#123; UE_LOG(LogBlueprintUserMessages, Log, TEXT("%s"), *FinalLogString); APlayerController* PC = (WorldContextObject ? UGameplayStatics::GetPlayerController(WorldContextObject, 0) : NULL); ULocalPlayer* LocalPlayer = (PC ? Cast&lt;ULocalPlayer&gt;(PC-&gt;Player) : NULL); if (LocalPlayer &amp;&amp; LocalPlayer-&gt;ViewportClient &amp;&amp; LocalPlayer-&gt;ViewportClient-&gt;ViewportConsole) &#123; LocalPlayer-&gt;ViewportClient-&gt;ViewportConsole-&gt;OutputText(FinalDisplayString); &#125; &#125; else &#123; UE_LOG(LogBlueprintUserMessages, Verbose, TEXT("%s"), *FinalLogString); &#125; // Also output to the screen, if possible if (bPrintToScreen) &#123; if (GAreScreenMessagesEnabled) &#123; if (GConfig &amp;&amp; Duration &lt; 0) &#123; GConfig-&gt;GetFloat( TEXT("Kismet"), TEXT("PrintStringDuration"), Duration, GEngineIni ); &#125; GEngine-&gt;AddOnScreenDebugMessage((uint64)-1, Duration, TextColor.ToFColor(true), FinalDisplayString); &#125; else &#123; UE_LOG(LogBlueprint, VeryVerbose, TEXT("Screen messages disabled (!GAreScreenMessagesEnabled). Cannot print to screen.")); &#125; &#125;#endif&#125; 重点是下面 WorldContext=”WorldContextObject”, CallableWithoutWorldContext 这部分。 受这个启发，这个让我们可以不用传入额外的参数（self），并且使用GetNameSafe函数得到名字。 顺便一提，Keywords关键字可以设置搜索的关键字。细节上面的官方文档中有。 2.Wildcard 类型Wildcard这个数据类型是UE4的Editor的可以适配所有类型的Pin的类型。 可以用来作为一些宏的Event的类型指定，就像为函数提供一个delegate一样，UE4的蓝图的宏也可以使用类似的特性。 UE4 Blueprintでdelegateを引数で使用する方法 这篇文章的知识点随着时间的推移开始变得有些杂乱了，该考虑一下重新整理文章内容了。 道听途说1.关于C++中的资源释放一般在c++中应该是资源的获取与申请（new等等的操作）与资源的释放都是需要程序员手动操作的。但是如果使用了UE管理的资源，比如继承了UE中的类库等等的操作，那么释放这些资源的操作，在UE中会自动释放而不需要程序员的额外操作，反而要是操作了还会出问题。 当然这个问题只是道听途说，未能够验证。 当然需要仔细调查了啊 2.关于UE中UObject的派生对象的垃圾回收问题如果一个UObject的派生类对象中有一个UObject的派生类对象的指针变量，当这个指针变量经过NewObject&lt;&gt;()的操作实例化了之后，这个实例化对象就成为了GC对象（garbage collection）,但是仅仅如此还不足以达到自动回收的目的，像下面这样在声明之前加上UPROPERTY()宏，就不需要显式的delete垃圾回收了。12UPROPERTY()UObject* MyObjectReference; 总结来说，在C++中使用了new等等的方式来申请了一部分空间的话在使用结束的时候需要显式的释放掉，否则的话就会造成内存泄漏。然而上述的使用方式会使得这样声明的实例对象能够得到的资源自动回收。 参考来源: [Question]UObject Pointer References 关于C++好像发现了一个不得了的链接貌似可以在这个链接中找到C++的标准文档，英文文档。 Open Standards]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#中的单例模式-SingletonPattern]]></title>
    <url>%2FC%23%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-SingletonPattern%2F</url>
    <content type="text"><![CDATA[这次来整理一下C的单例模式，参考的文章是Implementing the Singleton Pattern in C#。 曾经在做一个数据库管理类中经常多次使用了一个数据库管理的实例类对象，每次在新的不相关的类中需要使用数据库操作的时候都重新实例化一个数据库管理类对象，久而久之就觉得有些麻烦。便决定使用单例模式来管理，同时深究一下单例模式与C#中的使用。 算是这篇文章的汉化与总结吧。 –未完–]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Semaphore-信号量]]></title>
    <url>%2FSemaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Semaphore,中文叫信号量，日语叫セマフォ（= .=）。经常会在多线程的编程中用到。信号量说简单点就是为了线程同步，或者说是为了限制线程能运行的数量。 仔细说明一下就是，信号量会在内部维护一个计数器，当一个线程调用了这个信号量，计数器就会减1，直到计数器减为0，调用这个信号量的线程将会被阻塞，直到有别的线程释放掉一个信号量使其计数器加1。 那么问题就来了，这个信号量维护的这个计数器应该是对线程的死锁有所防护的，也就是说同一时间只有一个线程能过获取这个信号量，而且当线程获取信号量的时候对信号量中的计数器进行减操作是具有原子性的操作。对于这个计数器的保存位置应该深入调查一下。 实例代码：12345678910111213141516171819202122232425262728293031323334353637383940414243using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading;namespace Semaphore1&#123; class Program &#123; //我设置一个最大允许5个线程允许的信号量 //并将它的计数器的初始值设为0 //这就是说除了调用该信号量的线程都将被阻塞 static Semaphore semaphore = new Semaphore(0, 5); static void Main(string[] args) &#123; for (int i = 1; i &lt;= 5; i++) &#123; Thread thread = new Thread(new ParameterizedThreadStart(work)); thread.Start(i); &#125; Thread.Sleep(1000); Console.WriteLine(&quot;Main thread over!&quot;); //释放信号量，将初始值设回5，你可以将 //将这个函数看成你给它传的是多少值，计数器 //就会加多少回去，Release()相当于是Release(1) semaphore.Release(5); &#125; static void work(object obj) &#123; semaphore.WaitOne(); Console.WriteLine(&quot;Thread &#123;0&#125; start!&quot;,obj); semaphore.Release(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS真机安装Build出错]]></title>
    <url>%2FiOS%E7%9C%9F%E6%9C%BA%E5%AE%89%E8%A3%85Build%E5%87%BA%E9%94%99%2F</url>
    <content type="text"><![CDATA[为了面试，需要用尽一切手段了，把自己的毕业设计的时候做的2D游戏也拿出来了（捂脸）。找到了自己之前保存好的已经编译好的安装包，希望能够平安无事的安装到自己的系统高版本的iPhone7上。但是再次编译的时候果不其然还是要报错。1'__declspec' attributes are not enabled; use '-fdeclspec' or '-fms-extensions' to enable support for __declspec attributes 但是无论是Xcode还是Unity都已经升级的面目全非了，打开以前保存的Unity工程果不其然各种报错。想要解决出现的问题，第一个是NGUI的版本问题，代码中出现的一部分说是已经不支持Unity5.4+了…上网搜了一下，结果没有找到任何解答。 第一下就碰壁，只能再回去找已经编译好的文件的Build错误了。 问题解决继续搜关键词，看到了Unity社区中有一个这个提问：Error “unknown type name __declspec” after Xcode 7.3 upgrade 出问题的代码部分跟我的是一样的:1234567NORETURN static void il2cpp_codegen_raise_exception (Il2CppCodeGenException *ex)&#123; il2cpp::vm::Exception::Raise ((Il2CppException*)ex);#if __has_builtin(__builtin_unreachable) __builtin_unreachable();#endif&#125; 当然我是根本不知道这几行代码到底是干什么的。但是就是出错了…继续往下看，好像看到了一个解决方案: It has helped me: 1) Remove ‘NORETURN’2) Clean build3) Build it Like a hack:) XCode7.3, Unity5.2.2 UPD: XCode7.3, Unity5.3.4f1 - no issue 跟我的情况太像了，抱着试一试的态度，然后…Build通过了，游戏也成功的安装到了我的手机上了。 で？这个NORETURN到底是个什么？ 查了一下发现这个属性不光是Swift中的，C++中也有。所以说我已经厌倦了什么都学，什么都学对自己来说就是什么都学不会。自己之前一段时间看了Swift然后又去干别的，妥妥的全部忘光。 noreturn in Swiftnoreturn是一种属性，被这个属性修饰的函数表示没有任何返回值，函数可以被重写，但是重写之后也必须没有返回值。 具有代表性的函数有：exit(),abort()等等。 这里有一篇介绍Swift的Attributes的文章Swift - Attributes(@attribute) について 【編集中】介绍了Swift中的修饰属性。 noreturn in C++相比之下我更在意noreturn在C++中的作用。试着查了一下What is the point of noreturn? 字面意思看起来是:不返回函数的结果，没有返回值。但实际上跟void funtion还是有很大的区别。 void function运行会返回调用函数，只不过没有返回值。 被noreturn修饰的函数在运行结束之后并不会返回调用函数。 12345678910[[ noreturn ]] void f() &#123; throw "error"; // OK&#125;void g() &#123; f(); // unreachable: 在调用了`f()`之后，下面的代码永远不会执行 std::cout &lt;&lt; "No! That's impossible" &lt;&lt; std::endl;&#125; 别的事情不说，每次发现这种有关语言的语法的地方不明白的时候，就觉得特别打脸。]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>Bugs</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zsh找不到gulp工具包]]></title>
    <url>%2Fzsh%E6%89%BE%E4%B8%8D%E5%88%B0gulp%E5%B7%A5%E5%85%B7%E5%8C%85%2F</url>
    <content type="text"><![CDATA[不能上网，一上网问题就接踵而来。今天突然看到了hexo博文压缩这个功能，就想着这个可以有，就按照教程安装了gult。安装完运行hexo g &amp;&amp; gulp之后准备舒舒服服的打包的时候，我一向视同己出的zsh弹出来了这个提示1zsh: command not found: gulp 刚装的你跟我说找不到？我信了你的邪。 自己解决应该是有点难度了，只能借用大家的智慧了。在网上搜到了这两篇博文COMMAND NOT FOUNDWITH A NODE MODULE (NPM) SOLUTION与【gulp】zsh: command not found: gulp!!!「急にgulpが壊れた!」と思ったら読む記事完美的解决了我的问题。 原因可以从下面的命令中看出来 1234➜ blog npm root/Users/stone/Documents/mynote/BLOG/blog/node_modules➜ blog npm root -g/Users/stone/node_modules gulp被安装到了个人文件夹中去而不是NPM命令的全局文件夹。 解决办法是运行下面的命令1npm config set prefix /usr/local 再运行一次npm root -g应该就会看到执行后的结果变化12➜ blog npm root -g/usr/local/lib/node_modules 然后再次安装gulp，应该是全局的安装1npm i -g gulp 确认gulp的版本123➜ blog gulp -v[23:25:50] CLI version 3.9.1[23:25:50] Local version 3.9.1 出现了一个CLI版本跟一个本地的版本。嘛，反正是好用了。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown文件转换为PDF文件]]></title>
    <url>%2FMarkdown%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E4%B8%BAPDF%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近闲来无事(实际上由于跳槽面试的原因忙的要死)，在知乎上看到了一篇搭建博客的文章，看了一眼发现对于我这种WEB盲还挺友好，于是就自己搭建了这个博客。 就在ZH上捞鱼捞的正爽的时候，面试(未)公司发来了要看看我的作品的消息。我一看表现的时候到了，就掏出我刚学的Markdown来写了几篇我的作品的说明文。正当我想把刚build好的html文件打包压缩发送过去的时候，(自动脑补柯南的灵光一闪音效)我发觉事情并不是这么简单。 要是我作死直接发了一堆html过去，估计就别想见到人家了，就算见到了人家公司的HR，估计见面也有不小的概率会被锤。这个时候慌乱的我,手不由自主的打开了谷歌并输入了:How to convert markdown to pdf.然后发现正确的提问用法是:How to convert from markdown to pdf. (；´∀｀)嘛，英语不好这得批评，早晚得去考一次托福… 搜到的第一个是说用谷歌上的插件:Markdown Preview Plus - Chrome Webstore.ドラッグアンドドロップ就可以转换了。什么？ドラ…什么的，打开谷歌翻译:drag and drop.我… 但是利用网上的插件总感觉有些难受，还要上传文件什么的，万一上传到人家服务器上被人家看到了里面的内容就不好了(WEB盲)。于是看到了第二个方法：使用Node.js的工具markdown-pdf 1npm -g install markdown-pdf 安装好工具之后 1markdown-pdf 我的说明文.md 就能生成想要的PDF文件了。浏览生成的PDF文件的时候唯一在意的就是Markdown给隐藏起来的URL链接PDF文件也一并显示了出来。难不成是制作人有意这样，亦或者是机关在作祟，我就暂时不得而知了。因为现在的我得等人家的面试通知。 唉…寝よう]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Markdown</tag>
        <tag>碎碎念</tag>
      </tags>
  </entry>
</search>
