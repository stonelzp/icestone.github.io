<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/stonelzp.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/stonelzp.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/stonelzp.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/stonelzp.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/stonelzp.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/stonelzp.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/stonelzp.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="UE4,ActionRPG,">










<meta name="description" content="这次是UE4的学习，要学习如何在UE4中制作动作游戏，在UE4官方放出来的案例中Action RPG这个案例里面包含了大量有用的知识点，这篇文章就是就这个案例进行学习整理。">
<meta name="keywords" content="UE4,ActionRPG">
<meta property="og:type" content="article">
<meta property="og:title" content="UE4-GameplayAbilitySystem学习">
<meta property="og:url" content="http://stonelzp.github.io/ue4-gameplay-ability-system/index.html">
<meta property="og:site_name" content="StoneのBLOG">
<meta property="og:description" content="这次是UE4的学习，要学习如何在UE4中制作动作游戏，在UE4官方放出来的案例中Action RPG这个案例里面包含了大量有用的知识点，这篇文章就是就这个案例进行学习整理。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://stonelzp.github.io/ue4-gameplay-ability-system/ListenForAttributeChange.PNG">
<meta property="og:image" content="http://stonelzp.github.io/ue4-gameplay-ability-system/WaitDelay.png">
<meta property="og:image" content="http://stonelzp.github.io/ue4-gameplay-ability-system/TaskWaitDelay.png">
<meta property="og:updated_time" content="2020-11-05T12:52:41.756Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="UE4-GameplayAbilitySystem学习">
<meta name="twitter:description" content="这次是UE4的学习，要学习如何在UE4中制作动作游戏，在UE4官方放出来的案例中Action RPG这个案例里面包含了大量有用的知识点，这篇文章就是就这个案例进行学习整理。">
<meta name="twitter:image" content="http://stonelzp.github.io/ue4-gameplay-ability-system/ListenForAttributeChange.PNG">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/stonelzp.github.io/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://stonelzp.github.io/ue4-gameplay-ability-system/">





  <title>UE4-GameplayAbilitySystem学习 | StoneのBLOG</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/stonelzp.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">StoneのBLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">生活这种事情，从来都是自我陶醉</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/stonelzp.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/stonelzp.github.io/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/stonelzp.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/stonelzp.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/stonelzp.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stonelzp.github.io/stonelzp.github.io/ue4-gameplay-ability-system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="stone">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/stonelzp.github.io/uploads/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StoneのBLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">UE4-GameplayAbilitySystem学习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-05T12:27:01+09:00">
                2020-06-05
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-11-05T21:52:41+09:00">
                2020-11-05
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/stonelzp.github.io/categories/Unreal-Engine/" itemprop="url" rel="index">
                    <span itemprop="name">Unreal Engine</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>这次是UE4的学习，要学习如何在UE4中制作动作游戏，在UE4官方放出来的案例中<strong>Action RPG</strong>这个案例里面包含了大量有用的知识点，这篇文章就是就这个案例进行学习整理。</p>
<a id="more"></a>
<p>这里涉及到一个相当大的概念，<strong>GamePlay</strong>，这个应该是UE4模式的游戏架构，理解的话需要花费很多精力，大量的名词我都闻所未闻，只能一点点的啃了。</p>
<h1 id="GamePlay-Guide"><a href="#GamePlay-Guide" class="headerlink" title="GamePlay Guide"></a>GamePlay Guide</h1><p>这是官网的标题，暂时我不会整理，先从别的部分一点点入手</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Gameplay/index.html" target="_blank" rel="noopener">Gameplay Guide-Overviews and examples of gameplay functionality for programmers and visual scripters.</a></li>
</ul>
<p>UE4官网的文章都是有中文的，但是还是放着吧，机翻翻译的我不知所云。</p>
<h2 id="Gameplay-Ability-System"><a href="#Gameplay-Ability-System" class="headerlink" title="Gameplay Ability System"></a>Gameplay Ability System</h2><p>官网上对于GAS的介绍，也是这篇文章要搞明白的部分。</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Gameplay/GameplayAbilitySystem/index.html" target="_blank" rel="noopener">Gameplay Ability System-High-level view of the Gameplay Ability System</a></li>
</ul>
<h1 id="ActionRPG"><a href="#ActionRPG" class="headerlink" title="ActionRPG"></a>ActionRPG</h1><p>这里我要逐步理解GAS的组成，剖析这个项目的源码。</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Resources/SampleGames/ARPG/index.html" target="_blank" rel="noopener">Action RPG Game - A sample game that shows how to use the Ability System plugin.</a></li>
</ul>
<h2 id="ActionRPG内容分析"><a href="#ActionRPG内容分析" class="headerlink" title="ActionRPG内容分析"></a>ActionRPG内容分析</h2><h2 id="ActionRPG练习"><a href="#ActionRPG练习" class="headerlink" title="ActionRPG练习"></a>ActionRPG练习</h2><p>这一部分的内容是针对ActionRPG源码的练习，同时也是在公司练手的时候的练习。旨在熟悉GAS的使用。</p>
<p>下一章节的<em>GameplayAbilities and you</em>中是对PlayerInput和Ability进行了绑定，而大多数情况我觉得用到的可能性很小。但是作为熟悉GAS的使用是足够了。下一步是对使用GameplayAbility作为事件的Trigger进行介绍。</p>
<h1 id="GameplayAbilities-and-you"><a href="#GameplayAbilities-and-you" class="headerlink" title="GameplayAbilities and you"></a>GameplayAbilities and you</h1><p>这是一篇本应在UnrealEngineforums上的文章，但是不知道为什么页面被关闭了，但是我找到了GitHub上有人转载了</p>
<ul>
<li><a href="https://github.com/michaeltchapman/MCGameplayAbilities/wiki/GameplayAbilities-and-You" target="_blank" rel="noopener">GameplayAbilities and you</a></li>
</ul>
<p>这是一篇相当晦涩难懂的文章，当然也包含了全是英文这个原因，但是也总好于上面的ActionRPG只有一个工程，其他的啥也没有的要好。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>关于GameplayAbility(一下简称GA)，在这篇文章或者官网中有介绍，或者上面的部分有提到这里不再赘述。</p>
<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>所以让我直接开始正题，如何一步一步按照文章的步骤来初步理解GA的。</p>
<h3 id="Setting-up-the-Project"><a href="#Setting-up-the-Project" class="headerlink" title="Setting up the Project"></a>Setting up the Project</h3><p>第一步是建立我们的项目，首先我是使用的UE4.25版本，创建了一个完全空白的项目。这里文章中要求的是让我们导入<strong>C++ Third persion</strong>，就是那个第三人称的控制器。而在这里我遇见了一个挑战。</p>
<p>如何导入第三人称控制器。由于我创建的是初始的空白项目。</p>
<p>ContentBrows -&gt; Add New -&gt; Add Feature or Content Pack to the Project -&gt; C++ Feature -&gt; Third Person</p>
<p>就这样导入项目了，但是下一个问题又来了，导入项目的ThirdPerson编译错误。</p>
<p>绕了一大圈，最终发现是在项目源码的Build.cs中缺少了<strong>HeadMountedDisplay</strong>这个Module。至于为什么会缺少这个module的原因我猜测是</p>
<ul>
<li>BlankProject确实是没有这个Module的</li>
<li>在我禁用SteamVRPlugin的时候自动给我删除掉了</li>
</ul>
<p>当然我还是觉得第一种可能性是比较大的，而我也没想到这个第三人称的控制器需要用到VR相关的Module。最后的调整，编译无错的版本是这样的：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PublicDependencyModuleNames.AddRange(<span class="keyword">new</span> <span class="keyword">string</span>[] &#123; <span class="string">"Core"</span>, <span class="string">"CoreUObject"</span>, <span class="string">"Engine"</span>, <span class="string">"InputCore"</span>, <span class="string">"HeadMountedDisplay"</span> &#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="创建第一个GamePlayAbility-blueprint"><a href="#创建第一个GamePlayAbility-blueprint" class="headerlink" title="创建第一个GamePlayAbility blueprint"></a>创建第一个GamePlayAbility blueprint</h4><p>这个就是创建一个GA蓝图，继承GameplayAbility蓝图类，这一步超级简单，然后打开创建的蓝图，会看到ActivateAbility的节点，在后面添加一个print节点，打印HelloWorld。</p>
<h3 id="Setting-up-our-Charactor"><a href="#Setting-up-our-Charactor" class="headerlink" title="Setting up our Charactor"></a>Setting up our Charactor</h3><p>哦对，在我们建立项目之后应该启用<strong>GameplayAbilityPlugin</strong>，以便于我们在项目中引用它。</p>
<p>在我们的Build.cs中添加GameplayAbility的Module，最终的感觉像这样：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PublicDependencyModuleNames.AddRange(<span class="keyword">new</span> <span class="keyword">string</span>[] &#123; <span class="string">"Core"</span>, <span class="string">"CoreUObject"</span>, <span class="string">"Engine"</span>, <span class="string">"InputCore"</span>, <span class="string">"HeadMountedDisplay"</span>, <span class="string">"GameplayAbilities"</span> &#125;);</span><br></pre></td></tr></table></figure></p>
<p>找到第三人称控制器的源码，我们将在源码中添加一些修饰。我自己的项目则是<strong>TP_ThirdPersonCharacter.h</strong>文件。</p>
<p>首先我们要为Charactor添加AbilitySystemComponent组件，在别的地方应该也有提到，这个组件是Actor必须的，非常关键的，对于GameplayAbilitySystem来说。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Camera boom positioning the camera behind the character */</span></span><br><span class="line">UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = <span class="string">"true"</span>)) <span class="class"><span class="keyword">class</span> <span class="title">USpringArmComponent</span>* <span class="title">CameraBoom</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Follow camera */</span> UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = <span class="string">"true"</span>)) <span class="class"><span class="keyword">class</span> <span class="title">UCameraComponent</span>* <span class="title">FollowCamera</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Our ability system */</span> UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Abilities, meta = (AllowPrivateAccess = <span class="string">"true"</span>)) <span class="class"><span class="keyword">class</span> <span class="title">UAbilitySystemComponent</span>* <span class="title">AbilitySystem</span>;</span></span><br></pre></td></tr></table></figure>
<p>因为我添加的代码跟文章中的差不多，所以直接复制粘贴了。</p>
<p>这之后，也是非常重要的，我们需要继承<code>IAbilitySystemInterface</code>接口并实现里面的方法。</p>
<blockquote>
<p>This interface here gives other actors an easy way to both know we have an ability system, and a way to get it without doing something dumb and inefficient like iterating through our components for an ability system.</p>
</blockquote>
<p>AbilitySystem貌似就是通过这个接口来确定Actor的AbilitySystem能否正常工作。实现的效果像这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"AbilitySystemInterface.h"</span> <span class="comment">//We add this include 别忘了添加头文件</span></span></span><br><span class="line">UCLASS(config=Game) <span class="class"><span class="keyword">class</span> <span class="title">AGameplayAbilitiesTutCharacter</span> :</span> <span class="keyword">public</span> ACharacter, <span class="keyword">public</span> IAbilitySystemInterface <span class="comment">//We add this parent.继承接口</span></span><br><span class="line"></span><br><span class="line"><span class="function">UAbilitySystemComponent* <span class="title">GetAbilitySystemComponent</span><span class="params">()</span> <span class="keyword">const</span> override <span class="comment">//We add this function, overriding it from IAbilitySystemInterface. 接口的方法实现</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> AbilitySystem; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>之后我们需要对AbilitySystemComponnent进行创建，在头文件中只是声明了一下。实现的就像这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TP_ThirdPersonCharacter.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"AbilitySystemComponent.h"</span></span></span><br><span class="line"><span class="comment">// 省略了与文章无关的头文件</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// ATP_ThirdPersonCharacter</span></span><br><span class="line"></span><br><span class="line">ATP_ThirdPersonCharacter::ATP_ThirdPersonCharacter()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 省略一些源码</span></span><br><span class="line">    <span class="comment">// Create a follow camera</span></span><br><span class="line">    FollowCamera = CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT(<span class="string">"FollowCamera"</span>));</span><br><span class="line">    FollowCamera-&gt;SetupAttachment(CameraBoom, USpringArmComponent::SocketName); <span class="comment">// Attach the camera to the end of the boom and let the boom adjust to match the controller orientation</span></span><br><span class="line">    FollowCamera-&gt;bUsePawnControlRotation = <span class="literal">false</span>; <span class="comment">// Camera does not rotate relative to arm</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Our ability system component 创建组件</span></span><br><span class="line">    AbilitySystem = CreateDefaultSubobject&lt;UAbilitySystemComponent&gt;(TEXT(<span class="string">"AbilitySystem"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: The skeletal mesh and anim blueprint references on the Mesh component (inherited from Character) </span></span><br><span class="line">    <span class="comment">// are set in the derived blueprint asset named MyCharacter (to avoid direct content references in C++)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Once you have compiled, you can open your character blueprint(which inherits from your C++ character) and lo and behold, right under the character’s movement component you should see an AbilitySystemComponent.</p>
</blockquote>
<p>就像上面说的那样，当你编译之后就能在Map中的第三人称控制器的蓝图中找到我们创建的AbilitySystemComponent组件。</p>
<p>So far so good.</p>
<p>但是目前为止，我们还有很长的路。现在我们什么都没实现。</p>
<blockquote>
<p>That’s because the ability system doesn’t have any abilities to activate yet, nor does it have any inputs assigned to them, anyway, so trying to activate an ability you do not have is, obviously, a quite useless effort. We will work on fixing both things. You must do both things in C++.</p>
</blockquote>
<p>上面这句话有两个：</p>
<ul>
<li>需要一个ability去激活ability system</li>
<li>需要绑定输入(inputs)到它们身上</li>
</ul>
<h3 id="Binding-to-Character-input"><a href="#Binding-to-Character-input" class="headerlink" title="Binding to Character input"></a>Binding to Character input</h3><p>首先，我们需要将我们的AbilitySystem绑定到Character’s input。我们想把我们的abilitysystem绑定到UInputComponent上。</p>
<blockquote>
<p>We want to call AbilitySystem-&gt;BindAbilityActivationToInputComponent within the SetupPlayerInputComponent. It takes two parameters: The UInputComponent pointer at hand and a struct called FGameplayAbiliyInputBinds. This is not a typo! It is not called FGameplayAbilityInputBinds, but FGameplayAbiliyInputBinds!</p>
</blockquote>
<p>所以说FGameplayAbiliyInputBinds是什么？注意这里我还真拼错了一次。</p>
<blockquote>
<p>The constructor for FGameplayAbiliyInputBinds takes at least 3 parameters: The first two are strings, and represent the input names that will be used to define “Confirm” and “Cancel”-input commands. You do not necessarily need these depending on your game, but abilities can be set up to listen to these while they’re active, and targeting actors (basically, actors that return an ability viable targets/locations to aim at for an ability, if an ability requests one) will use these too, so generally it can’t hurt to have these even if you will never use them. The third parameter is the name of an arbitrary UEnum of all things. This is one of the witchcraft-ier aspects of the system: <strong>The ability system component will look into the enum whose name you’ve given and will map its ability slots to the names of the elements contained within the enum</strong>.</p>
</blockquote>
<p>顾名思义，应该就是负责存储对应Ability和键位映射的结构数据或者中间数据，FGameplayAbiliyInputBinds的构造函数至少有三个参数，前两个参数是字符串，代表着定义”Confirm”和”Cancel”两个输入命令(input commands)的输入名字。根据游戏的需要可能这并不是必须的。</p>
<p>这里我没怎么明白这前两个参数的具体意思，文章中说的<em>abilities can be set up to listen to these while they’re active, and targeting actors (basically, actors that return an ability viable targets/locations to aim at for an ability, if an ability requests one) will use these too</em>这里我也不是非常清楚，谁是谁，说的是谁我都不知道。</p>
<p>第三个参数是一个自定义的UENUM枚举，他说这里是这个GAS的神奇的地方，而我只觉得想骂人。</p>
<p>AbilitySystemComponent会取出自定义的枚举类型的名字，然后映射他的<strong>ability slots</strong>到这个枚举类型中所包含的名字上。下面是这个自定义枚举的举例实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Example for an enum the FGameplayAbiliyInputBinds may use to map input to ability slots.</span></span><br><span class="line"><span class="comment">//It's very important that this enum is UENUM, because the code will look for UENUM by the given name and crash if the UENUM can't be found. BlueprintType is there so we can use these in blueprints, too. Just in case. Can be neat to define ability packages.</span></span><br><span class="line">UENUM(BlueprintType) <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">AbilityInput</span> :</span> uint8</span><br><span class="line">&#123;</span><br><span class="line">    UseAbility1 UMETA(DisplayName = "Use Spell 1"), //This maps the first ability(input ID should be 0 in int) to the action mapping(which you define in the project settings) by the name of "UseAbility1". "Use Spell 1" is the blueprint name of the element.</span><br><span class="line">    UseAbility2 UMETA(DisplayName = "Use Spell 2"), //Maps ability 2(input ID 1) to action mapping UseAbility2. "Use Spell 2" is mostly used for when the enum is a blueprint variable.</span><br><span class="line">    UseAbility3 UMETA(DisplayName = "Use Spell 3"),</span><br><span class="line">    UseAbility4 UMETA(DisplayName = "Use Spell 4"),</span><br><span class="line">    WeaponAbility UMETA(DisplayName = "Use Weapon"), //This finally maps the fifth ability(here designated to be your weaponability, or auto-attack, or whatever) to action mapping "WeaponAbility".</span><br><span class="line"></span><br><span class="line">    <span class="comment">//You may also do something like define an enum element name that is not actually mapped to an input, for example if you have a passive ability that isn't supposed to have an input. This isn't usually necessary though as you usually grant abilities via input ID,</span></span><br><span class="line">    <span class="comment">//which can be negative while enums cannot. In fact, a constant called "INDEX_NONE" exists for the exact purpose of rendering an input as unavailable, and it's simply defined as -1.</span></span><br><span class="line">    <span class="comment">//Because abilities are granted by input ID, which is an int, you may use enum elements to describe the ID anyway however, because enums are fancily dressed up ints.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我直接复制粘贴了。将上面的Enum实现放到头文件，然后回到cpp文件中对键位进行绑定。</p>
<p>回到Cpp文件中的<code>SetupPlayerInputComponent</code>函数中,用户输入键位进行绑定。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbilitySystem-&gt;BindAbilityActivationToInputComponent(PlayerInputComponent, FGameplayAbiliyInputBinds(<span class="string">"ConfirmInput"</span>, <span class="string">"CancelInput"</span>, <span class="string">"AbilityInput"</span>));</span><br></pre></td></tr></table></figure></p>
<p>所以到这一步为止，如果编译没有出错误的话，我们已经成功的将<strong>ability system’s sbility activation</strong>()绑定到了用户输入(player input)上。</p>
<h3 id="Giving-the-Character-an-Ability"><a href="#Giving-the-Character-an-Ability" class="headerlink" title="Giving the Character an Ability"></a>Giving the Character an Ability</h3><p>最后一步是给我们的AbilitySystem一个Ability，就如已经预备好的一样，我们要将这个Ability放到已经映射到PlayerInput的第一个ability slot上。</p>
<p>这里使用了蓝图的一个类似Unity的Inspector中拖拽搞定Reference的功能，我之前也有实现过，只不过拖拽是不支持的，可以在下拉菜单中选择自己定义好的蓝图而已，而这里则是选择我们一开始创建的那个GameplayAbility蓝图。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Abilities)</span><br><span class="line">TSubclassOf&lt;<span class="class"><span class="keyword">class</span> <span class="title">UGameplayAbility</span>&gt; <span class="title">Ability</span>;</span></span><br></pre></td></tr></table></figure>
<p>随后我们将在BeginPlay中调用AbilitySystem的GiveAbility函数，看名字就知道是干什么得了。但是需要注意的是我们必须，或者说只能在Server端执行Ability的赋予，这里应该是GAS的要求或者说实现，因为GAS是支持多人通信的系统，就文章所说如果在Client中赋予Ability的话，会崩溃，UE4和你都会崩溃（这是我加的）。</p>
<p>GiveAbility需要一个FGameplayAbilitySpec作为参数，FGameplayAbilitySpec是围绕着GameplayAbility的数据（类型），包含着level和input ID。</p>
<blockquote>
<p>GiveAbility requests an FGameplayAbilitySpec as parameters. An FGameplayAbilitySpec is the data surrounding a GameplayAbility, notably which level (the system has built-in support for a level variable, quite good for RPGs/MOBAs as mentioned) and which input ID it is.</p>
</blockquote>
<ul>
<li>level: 系统已经内置的关卡变量，对RPGs/MOBAs类的游戏非常友好。也就是关卡的标志，或许我以后会经常用到。</li>
<li>input ID: 这里终于跟上面连起来了，那个自定义的ENUM已经跟我们的AbilitySystem的AbilitySlots进行了绑定，这个Input ID则是可以对AbilitySlot进行指定（这是目前为止自己的理解）</li>
</ul>
<p>FGameplayAbilitySpec需要一个GameplayAbility对象作为参数，我们可以使用Ability的默认对象（class’s default object），就文章的作者而已：</p>
<blockquote>
<p>There is very little reason to use anything other than the default object of a GameplayAbility class as far as I’ve understood it from going through the source. </p>
</blockquote>
<p>关于默认对象的描述贴一段来自官网的内容：</p>
<blockquote>
<p><a href="https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Objects/index.html" target="_blank" rel="noopener">Objects</a></p>
<p>The UCLASS Macro</p>
<p>The UCLASS macro gives the UObject a reference to a UCLASS that describes its Unreal-based type. Each UCLASS maintains one Object called the ‘Class Default Object’, or CDO for short. The CDO is essentially a default ‘template’ Object, generated by the class constructor and unmodified thereafter. Both the UCLASS and the CDO can be retrieved for a given Object instance, though they should generally be considered read-only. The UCLASS for an Object instance can be accessed at any time using the GetClass() function.</p>
</blockquote>
<p>我们还要调用<strong>AbilitySystem-&gt;InitAbilityActorInfo</strong>函数，来告诉AbilitySystem谁是Owner谁是Avatar。</p>
<blockquote>
<p>Finally, while on the topic of BeginPlay, we should also call AbilitySystem-&gt;InitAbilityActorInfo. It tells the AbilitySystem what its Owner (the actor responsible for the AbilitySystem) and Avatar (the actor through which the AbilitySystem acts, uses Abilities from etc.) is. In our case our character is both.</p>
</blockquote>
<ul>
<li>Owner: AbilitySystem的持有Actor</li>
<li>Avatar:使用这个AbilitySystem的Ability的Actor？这里我不是太明白。</li>
</ul>
<p>BeginPlay中的实现效果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BeginPlay</span><span class="params">()</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="keyword">void</span> ATP_ThirdPersonCharacter::BeginPlay()</span><br><span class="line">&#123;</span><br><span class="line">    Super::BeginPlay();</span><br><span class="line">    <span class="keyword">if</span> (AbilitySystem) &#123;</span><br><span class="line">    <span class="keyword">if</span> (HasAuthority() &amp;&amp; Ability) &#123;</span><br><span class="line">    AbilitySystem-&gt;GiveAbility(FGameplayAbilitySpec(Ability.GetDefaultObject(), <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    AbilitySystem-&gt;InitAbilityActorInfo(<span class="keyword">this</span>,<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有需要注意的是，我们必须要保证每当controller改变的时候，AbilitySystemComponent’s ActorInfo struct的内容被更新。这里贴上原作者的话:</p>
<blockquote>
<p>You also need to make sure that the AbilitySystemComponent’s ActorInfo struct is being updated each time the controller changes. On the surface much of the system will work without that, but in a multiplayer enviroment especially(where pawns may be spawned before the client controller possesses them) you will experience crashes and behaviour that can be difficult to debug should you not properly set the ActorInfo up.</p>
</blockquote>
<p>这里有我不太明白的地方，就下面的源码来看这个Controller指的是哪个Controller我都不知道，这里是知识盲区。实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PossessedBy</span><span class="params">(AController * NewController)</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="keyword">void</span> AGameplayAbilitiesTutCharacter::PossessedBy(AController * NewController)</span><br><span class="line">&#123;</span><br><span class="line">   Super::PossessedBy(NewController);</span><br><span class="line">   AbilitySystem-&gt;RefreshAbilityActorInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里扫一下盲，关于PossessedBy函数的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pawn.h</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Called when this Pawn is possessed. Only called on the server (or in standalone).</span></span><br><span class="line"><span class="comment">    * @param NewController The controller possessing this pawn</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PossessedBy</span><span class="params">(AController* NewController)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>以上都编译好了之后，还有两步，一是把我们一开始创建好的GameplayAbility蓝图（输出HelloWorld）指定到我们预备好的AbilitySlot上。</p>
<p>在打开的Map中找到我们使用的第三人称控制器（ThirdPersonCharacter），在它的Details面板使用我们设置的Category-Abilities检索，便会找到我们准备好的AbilitySlot1，在这里我们指定我们制作的打印HelloWorld的GameplayAbility蓝图。</p>
<p>第二步是指定PlayerInput的映射，我们已经把Ability映射到了PlayerInput上了，但是没有指定哪一个Ability到哪一个键位，这个时候回想起那个我们制作的不知道干什么的UENUM枚举类型。</p>
<p>去Edit-&gt;Project Settings中找到Input，添加Action Mappings。</p>
<p>添加一个新的<strong>Action Mappings</strong>，名字指定为”UseAbility1”,这个名字跟你声明的Enum枚举类型里定义的变量名对应，注意是变量名字。然后指定键位，我这里指定的是Enter键。</p>
<p>好了以上就是我跟着做的过程的全部内容，运行游戏，然后按下Enter键，就会发现左上角打印出了HelloWorld！。</p>
<p>虽然只能触发一次。</p>
<p>这里文章还提到如果出现了问题，比如说UE4崩溃，或者AbilityActor is invalid之类的错误的话提供下面的解决方案：</p>
<blockquote>
<p>Note that if it crashes and spits out an error message talking about AbilityActorInfo being invalid, try adding this code just before the HasAuthority() check and seeing if it fixes the problem:</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FGameplayAbilityActorInfo* ActorInfo = <span class="keyword">new</span> FGameplayAbilityActorInfo();</span><br><span class="line">ActorInfo-&gt;InitFromActor(<span class="keyword">this</span>, <span class="keyword">this</span>, AbilitySystem); AbilitySystem-&gt;AbilityActorInfo = TSharedPtr&lt;FGameplayAbilityActorInfo&gt;(actorInfo);</span><br></pre></td></tr></table></figure>
<p>然后我们枯燥的部分终于告一段落了。</p>
<h2 id="The-Essentials-要点"><a href="#The-Essentials-要点" class="headerlink" title="The Essentials (要点)"></a>The Essentials (要点)</h2><p>在解决了漫长的Setup设置之后，是对GAS的各种基础概念进行认知。但是这篇文章从现在开始的部分真的对我来说是晦涩难懂，每一句话太长了，让我陷入了不会英语的自责。。。</p>
<p>我只能一点点的理解。</p>
<p>这个章节是对GAS中的一些要点，关键概念进行总结和理解。</p>
<h3 id="GameplayAbilities"><a href="#GameplayAbilities" class="headerlink" title="GameplayAbilities"></a>GameplayAbilities</h3><h3 id="GameplayTasks"><a href="#GameplayTasks" class="headerlink" title="GameplayTasks"></a>GameplayTasks</h3><h3 id="GameplayEffects"><a href="#GameplayEffects" class="headerlink" title="GameplayEffects"></a>GameplayEffects</h3><h3 id="AttributeSet"><a href="#AttributeSet" class="headerlink" title="AttributeSet"></a>AttributeSet</h3><p>这里我先跨过前面的部分直接说AttributeSet。其实我是大概的看完了这个部分，然后又看了下面的文章才更新的这部分的内容的。</p>
<ul>
<li><a href="https://forums.unrealengine.com/community/community-content-tools-and-tutorials/116578-comprehensive-gameplayabilities-analysis-series" target="_blank" rel="noopener">Comprehensive GameplayAbilities Analysis Series</a></li>
</ul>
<p>这篇文章对AttributeSet的内容讲解的稍微深了些，或者说配合代码讲解，本应是很好理解的，但是我只理解了一半。有时间，或者再加深一些理解之后再来总结这篇文章吧。</p>
<h1 id="GASDocumentation"><a href="#GASDocumentation" class="headerlink" title="GASDocumentation"></a>GASDocumentation</h1><ul>
<li><a href="https://github.com/tranek/GASDocumentation" target="_blank" rel="noopener">GASDocumentation</a></li>
</ul>
<p>这是一个完整的关于GameplayAbilitySystem的框架的使用文章，这里面包含了很多的知识，也吃掉了我许多时间，实在是理解GAS的一个非常好非常重要的文章。</p>
<p>由于理解本身就已经非常费时费力，当然更多的是自己的摸鱼和工作不力，但还是希望能好好理解UE4这个框架</p>
<h2 id="GASDocumentation的个人翻译和理解"><a href="#GASDocumentation的个人翻译和理解" class="headerlink" title="GASDocumentation的个人翻译和理解"></a>GASDocumentation的个人翻译和理解</h2><p>在这里我准备把这个GitHub的文章的一些重要部分进行翻译和整理，当然不是全部，还有对其中的实现做一些记录。</p>
<h3 id="Intro-to-the-GameplayAbilitySystem-Plugin"><a href="#Intro-to-the-GameplayAbilitySystem-Plugin" class="headerlink" title="Intro to the GameplayAbilitySystem Plugin"></a>Intro to the GameplayAbilitySystem Plugin</h3><p>官网上的说明跳过不说，我自己的理解就是，GAS这个系统是为RPG和MOBA类游戏打造的框架，里面包含了升级啊角色技能冷却啊之类的要素的开箱即用的功能，即包装好的功能。由于在这个框架中实现了许多Multiplay的内容，相较于自己重新构建，学习使用这个框架的成本更低一些，嘛代价就是不能彻底理解UE4的多人游戏网络框架了。</p>
<p>但是有得必有失。由于GAS已经内置于UE4的源码中了，所以直接拿来用就好了。如果有不满的地方，那么之后再考虑如何对其进行扩展。</p>
<p>关于UE4中关于GAS提供的功能，在这篇文章中是这样形容的：</p>
<blockquote>
<p>The plugin provides an out-of-the-box solution in single and multiplayer games for:</p>
<ul>
<li>Implementing level-based character abilities or skills with optional costs and cooldowns (GameplayAbilities)</li>
<li>Manipulating numerical Attributes belonging to actors (Attributes)</li>
<li>Applying status effects to actors (GameplayEffects)</li>
<li>Applying GameplayTags to actors (GameplayTags)</li>
<li>Spawning visual or sound effects (GameplayCues)</li>
<li>Replication of everything mentioned above</li>
</ul>
</blockquote>
<p>在我整理这篇文章的时候已经对这篇文章和这个项目的源码进行了大致的理解和实现，所以对于不知所云的地方会加上一些标注。</p>
<p>GAS提供的一些开箱即用的功能有（包含单人和多人游戏）：</p>
<ul>
<li>基于等级的能力和技能的实现带有一些数值的消耗或者冷却时间，即GameplayAbility</li>
<li>操纵Actor的数值属性，即Attribute</li>
<li>应用一些“影响”到Actor当前的状态上，即GameplayEffect</li>
<li>将GameplayTags应用到Actor上，即一些GameplayTag的使用</li>
<li>生成一些特效或音效，即GameplayCue</li>
<li>上述提到的内容的状态复制，即Replication</li>
</ul>
<blockquote>
<p>In multiplayer games, GAS provides support for client-side prediction of:</p>
<ul>
<li>Ability activation</li>
<li>Playing animation montages</li>
<li>Changes to Attributes</li>
<li>Applying GameplayTags</li>
<li>Spawning GameplayCues</li>
<li>Movement via RootMotionSource functions connected to the CharacterMovementComponent.</li>
</ul>
</blockquote>
<p>关于GAS的一些高级特性，就是某种程度上提供了<strong>客户端本地预测</strong>。</p>
<ul>
<li>Ability的激活</li>
<li>Animation Montage的播放</li>
<li>Attribute的变动</li>
<li>应用GameplayTag</li>
<li>生成GameplayCue</li>
<li><span style="color: red; ">Movement via RootMotionSource functions connected to the CharacterMovementComponent.</span></li>
</ul>
<p>最后一个特性是我没有遇见过的也是没有验证过的，也不知道该怎么翻译</p>
<blockquote>
<p>Current issues with GAS:</p>
<ul>
<li>GameplayEffect latency reconciliation (can’t predict ability cooldowns resulting in players with higher latencies having lower rate of fire for low cooldown abilities compared to players with lower latencies).</li>
<li>Cannot predict the removal of GameplayEffects. We can however predict adding GameplayEffects with the inverse effects, effectively removing them. This is not always appropriate or feasible and still remains an issue.</li>
<li>Lack of boilerplate templates, multiplayer examples, and documentation. Hopefully this helps with that!</li>
</ul>
</blockquote>
<p>目前GAS上仍然需要解决的问题是以下几个问题：</p>
<ul>
<li>GameplayEffect latency reconciliation, 我也不知道该怎么翻译这个，按照描述时所说就是ability的colldown无法本地预测导致了拥有高延迟的本地玩家相较于低延迟的玩家拥有更低的开火率，这在GameplayEffect章节中会再提及。</li>
<li>不能预测GameplayEffect的移除。虽然可以预测性的添加具有相反效果的GE来完成看似删除的效果，但是这不是总是可行的，仍然是一个问题。</li>
<li>确实样例模板和文档。（跟GAS相关的文档就少到离谱，而且大多还是英文，而事实上这篇文章帮了我很多很多）</li>
</ul>
<p>但是最详尽的文档就是UE4的源码了…</p>
<h3 id="Setting-Up-a-Project-Using-GAS"><a href="#Setting-Up-a-Project-Using-GAS" class="headerlink" title="Setting Up a Project Using GAS"></a>Setting Up a Project Using GAS</h3><blockquote>
<ol>
<li>Enable GameplayAbilitySystem plugin in the Editor</li>
<li>Edit YourProjectName.Build.cs to add “GameplayAbilities”, “GameplayTags”, “GameplayTasks” to your PrivateDependencyModuleNames</li>
<li>Refresh/Regenerate your Visual Studio project files</li>
<li>Starting with 4.24, it is now mandatory to call UAbilitySystemGlobals::InitGlobalData() to use TargetData. The Sample Project does this in UEngineSubsystem::Initialize(). See InitGlobalData() for more information.</li>
</ol>
</blockquote>
<p>前几条就是常规操作了，但是最后一条，在使用了<strong>TargetData</strong>之后，不要忘记调用<code>UAbilitySystemGlobals::InitGlobalData()</code>，这个部分我还没有验证过。</p>
<h3 id="AbilitySystemComponent"><a href="#AbilitySystemComponent" class="headerlink" title="AbilitySystemComponent"></a>AbilitySystemComponent</h3><p><code>AbilitySystemComponent</code>简称ACS，是GAS的自内脏，嘛就是中心，控制着GAS中的所有的交互。如果想要让一个Actor拥有<strong>Attributes</strong>，或者能够使用<strong>GameplayAbilities</strong>，那么对于Actor来说都需要一个ACS。我们可以选择直接使用或者继承它自己定义新的Component。</p>
<p>ACS所依附(AttachTo)的Actor一般名义上就是这个ASC的<strong>OwnerActor</strong>。而ACS的实际上的物理使用者Actor则被称为<strong>AvatarActor</strong>。(这里文章所说的<em>PhysicalRepresentationActor</em>我不知道该如何翻译)一般情况下这两者都会是相同的Acotr(MOBA游戏中的简单的AI控制单位AI minion等等)。他们也有可能是不同的Actor，比如说MOBA游戏中玩家控制的Hero角色，OwnerActor是PlayerState，AvatarActor则是Hero的Character类来担任。</p>
<p>大多数情况下Actor都会自己持有ASC，除非是想要Respawn这个Actor而且想要持续的保持Actor中的属性状态，就像是MOBA游戏中的Hero的属性，这个时候我们第一个想到的就是将ASC放到PlayerState上。</p>
<blockquote>
<p>If your Actor will respawn and need persistence of Attributes or GameplayEffects between spawns (like a hero in a MOBA), then the ideal location for the ASC is on the PlayerState.</p>
</blockquote>
<p>需要注意的是：</p>
<ol>
<li>如果设置了ASC到PlayerState上了，要记着调整<code>NetUpdateFrequency</code>的值。默认的值很低，使用默认值的话，Client上可能会有很高的延迟感，相对于Attributes和GameplayTag的使用来说。<ul>
<li>记得开启<code>AdaptiveNetworkUpdateFrequency</code>选项。Fortnite使用了这个。</li>
</ul>
</li>
<li><p>想要使用ASC的时候一定要继承实现<code>IAbilitySystemInterface</code>,如果是上述的那种OwnerActor和AvatarActor不同的情况下（也就是PlayerState拥有真正的ASC实例，Character只是ASC的指针的时候）对于两个Actor来说，都需要继承该接口并对其进行实现。</p>
<ul>
<li><code>UAbilitySystemComponent* GetAbilitySystemComponent() const</code>进行实现</li>
<li>ASCs interact with each other internally to the system by looking for this interface function.ASC之间的交互貌似会用到这个接口，其他情况下不太清楚。</li>
</ul>
</li>
<li><p>ASC中有一个变量<code>FActiveGameplayEffectsContainer ActiveGameplayEffects</code>用来保存目前active状态的GameplayEffects</p>
</li>
<li>ASC中有一个变量<code>GameplayAbilitySpecContainer ActivatableAbilities</code>用来保存所有生成的GameplayAbilities。<ul>
<li>这里的<em>granted Gameplay Abilities</em>的翻译可能不是很准确。</li>
<li>如果需要遍历<code>ActivatableAbilities.Items这个List的时候，一定要在之前加上</code>ABILITYLIST_SCOPE_LOCK();`来防止在循环的时候内容被修改(removing a ability是被修改的原因)。</li>
<li>在scope中的时候<code>AbilityScopeLockCount</code>会加算，scope运行结束之后会减去。</li>
<li>不要尝试在<code>ABILITYLIST_SCOPE_LOCK();</code>中移除ability(the clear ability functions check AbilityScopeLockCount internally to prevent removing abilities if the list is locked)</li>
</ul>
</li>
</ol>
<h4 id="Replication-Mode"><a href="#Replication-Mode" class="headerlink" title="Replication Mode"></a>Replication Mode</h4><p>ASC为<code>GameplayEffects</code>,<code>GameplayTags</code>,<code>GameplayCues</code>提供了三种不同的复制模式(Replication Mode)，<code>Full</code>,<code>Mixed</code>,<code>Minimal</code>。<br><code>Attributes</code>的Replication是由<code>AttributeSet</code>负责的。</p>
<table>
<thead>
<tr>
<th>Replication Mode</th>
<th>When to Use</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Full</code></td>
<td>SinglePlayer</td>
<td>每一个<code>GameplayEffect</code>都会被复制(replicated)到每一个对应的客户端上。</td>
</tr>
<tr>
<td><code>Mixed</code></td>
<td>Multiplayer,<br> player controlled Actors</td>
<td><code>GameplayEffect</code>只会被复制到自己的<strong>OwningClient</strong>上。只有<code>GameplayTags</code>和<code>GameplayCues</code>会被复制到每一个对应的客户端上。</td>
</tr>
<tr>
<td><code>Minimal</code></td>
<td>Multiplayer,<br>AI controlled Actors</td>
<td><code>GameplayEffect</code>不会被复制到任何客户端的连接。只有<code>GameplayTags</code>和<code>GameplayCues</code>会被复制到每一个对应的客户端上。</td>
</tr>
</tbody>
</table>
<p>Note：这里需要注意的是，设置为<code>Mixed</code>模式的时候，ASC的<code>OwnerActor&#39;s</code> <code>Owner</code>需要是<code>Controller</code>。<code>PlayerState</code>的<code>Owner</code>默认就是<code>Controller</code>，而使用<code>Character</code>的情况下就不是，需要我们调用<code>SetOwner()</code>函数手动设置一个有效的<code>Controller</code>。</p>
<p>从UE4的4.24版本开始，<code>Pawn</code>的<code>PossessedBy()</code>函数会设置<code>Owner</code>的新<code>Controller</code>。</p>
<p>出于好奇，调查了一下<code>SetOwner()</code>函数，发现这个是<code>AActor</code>的函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Set the owner of this Actor, used primarily for network replication. </span></span><br><span class="line"><span class="comment">     * @param NewOwner The Actor who takes over ownership of this Actor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UFUNCTION(BlueprintCallable, Category=Actor)</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetOwner</span><span class="params">( AActor* NewOwner )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the owner of this Actor, used primarily for network replication. */</span></span><br><span class="line">    UFUNCTION(BlueprintCallable, Category=Actor)</span><br><span class="line">    <span class="function">AActor* <span class="title">GetOwner</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>貌似Actor的Owner都需要正确的设置才能被Replicated。</p>
<h4 id="Setup-and-Initialization"><a href="#Setup-and-Initialization" class="headerlink" title="Setup and Initialization"></a>Setup and Initialization</h4><p>ACS一般情况下都需要在<code>OwnerActor</code>的构造函数中创建，而且需要被标记为<strong>Replicated</strong>。这一步只能在C++中完成。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AGDPlayerState::AGDPlayerState()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create ability system component, and set it to be explicitly replicated</span></span><br><span class="line">    AbilitySystemComponent = CreateDefaultSubobject&lt;UGDAbilitySystemComponent&gt;(TEXT(<span class="string">"AbilitySystemComponent"</span>));</span><br><span class="line">    AbilitySystemComponent-&gt;SetIsReplicated(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ASC需要初始化它<strong>Server/Client</strong>的<code>OwnerActor</code>和<code>AvatarActor</code>，这一步可以在<code>Pawn</code>的<code>Controller</code>被设置(possession)的时候执行。单人游戏的话就只需要担心Server端就行了。</p>
<p>据作者的习惯，当把ASC放在玩家控制的Pawn的时候，我们可以在Server的<code>Pawn&#39;s</code> <code>PossessedBy()</code>中初始化，Client端在<code>PlayerController&#39;s</code> <code>AcknowledgePossession()</code>中初始化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> APACharacterBase::PossessedBy(AController * NewController)</span><br><span class="line">&#123;</span><br><span class="line">    Super::PossessedBy(NewController);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (AbilitySystemComponent)</span><br><span class="line">    &#123;</span><br><span class="line">            AbilitySystemComponent-&gt;InitAbilityActorInfo(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ASC MixedMode replication requires that the ASC Owner's Owner be the Controller.</span></span><br><span class="line">    SetOwner(NewController);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> APAPlayerControllerBase::AcknowledgePossession(APawn* P)</span><br><span class="line">&#123;</span><br><span class="line">    Super::AcknowledgePossession(P);</span><br><span class="line"></span><br><span class="line">    APACharacterBase* CharacterBase = Cast&lt;APACharacterBase&gt;(P);</span><br><span class="line">    <span class="keyword">if</span> (CharacterBase)</span><br><span class="line">    &#123;</span><br><span class="line">            CharacterBase-&gt;GetAbilitySystemComponent()-&gt;InitAbilityActorInfo(CharacterBase, CharacterBase);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们把ASC放到玩家控制的<code>PlayerState</code>上的时候，Server端还是一样放到<code>Pawn&#39;s</code> <code>PossessedBy()</code>中初始化，而Client端在<code>Pawn&#39;s</code> <code>OnRep_PlayerState()</code>中初始化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Server only</span></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::PossessedBy(AController * NewController)</span><br><span class="line">&#123;</span><br><span class="line">    Super::PossessedBy(NewController);</span><br><span class="line"></span><br><span class="line">    AGDPlayerState* PS = GetPlayerState&lt;AGDPlayerState&gt;();</span><br><span class="line">    <span class="keyword">if</span> (PS)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// Set the ASC on the Server. Clients do this in OnRep_PlayerState()</span></span><br><span class="line">            AbilitySystemComponent = Cast&lt;UGDAbilitySystemComponent&gt;(PS-&gt;GetAbilitySystemComponent());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// AI won't have PlayerControllers so we can init again here just to be sure. No harm in initing twice for heroes that have PlayerControllers.</span></span><br><span class="line">            PS-&gt;GetAbilitySystemComponent()-&gt;InitAbilityActorInfo(PS, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client only</span></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::OnRep_PlayerState()</span><br><span class="line">&#123;</span><br><span class="line">    Super::OnRep_PlayerState();</span><br><span class="line"></span><br><span class="line">    AGDPlayerState* PS = GetPlayerState&lt;AGDPlayerState&gt;();</span><br><span class="line">    <span class="keyword">if</span> (PS)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// Set the ASC for clients. Server does this in PossessedBy.</span></span><br><span class="line">            AbilitySystemComponent = Cast&lt;UGDAbilitySystemComponent&gt;(PS-&gt;GetAbilitySystemComponent());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Init ASC Actor Info for clients. Server will init its ASC when it possesses a new Actor.</span></span><br><span class="line">            AbilitySystemComponent-&gt;InitAbilityActorInfo(PS, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果出现了<code>LogAbilitySystem: Warning: Can&#39;t activate LocalOnly or LocalPredicted ability %s when not local!</code>这样的警告消息，意味着ASC没有在Client端完成<code>OwnerActor</code>和<code>AvatarActor</code>的初始设定。</p>
<p><strong>Tips:</strong> <br><br>这里在ASC到底是放在PlayerState还是Character上的问题上，就我自身遇到的情况来看，</p>
<p>当ASC放在PlayerState上的时候，即ASC的OwnerActor是PlayerState，优点是可以省略一些Controller的设置操作。但是我遇到的是需要对ASC中的属性进行Replicated的时候，由于PlayerState本身默认的<code>NetUpdateFrequency</code>的值很低(听来的)，更新不频繁就会使得属性的Replication变得很迟缓，故而会有问题。</p>
<p>调整PlayerState的属性网络更新频率也是一种方法，但是跟Character的情况就多了一些操作。</p>
<h3 id="Gameplay-Tags"><a href="#Gameplay-Tags" class="headerlink" title="Gameplay Tags"></a>Gameplay Tags</h3><p><code>FGameplayTags</code>是一种层级式的命名方式，就像<code>Parent.Child.Grandchild...</code>这样，被登记在<code>GameplayTagManager</code>里面。据作者所说，<code>GameplayTags</code>非常的有用，有的时候会在程序的逻辑中使用一些<code>booleans</code>或者枚举，这些可以用<code>GameplayTags</code>来替代。</p>
<p>通常我们是向ASC中添加一个<code>Tag</code>，以便于和<strong>GAS</strong>的交互。<code>UAbilitySystemComponent</code>实现了<code>IGameplayTagAssetInterface</code>接口，这个接口提供了访问自己的<code>GameplayTags</code>的函数。</p>
<p>多个<code>GameplayTags</code>可以使用<code>FGameplayTagContainer</code>来存储，相比于常规的<code>TArray&lt;FGameplayTag&gt;</code>，前者更加有效率(efficiency magic)。Tags是标准的<code>FName</code>类型，在<code>FGameplayTagContainer</code>中存储可以非常效率的打包方便<strong>Replication</strong>。前提是开启了ProjectSetting中的<code>Fast Replication</code>功能。<code>Fast Replication</code>要求Server和Client拥有相同的<code>GameplayTags</code>的列表(list)，一般情况下这不是问题，所以应该开启这个功能。</p>
<p><code>GameplayTagontainer</code>也可以返回一个<code>TArray&lt;FGameplayTag&gt;</code>方便我们遍历。</p>
<p>存储在<code>FGameplayTagCountContainer</code>的<code>GameplayTags</code>有一个<code>TagMap</code>被用来存储<code>GameplayTag</code>的实例(Instance)的数量。一个<code>FGameplayTagCountContainer</code>也许会存在某个<code>GameplayTag</code>，但是它的<code>TagMapCount</code>的值是<code>0</code>，这也许会在调试的时候遇到这种情况，可能明明已经移除了这个GameplayTag(encounter)，但是ASC仍然持有这个<code>GameplayTag</code>。</p>
<p>使用<code>HasTag()</code>或者<code>HasMatchingTag()</code>之类相似的函数，会检查<code>TagMapCount</code>的值，当该<code>GameplayTag</code>不存在亦或者<code>TagMapCount</code>的值为0的时候返回false。</p>
<p>使用<strong>GameplayTag</strong>的时候，一定要在<code>DefaultGameplayTags.ini</code>中提前定义。（个人经验就是用了没有定义过的GameplayTags之后会发生不太好的事情）成为直接在配置文件中定义GameplayTag之外，还可以利用UE4Editor提供的接口界面，</p>
<p>此处应有GameplayTag的编辑界面图片。</p>
<blockquote>
<p>Searching for GameplayTag references will bring up the familiar Reference Viewer graph in the Editor showing all the assets that reference the GameplayTag. This will not however show any C++ classes that reference the GameplayTag.<br>这句话的意思没有完全理解，在尝试对<code>GameplayTag</code>的Reference进行搜索的时候，使用那个<strong>ReferenceViewer</strong>，会表示与之相关的资产(Assets)，但是不会显示任何与C++类相关联的资产。</p>
</blockquote>
<p>这句话让我联想到了如果一大堆素材与这个GameplayTag相关联的话，是不是都会被加载到内存里面，无论它是不是会用到。至于C++中使用这个GameplayTag的话是不是就相对安全一些？看来在制作的过程中，勤奋的确认ReferenceView的内容是必要的啊。</p>
<p>对GameplayTag进行重命名(Rename)会产生一个重定向(redirect)以便于其所关联的资产能够重定向到新的GameplayTag上。据作者所说，可能的话还是新建一个GameplayTag，然后手动调整资产连接到新的GameplayTag上，然后删掉旧的GameplayTag，最好还是避免创建重定向(redirect)资源。我也认为既然重命名是一个会创建资源的操作的话还是避免为好。</p>
<p>除了<code>Fast Replication</code>之外，<code>GameplayTag</code> editor还有一个可以更加深度优化<code>GameplayTag</code>的<code>Replicated</code>的选项。</p>
<p>由<code>GameplayEffect</code>添加的GameplayTag会Replicated。ASC还允许添加不会Replicated的<code>LooseGameplayTags</code>，它必须手动的进行管理。该项目就使用了<code>State.Dead</code>作为<code>LooseGameplayTag</code>，以便于当玩家的HP降到0的时候OwningClient能够立马做出反应。Respawning的时候再手动的将这个Tag的<code>TagMapCount</code>置为0。当使用<code>LooseGameplayTag</code>的时候，只能手动的去调整<code>TagMapCount</code>的值。</p>
<p>这里推荐<code>UAbilitySystemComponent::AddLooseGameplayTag()</code>和<code>UAbilitySystemComponent::RemoveLooseGameplayTag()</code>函数，它们应该会自动调整<code>TagMapCount</code>的值，使用这个函数应该不用真的去对TagMapCount的值进行操作。</p>
<p>在C++中获取一个GameplayTag的Reference的方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FGameplayTag::RequestGameplayTag(FName(<span class="string">"Your.GameplayTag.Name"</span>))</span><br></pre></td></tr></table></figure></p>
<p><code>GameplayTagManager</code>还提供了一些GameplayTag的高级用法，比如获取一个GameplayTag的Parent和Children。添加<code>GameplayTagManager.h</code>头文件以便于使用其功能。<code>UGameplayTagManager::Get().FunctionName</code>这样调用，实际上GameplayTagManager就是用这种类似节点(relational node)的方式(parent,child,etc)来存储GameplayTag，方便用来进行类似字符串的合并对比操作。</p>
<p>GameplayTag和GameplayTagContainer有一个可选的<code>UPROPERTY()</code>属性修饰符(specifier)，<code>Meta = (Categories = &quot;GameplayCue&quot;)</code>，可以用来在Blueprint中筛选表示ParentNode是<code>GameplayCue</code>的标签。当你知道这些GameplayTag和GameplayTagContainer仅在<code>GameplayCue</code>中使用的时候这个修饰符会很有用。</p>
<p>除此之外还有一个<code>FGameplayCueTag</code>的结构体，它对GameplayTag做了些制约(猜测是只有Parent是GameplayCue的Tag)，它会自动的过滤在Blueprint中仅显示GameplayCue为父节点的标签。</p>
<p>同理，如果想在函数里面过滤GameplayTag，使用<code>UFUNCTION()</code>的修饰符<code>Meta = (GameplayTagFilter = &quot;GameplayCue&quot;)</code>。但是GameplayTagContainer就不行了，想要它也适用则需要对引擎做些修改。</p>
<blockquote>
<p>If you would like to edit your engine to allow this, look at how <code>SGameplayTagGraphPin::ParseDefaultValueData()</code> from <code>Engine\Plugins\Editor\GameplayTagsEditor\Source\GameplayTagsEditor\Private\SGameplayTagGraphPin.cpp</code> calls <code>FilterString = UGameplayTagsManager::Get().GetCategoriesMetaFromField(PinStructType);</code> and passes <code>FilterString</code> to <code>SGameplayTagWidget</code> in <code>SGameplayTagGraphPin::GetListContent().</code> The <code>GameplayTagContainer</code> version of these functions in <code>Engine\Plugins\Editor\GameplayTagsEditor\Source\GameplayTagsEditor\Private\SGameplayTagContainerGraphPin.cpp</code> do not check for the meta field properties and pass along the filter.</p>
</blockquote>
<p>这涉及具体操作了我看太懂，直接复制过来了。</p>
<h4 id="GameplayTag有变动的函数回调"><a href="#GameplayTag有变动的函数回调" class="headerlink" title="GameplayTag有变动的函数回调"></a>GameplayTag有变动的函数回调</h4><p>ASC提供了GameplayTag的<strong>Add/Remove</strong>操作的Delegate，这个Delegate需要一个<code>EGameplayTagEventType</code>类型的参数，只有当GameplayTag由于Add/Remove等操作使得<code>GameplayTag&#39;s</code> <code>TagMapCount</code>的值被修改的时候，这个代理会被执行(fire)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;RegisterGameplayTagEvent(FGameplayTag::RequestGameplayTag(FName(<span class="string">"State.Debuff.Stun"</span>)), EGameplayTagEventType::NewOrRemove).AddUObject(<span class="keyword">this</span>, &amp;AGDPlayerState::StunTagChanged);</span><br></pre></td></tr></table></figure></p>
<p>回调函数有该GameplayTag和新的<code>TagCount</code>值作为参数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">StunTagChanged</span><span class="params">(<span class="keyword">const</span> FGameplayTag CallbackTag, int32 NewCount)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h3><h4 id="Attribute-定义"><a href="#Attribute-定义" class="headerlink" title="Attribute 定义"></a>Attribute 定义</h4><p><code>Attributes</code>是由<code>FGameplayAttributeData</code>结构体定义的<strong>float values</strong>。他可以表示游戏中的任何数值类的能力，像HP，MP，玩家等级之类的。游戏设计中如果<code>Actor</code>有什么数值相关的属性能力，都可以考虑用<code>Attributes</code>来实现。<br><br><code>Attributes</code>的修改一般情况下都应该由<code>GameplayEffects</code>来执行，这样方便ASC预测这些修改(predict the changes)。<br></p>
<p>关于GAS的一些预测(prodict)功能，也是很重要的内容，会在以后进行验证。<br><span style="color:blue">此处应该有FGameplayAttributeData结构体的源码截图。</span></p>
<p><code>Attributes</code>是由<code>AttributeSet</code>来定义和保持的，同时也负责着<code>Attributes</code>的Replication。</p>
<p><span style="color:blue">此处应该有AttributeSet的源码截图</span></p>
<p><strong>Tips</strong> :<br><br>可以使用<code>Meta = (HideInDetailsVies)</code>属性修饰符来隐藏<code>Attributes</code>,使其不会出现在UE4Editor的列表中。</p>
<h4 id="BaseValue-vs-CurrentValue"><a href="#BaseValue-vs-CurrentValue" class="headerlink" title="BaseValue vs CurrentValue"></a>BaseValue vs CurrentValue</h4><p>一个<code>Attribute</code>是由两个值组成的，<code>BaseValue</code>和<code>CurrentValue</code>。</p>
<ul>
<li><code>BaseValue</code> : 代表着Attribute永久变更的值(the permanent value)，相对于<code>CurrentValue</code>而言。</li>
<li><code>CurrentValue</code> : 代表着Attribute的<code>BaseValue</code>加上来自<code>GameplayEffect</code>的临时变更的值。</li>
</ul>
<p>举个栗子就是玩家的移动速度是1m/s，那么此时BaseValue和CurrentValue的值都是1m/s。但是当我们给玩家一个加速效果(GameplayEffect)，玩家的移动速度变成了1.1m/s，此时BaseValue是1m/s，而CurrentValue的值是(1+0.1=)1.1m/s。当加速效果结束，BaseValue和CurrentValue的值都回到了1m/s。</p>
<p>这里需要注意的是BaseValue经常会被误认为是Attribute的最大值，而我最开始确实是这样误解的，其实不是。某个属性的最大值比如说HP等，同样也是Attribute的一种，也是需要BaseValue和CurrentValue。</p>
<p>对于Attribute的最大值最小值进行硬编码的问题，UE4提供了一种<code>DataTable</code>，使用<code>FAttributeMetaData</code>来设置。但是据源码的评论内容来看这个Struct仍然是WIP状态。只有期待后续的更新了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* DataTable that allows us to define meta data about attributes. Still a work in progress.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GAMEPLAYABILITIES_API</span> <span class="title">FAttributeMetaData</span> :</span> <span class="keyword">public</span> FTableRowBase</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_USTRUCT_BODY()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FAttributeMetaData();</span><br><span class="line"></span><br><span class="line">    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = <span class="string">"Gameplay Attribute"</span>)</span><br><span class="line">    <span class="keyword">float</span> BaseValue;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = <span class="string">"Gameplay Attribute"</span>)</span><br><span class="line">    <span class="keyword">float</span> MinValue;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = <span class="string">"Gameplay Attribute"</span>)</span><br><span class="line">    <span class="keyword">float</span> MaxValue;</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">    FString DerivedAttributeInfo;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = <span class="string">"Gameplay Attribute"</span>)</span><br><span class="line">    <span class="keyword">bool</span> bCanStack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>目前我并没有使用这个方法，而是将最大值和最小值也视为常规的Attribute来使用。</p>
<p>通常对于来自GameplayEffect的处理，会有Clamp之类的处理，而这类的处理，对于Attribute中的这两个值来说会被放在不同的地方：</p>
<ul>
<li><code>CurrentValue</code>的Clamp处理通常会在<code>PreAttributeChange()</code>函数里进行</li>
<li><code>BaseValue</code>的Clamp处理通常会在<code>PostGameplayEffectExecute()</code>函数里进行</li>
</ul>
<p>通常情况下，<code>Instant`</code>GameplayEffects<code>这种类型的GE被视为对Attribute的永久变更，会直接改变</code>BaseValue<code>的值，而</code>Duration<code>Infinite`类型的`GameplayEffects`则是一种暂时的状态会改变`CurrentValue`的值。`Periodic</code>GameplayEffects<code>类型像</code>Instant<code>一样会改变</code>BaseValue`的值。</p>
<h4 id="Meta-Attributes"><a href="#Meta-Attributes" class="headerlink" title="Meta Attributes"></a>Meta Attributes</h4><p>有一些Attributes可以被用来当做是占位符(placeholders)或者临时的变量，目的是与其他的Attributes做一些交互(interact)，我们称作这样的变量为<code>MetaAttribute</code>。最常见的就是<strong>Damage</strong>伤害变量，我们将Damage变量作为占位符变量存储伤害数值，而不是将其封装在GameplayEffect中，使用GE<strong>直接</strong>改变我们的生命值。</p>
<p>这种方式可以方便的将伤害值传给<code>GameplayEffectExecutionCalculation</code>，方便其进行一些Buff和Debuff的计算。而且还可以更方便在<code>AttributeSet</code>中进行操作。需要注意的是MetaAttributes在GameplayEffect之间没有持久性(persistence)，也就是可以被任何一方修改，或者说是重写(override)。<strong>一般MetaAttributes不会Replicated</strong>。</p>
<p>MetaAttributes为分离逻辑和数值的设计模式提供了良好的灵活性，但也不是必须要这么使用，取决于项目要求。</p>
<h4 id="Responding-to-Attribute-Changes"><a href="#Responding-to-Attribute-Changes" class="headerlink" title="Responding to Attribute Changes"></a>Responding to Attribute Changes</h4><p>监听Attributes的值的变化可以用来更新UI或者其他的gameplay。使用<code>UAbilitySystemComponent::GetGameplayAttributeValueChangeDelegate(FGameplayAttribute Attribute)</code>函数，该函数会返回一个代理(delegate)，我们可以将想要执行的函数比如说更新UI，绑定到这个代理上。</p>
<p>这个代理提供了一个<code>FOnAttributeChangeData</code>参数，里面包含了<code>NewValue</code>和<code>OldValue</code>，还有<code>FGameplayEffectModCallbackData</code>参数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;GetGameplayAttributeValueChangeDelegate(AttributeSetBase-&gt;GetHealthAttribute()).AddUObject(<span class="keyword">this</span>, $AGDPlayerState::HealthChanged);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">HealthChanged</span><span class="params">(<span class="keyword">const</span> FOnAttributeChangeData&amp; Data)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> </p>
<p><code>FGameplayEffectModCallbackData</code>只能在Server端被设置。</p>
<p>目前关于这个struct的内容我还不太清楚。</p>
<p>在GASDocumentation的项目中，作者制作了一个<code>AsyncTask</code>，用来方便的定制Attribute的更新与UI的更新事件。由于制作很是巧妙，而且还有我不知道的用法在里面，就像复制粘贴过来。至于源文件的链接我也贴上。</p>
<ul>
<li><a href="https://github.com/tranek/GASDocumentation/blob/master/Source/GASDocumentation/Public/Characters/Abilities/AsyncTaskAttributeChanged.h" target="_blank" rel="noopener">GASDocumentation-AsyncTaskAttributeChanged.h</a><br><details><br><summary>点击展开代码</summary> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2020 Dan Kestranek.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CoreMinimal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Kismet/BlueprintAsyncActionBase.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"AbilitySystemComponent.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"AsyncTaskAttributeChanged.generated.h"</span></span></span><br><span class="line"></span><br><span class="line">DECLARE_DYNAMIC_MULTICAST_DELEGATE_ThreeParams(FOnAttributeChanged, FGameplayAttribute, Attribute, <span class="keyword">float</span>, NewValue, <span class="keyword">float</span>, OldValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Blueprint node to automatically register a listener for all attribute changes in an AbilitySystemComponent.</span></span><br><span class="line"><span class="comment"> * Useful to use in UI.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UCLASS(BlueprintType, meta=(ExposedAsyncProxy = AsyncTask))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GASDOCUMENTATION_API</span> <span class="title">UAsyncTaskAttributeChanged</span> :</span> <span class="keyword">public</span> UBlueprintAsyncActionBase</span><br><span class="line">&#123;</span><br><span class="line">        GENERATED_BODY()</span><br><span class="line">        </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        UPROPERTY(BlueprintAssignable)</span><br><span class="line">        FOnAttributeChanged OnAttributeChanged;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Listens for an attribute changing.</span></span><br><span class="line">        UFUNCTION(BlueprintCallable, meta = (BlueprintInternalUseOnly = <span class="string">"true"</span>))</span><br><span class="line">        <span class="function"><span class="keyword">static</span> UAsyncTaskAttributeChanged* <span class="title">ListenForAttributeChange</span><span class="params">(UAbilitySystemComponent* AbilitySystemComponent, FGameplayAttribute Attribute)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Listens for an attribute changing.</span></span><br><span class="line">        <span class="comment">// Version that takes in an array of Attributes. Check the Attribute output for which Attribute changed.</span></span><br><span class="line">        UFUNCTION(BlueprintCallable, meta = (BlueprintInternalUseOnly = <span class="string">"true"</span>))</span><br><span class="line">        <span class="function"><span class="keyword">static</span> UAsyncTaskAttributeChanged* <span class="title">ListenForAttributesChange</span><span class="params">(UAbilitySystemComponent* AbilitySystemComponent, TArray&lt;FGameplayAttribute&gt; Attributes)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// You must call this function manually when you want the AsyncTask to end.</span></span><br><span class="line">        <span class="comment">// For UMG Widgets, you would call it in the Widget's Destruct event.</span></span><br><span class="line">        UFUNCTION(BlueprintCallable)</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">EndTask</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">        UPROPERTY()</span><br><span class="line">        UAbilitySystemComponent* ASC;</span><br><span class="line"></span><br><span class="line">        FGameplayAttribute AttributeToListenFor;</span><br><span class="line">        TArray&lt;FGameplayAttribute&gt; AttributesToListenFor;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">AttributeChanged</span><span class="params">(<span class="keyword">const</span> FOnAttributeChangeData&amp; Data)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details></li>
</ul>
<p></p>
<ul>
<li><a href>GASDocumentation-AsyncTaskAttributeChanged.cpp</a><br><details><br><summary>点击展开代码</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2020 Dan Kestranek.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Characters/Abilities/AsyncTaskAttributeChanged.h"</span></span></span><br><span class="line"></span><br><span class="line">UAsyncTaskAttributeChanged* UAsyncTaskAttributeChanged::ListenForAttributeChange(UAbilitySystemComponent* AbilitySystemComponent, FGameplayAttribute Attribute)</span><br><span class="line">&#123;</span><br><span class="line">        UAsyncTaskAttributeChanged* WaitForAttributeChangedTask = NewObject&lt;UAsyncTaskAttributeChanged&gt;();</span><br><span class="line">        WaitForAttributeChangedTask-&gt;ASC = AbilitySystemComponent;</span><br><span class="line">        WaitForAttributeChangedTask-&gt;AttributeToListenFor = Attribute;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!IsValid(AbilitySystemComponent) || !Attribute.IsValid())</span><br><span class="line">        &#123;</span><br><span class="line">                WaitForAttributeChangedTask-&gt;RemoveFromRoot();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AbilitySystemComponent-&gt;GetGameplayAttributeValueChangeDelegate(Attribute).AddUObject(WaitForAttributeChangedTask, &amp;UAsyncTaskAttributeChanged::AttributeChanged);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> WaitForAttributeChangedTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UAsyncTaskAttributeChanged * UAsyncTaskAttributeChanged::ListenForAttributesChange(UAbilitySystemComponent * AbilitySystemComponent, TArray&lt;FGameplayAttribute&gt; Attributes)</span><br><span class="line">&#123;</span><br><span class="line">        UAsyncTaskAttributeChanged* WaitForAttributeChangedTask = NewObject&lt;UAsyncTaskAttributeChanged&gt;();</span><br><span class="line">        WaitForAttributeChangedTask-&gt;ASC = AbilitySystemComponent;</span><br><span class="line">        WaitForAttributeChangedTask-&gt;AttributesToListenFor = Attributes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!IsValid(AbilitySystemComponent) || Attributes.Num() &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                WaitForAttributeChangedTask-&gt;RemoveFromRoot();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (FGameplayAttribute Attribute : Attributes)</span><br><span class="line">        &#123;</span><br><span class="line">                AbilitySystemComponent-&gt;GetGameplayAttributeValueChangeDelegate(Attribute).AddUObject(WaitForAttributeChangedTask, &amp;UAsyncTaskAttributeChanged::AttributeChanged);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> WaitForAttributeChangedTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> UAsyncTaskAttributeChanged::EndTask()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (IsValid(ASC))</span><br><span class="line">        &#123;</span><br><span class="line">                ASC-&gt;GetGameplayAttributeValueChangeDelegate(AttributeToListenFor).RemoveAll(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (FGameplayAttribute Attribute : AttributesToListenFor)</span><br><span class="line">                &#123;</span><br><span class="line">                        ASC-&gt;GetGameplayAttributeValueChangeDelegate(Attribute).RemoveAll(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SetReadyToDestroy();</span><br><span class="line">        MarkPendingKill();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> UAsyncTaskAttributeChanged::AttributeChanged(<span class="keyword">const</span> FOnAttributeChangeData &amp; Data)</span><br><span class="line">&#123;</span><br><span class="line">        OnAttributeChanged.Broadcast(Data.Attribute, Data.NewValue, Data.OldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details></li>
</ul>
<p></p>
<p>这段代码实现了两个函数<code>ListenForAttributeChange</code>和<code>ListenForAttributesChange</code>用来监视Attribute的值的变更，同时是基于<code>UBlueprintAsyncActionBase</code>扩展的类，也可以在BP中方便的使用这两个函数，主要是对于UI的操作来说，提供这样的函数会更加方便一些。</p>
<p><img src="ListenForAttributeChange.PNG" alt="AttributeChange"></p>
<h4 id="Derived-Attributes"><a href="#Derived-Attributes" class="headerlink" title="Derived Attributes"></a>Derived Attributes</h4><p>刚开始看的时候就觉得好高大上啊，派生属性好厉害，难不成是AttributeSet的派生类中的Attribute也能更新，但仔细想想这太厉害了也，而且不符合我学到的知识。</p>
<p>关于这个Attribute的派生的功能，其实是说比如当我们在<code>Infinite</code>类型的<code>GameplayEffect</code>中使用一个或更多个的<code>Attribute Based</code>和<code>MMC Modifiers</code>的时候，<code>Derived Attribute</code>会依据它所依赖的上述类型的变量的变化而更新自己的值。</p>
<blockquote>
<p>The <code>Derived Attribute</code> will update automatically when an <code>Attribute</code> that it depends on is updated.</p>
</blockquote>
<p>简单来理解就是当一个Attribute依赖于其他的Attribute的时候，这个Attribute就是一个<code>Derived Attribute</code>，而且其它的Attribute的值更新的时候，这个Attribute的值也会被更新。<br>文章中所举的例子就是：<code>TestAttrA = (TestAttrA + TestAttrB) * 2 * TestAttrC</code>这种计算中，<code>TestAttrA</code> <code>TestAttrB</code> <code>TestAttrC</code>中的任何一个值有更新，<code>TestAttrA</code>的值都会随之被更新。</p>
<p>至于这段内容还有没有额外的意思我不太确定，我只理解到了这一步。</p>
<blockquote>
<p>The final formula for all the <code>Modifiers</code> on a <code>Derived Attribute</code> is the same formula for <code>Modifier Aggregators</code>. If you need calculations to happen in a certain order, do it all inside of an <code>MMC</code>.</p>
</blockquote>
<p>关于<code>Modifier Aggregator</code>的内容我目前也不是很了解，大意应该就是，对于<code>Derived Attribtue</code>来说普通的<code>Modifier</code>计算公式顺序是和<code>Modifier Aggregator</code>是一样的，如果想要其按照某种顺序你想要的顺序来计算的话，就需要我们在<code>MMC</code>中完成这些事情。</p>
<blockquote>
<p><strong>Note:</strong> If playing with multiple clients in PIE, you need to disable <code>Run Under One Process</code> in the Editor <code>Preferences</code> otherwise the <code>Derived Attributes</code> will not update when their independent Attributes update on clients other than the first.</p>
</blockquote>
<p><strong>Note:</strong> 这段的意思我不是完全理解，大意应该就是在Editor的PIE模式下运行多个客户端的时候，记得把Editor的<code>Preference</code>中的<code>Run Under One Process</code>一项禁用掉，不然的话，除了第一个被运行的Client之外，其他Client上的<code>Dervied Attributes</code>尽管依赖的属性更新，其派生的Attribute的值也不会被更新。</p>
<h3 id="Attribute-Set"><a href="#Attribute-Set" class="headerlink" title="Attribute Set"></a>Attribute Set</h3><h4 id="Attribute-Set定义"><a href="#Attribute-Set定义" class="headerlink" title="Attribute Set定义"></a>Attribute Set定义</h4><p><strong>Tips</strong></p>
<p>我在GASDocumentation中看到，关于AttributeSet的初始化的问题。作者选择了Server和Client两侧都执行了初始化的操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GDCharacterBase.h</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Initialize the Character's attributes. Must run on Server but we run it on Client too</span></span><br><span class="line">    <span class="comment">// so that we don't have to wait. The Server's replication to Client wont't matter since</span></span><br><span class="line">    <span class="comment">// the values should be the same.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">InitializeAttributes</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AGDCharacterBase::InitializeAttributes()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!AbilitySystemComponent.IsValid()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!DefaultAttributes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can run on Server and Client</span></span><br><span class="line">    FGameplayEffectContextHandle EffectContext = AbilitySystemComponent-&gt;MakeEffectContext();</span><br><span class="line">    EffectContext.AddSourceObject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    FGameplayEffectSpecHandle NewHandle = AbilitySystemComponent-&gt;MakeOutgoingSpec(DefaultAttributes, GetCharacterLevel(), EffectContext);</span><br><span class="line">    <span class="keyword">if</span>(NewHandle.IsValid())</span><br><span class="line">    &#123;</span><br><span class="line">        FActiveGameplayEffectHandle ActiveGEHandle = AbilitySystemComponent-&gt;ApplyGameplayEffectSpecToTarget(*NewHandle.Data.Get(), AbilitySystemComponent.Get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面这样在双方都进行了初始化，但是我自己实验了之后明显Client这边没有被成功的初始化，貌似GameplayEffect这边执行Apply的时候也会有一个Authority检查，就导致Client在上面的<code>ApplyGameplayEffectSpecToTarget</code>这一步返回的<code>ActiveGEHandle</code>是<code>-1</code>，也就是无效的Handle。(可能是跟ASC的ReplicationMode有关？我选的是MixMode)</p>
<p>看来真的想在Client端也进行初始化的话，还是用<code>Setter</code>,<code>Getter</code>函数比较靠谱。</p>
<h2 id="GameplayAbilitySystem中重要的类，结构体"><a href="#GameplayAbilitySystem中重要的类，结构体" class="headerlink" title="GameplayAbilitySystem中重要的类，结构体"></a>GameplayAbilitySystem中重要的类，结构体</h2><h3 id="GameplayAbilitySpec"><a href="#GameplayAbilitySpec" class="headerlink" title="GameplayAbilitySpec"></a>GameplayAbilitySpec</h3><p>暂时先放到这里之后整理</p>
<p>我遇到了一个问题就是FGameplayAbilitySpec的SourceObject并不会replicated的问题，所以别想着在GA中尝试使用通用的SourceObject了，在Server和Client之间。</p>
<h3 id="GameplayEffect"><a href="#GameplayEffect" class="headerlink" title="GameplayEffect"></a>GameplayEffect</h3><h4 id="FGameplayEffectContext"><a href="#FGameplayEffectContext" class="headerlink" title="FGameplayEffectContext"></a>FGameplayEffectContext</h4><h4 id="FGameplayEffectContextHandle"><a href="#FGameplayEffectContextHandle" class="headerlink" title="FGameplayEffectContextHandle"></a>FGameplayEffectContextHandle</h4><h3 id="InputBind"><a href="#InputBind" class="headerlink" title="InputBind"></a>InputBind</h3><p>使用GAS的功能可以直接绑定Ability的激活到输入里，我暂时先把这个写下来之后整合到上面的内容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyCharacter.h</span></span><br><span class="line">    <span class="comment">// Called from both SetupPlayerInputComponent and OnRep_PlayerState because of a potential race condition where the PlayerController might</span></span><br><span class="line">    <span class="comment">// call ClientRestart which calls SetupPlayerInputComponent before the PlayerState is repped to the client so the PlayerState would be null in SetupPlayerInputComponent.</span></span><br><span class="line">    <span class="comment">// Conversely, the PlayerState might be repped before the PlayerController calls ClientRestart so the Actor's InputComponent would be null in OnRep_PlayerState.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BindASCInput</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyCharacter.cpp</span></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::BindASCInput()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ASCInputBound &amp;&amp; AbilitySystemComponent.IsValid() &amp;&amp; IsValid(InputComponent))</span><br><span class="line">    &#123;</span><br><span class="line">        AbilitySystemComponent-&gt;BindAbilityActivationToInputComponent(InputComponent, FGameplayAbilityInputBinds(FString(<span class="string">"ConfirmTarget"</span>),</span><br><span class="line">        FString(<span class="string">"CancelTarget"</span>), FString(<span class="string">"EGDAbilityInputID"</span>), <span class="keyword">static_cast</span>&lt;int32&gt;(EGDAbilityInputID::Confirm), <span class="keyword">static_cast</span>&lt;int32&gt;(EGDAbilityInputID::Cancel)));</span><br><span class="line"></span><br><span class="line">        ASCInputBound = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一些小的知识点"><a href="#一些小的知识点" class="headerlink" title="一些小的知识点"></a>一些小的知识点</h2><p>这里插播几个小知识点，在C++中添加了BlueprintCallable的函数的时候，直接编译之后保持Editor的开启状态可能会不出现，在Blueprint的编辑界面还是找不到这个函数，此时需要重启UE4的Editor。</p>
<p>还有一个就是在Blueprint中调用Parent节点的内容时，需要右键该节点找到<strong>add call to parent function</strong>。</p>
<h3 id="OnAvatarSet"><a href="#OnAvatarSet" class="headerlink" title="OnAvatarSet"></a>OnAvatarSet</h3><p>GameplayAbility.h<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UCLASS(Blueprintable)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GAMEPLAYABILITIES_API</span> <span class="title">UGameplayAbility</span> :</span> <span class="keyword">public</span> UObject, <span class="keyword">public</span> IGameplayTaskOwnerInterface</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/** Called when the avatar actor is set/changes */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnAvatarSet</span><span class="params">(<span class="keyword">const</span> FGameplayAbilityActorInfo* ActorInfo, <span class="keyword">const</span> FGameplayAbilitySpec&amp; Spec)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>GameplayAbility.cpp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> UGameplayAbility::OnAvatarSet(<span class="keyword">const</span> FGameplayAbilityActorInfo* ActorInfo, <span class="keyword">const</span> FGameplayAbilitySpec&amp; Spec)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Projects may want to initiate passives or do other "BeginPlay" type of logic here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个是GameplayAbility自身所有的一个函数，在想要使用的时候需要对其重写。就像是对Actor的BeginPlay函数一样，对GameplayAbility来说就是OnAvatarSet函数。</p>
<p>按照这篇文章的做法就是将被动属性的GameplayAbility的激活放在了一开始，就是这个函数里面。</p>
<p>GASDocumentation/GDGameplayAbility<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UCLASS()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GASDOCUMENTATION_API</span> <span class="title">UGDGameplayAbility</span> :</span> <span class="keyword">public</span> UGameplayAbility</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// If an ability is marked as ‘'ActivateAbilityOnGranted', activate them immediately when given here</span></span><br><span class="line">    <span class="comment">// Epic's comment: Projects may want to initiate passives or do other "BeginPlay" type of logic here.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnAvatarSet</span><span class="params">(<span class="keyword">const</span> FGameplayAbilityActorInfo* ActorInfo, <span class="keyword">const</span> FGameplayAbilitySpec&amp; Spec)</span> override</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>GASDocumentation/GDGameplayAbility.cpp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> UGDGameplayAbility::OnAvatarSet(<span class="keyword">const</span> FGameplayAbilityActorInfo* ActorInfo, <span class="keyword">const</span> FGameplayAbilitySpec&amp; Spec)</span><br><span class="line">&#123;</span><br><span class="line">    Super::OnAvatarSet(ActorInfo, Spec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ActivateAbilityOnGranted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> ActivatedAbility = ActorInfo-&gt;AbilitySystemComponent-&gt;TryActivateAbility(Spec.Handle, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>bAllowRemoteActivation</code>标志位被设置为false，这样设置的理由我目前还没有完全搞清楚。</p>
<p>以上就是<code>OnAvatarSet</code>函数的使用理由和方法了。</p>
<h3 id="WaitDelay"><a href="#WaitDelay" class="headerlink" title="WaitDelay"></a>WaitDelay</h3><p>这次我遇到的是一个<strong>WaitDelay</strong>的BlueprintNode，这里需要注意的是要与另外一个BPNode<strong>TaskWaitDelay</strong>区分开来。</p>
<p><img src="WaitDelay.png" alt="WaitDelay"><br><img src="TaskWaitDelay.png" alt="TaskWaitDelay"></p>
<p>区别是一个是面向GameplayTask的一个是面向AbilityTask的。目前只对WaitDelay即AbilityTask的内容进行理解。</p>
<h1 id="从零开始搭建一个GAS工程"><a href="#从零开始搭建一个GAS工程" class="headerlink" title="从零开始搭建一个GAS工程"></a>从零开始搭建一个GAS工程</h1><p>这部分更新于我开始阅读并理解上面的<a href="https://github.com/tranek/GASDocumentation" target="_blank" rel="noopener">GASDocumentation</a>的三个月后，没错，我用了超过3个月的时间进行<strong>GameplayAbilitySystem</strong>的学习。甚至还只是局限于读懂而已。</p>
<p>这之间涉及了太多的UE4的框架部分的知识，我先在我构建这样一个工程的同时，同时记录下我遇见的疑难知识点，算是自我的提升和加深记忆了。</p>
<p>当然主要的还是对上面的那篇文章的实践和翻译。</p>
<h2 id="创建一个空白的项目，准备导入GAS"><a href="#创建一个空白的项目，准备导入GAS" class="headerlink" title="创建一个空白的项目，准备导入GAS"></a>创建一个空白的项目，准备导入GAS</h2><p>就如标题所说，我们创建一个空白的项目，但是在导入GAS之前我们要把框架搭好。关于UE4的MultiPlay框架在别的文章有涉及。</p>
<p>要决定好一些我之后可能要修改的配置，尽可能的创造一些基类，为扩展做一些铺垫。倒也不是尽可能的，看情况吧。</p>
<h3 id="GameMode"><a href="#GameMode" class="headerlink" title="GameMode"></a>GameMode</h3><p>首先我们要决定我们的<strong>GameMode</strong>，这里要对游戏一开始的内容做一些初始的处理，包含一些登录操作什么的，之后再展开。</p>
<p>在继承了<code>AGameModeBase</code>得到了自己的GameMode之后，新建一个blueprint继承这个GameMode，主要是为了方便在Editor上切换GamMode相关的设定。</p>
<p>在Editor主界面找到<strong>Blueprint -&gt; WorldOverride</strong> 指定我们准备好的BP_GameMode，就可以了。</p>
<h3 id="Pawn"><a href="#Pawn" class="headerlink" title="Pawn"></a>Pawn</h3><p>至于顺序，看心情吧没有非要这样的顺序。下一个是开始我们的Pawn的制作，世界做好了得让人物动起来，也就是我们需要一个或者一些Character。</p>
<blockquote>
<p>Characters are Pawns that have a mesh, collision, and built-in movement logic.</p>
</blockquote>
<p>选自<code>ACharacter</code>类的注释，直接使用APawn也可以，是勇士了。</p>
<p>ACharacter有一个内置的SkeletalMeshComponent，还有一些关于移动的逻辑。</p>
<p>说到关于移动的逻辑那就只有<strong>CharacterMovementComponent</strong>了，但是我在<code>Character.cpp</code>中看到了<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ACharacter::ACharacter(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">: Super(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    CharacterMovement = CreateDefaultSubobject&lt;UCharacterMovementComponent&gt;(ACharacter::CharacterMovementComponentName);</span><br><span class="line">    <span class="keyword">if</span> (CharacterMovement)</span><br><span class="line">    &#123;</span><br><span class="line">        CharacterMovement-&gt;UpdatedComponent = CapsuleComponent;</span><br><span class="line">        CrouchedEyeHeight = CharacterMovement-&gt;CrouchedHalfHeight * <span class="number">0.80f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>怎么看都是只要继承了Character这个类的话都会有一个<code>UCharacterMovementComponent</code>的，但实际上在GASDocumentation中，又再一次生成了这个移动组件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GDCharacterBase.cpp</span></span><br><span class="line"><span class="comment">// Sets default values</span></span><br><span class="line">AGDCharacterBase::AGDCharacterBase(<span class="keyword">const</span> class FObjectInitializer&amp; ObjectInitializer) :</span><br><span class="line">    Super(ObjectInitializer.SetDefaultSubobjectClass&lt;UGDCharacterMovementComponent&gt;(ACharacter::CharacterMovementComponentName))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.</span></span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    GetCapsuleComponent()-&gt;SetCollisionResponseToChannel(ECollisionChannel::ECC_Visibility, ECollisionResponse::ECR_Overlap);</span><br><span class="line"></span><br><span class="line">    bAlwaysRelevant = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乍看一下好帅啊这个组件生成方法，但是这个是有其特殊用意的。</p>
<p>这个<strong>SetDefaultSubjectClass</strong>是用来做什么的呢？这个问题竟然回到了我之前一直疑惑的问题上。</p>
<h4 id="Constructor-with-or-without-FObjectInitializer"><a href="#Constructor-with-or-without-FObjectInitializer" class="headerlink" title="Constructor with or without FObjectInitializer"></a>Constructor with or without FObjectInitializer</h4><p>关于UE4中C++的构造函数的问题，我们有三种方式来实现UE4中的构造函数</p>
<ul>
<li>不声明构造函数</li>
<li>声明一个无参的默认构造函数</li>
<li>声明一个<code>FObjectInitializer</code>参数的构造函数</li>
</ul>
<p>写法网上一搜都有，说不定我哪篇文章也写过。</p>
<p>第一种是UE4的<code>GENERATED_BODY()</code>宏会生成构造函数，即使不特意的声明也没有问题。貌似生成的Constructor会存在与<code>XXX.generated.h</code>文件中。</p>
<p>第二种则是我经常用的方式，毕竟还多几行代码，看起来好看，也是最常规最常见的。</p>
<p>第三种，要在什么情况下使用呢？</p>
<blockquote>
<p>as long you dont have to replace any base component (such as replacing the MovementComponent class) that basic constructor works just fine if you don’t use the GENERATED_CLASS_BODY() macro. (using GENERATED_BODY() instead).</p>
</blockquote>
<p>来自问题<a href="https://forums.unrealengine.com/development-discussion/c-gameplay-programming/97550-constructor-with-or-without-fobjectinitializer" target="_blank" rel="noopener">Constructor with or without FObjectInitializer</a></p>
<p>大意就是说在没有<strong>替换组件例如MovementComponent</strong>的时候，第二种构造函数没有问题。</p>
<p>所以就引出了这一小节的主角</p>
<h4 id="ObjectInitializer控制组件生成"><a href="#ObjectInitializer控制组件生成" class="headerlink" title="ObjectInitializer控制组件生成"></a>ObjectInitializer控制组件生成</h4><p>也就是这篇<a href="https://historia.co.jp/archives/6587/" target="_blank" rel="noopener">UE4 ObjectInitializerでコンポーネント生成を制御する</a></p>
<p>关于宏生成构造函数的解说在上面的文章很详细，我也是：啊啊，好像是那样。</p>
<p>那么什么情况下我们非要使用带有<strong>ObjectInitializer</strong>的构造函数不可呢？</p>
<p>与其相关的最常见到的就是<code>CreateDefaultSubobject</code>这个函数了。在Constructor中生成Component。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USceneComponent* SceneComponent = ObjectInitializer.CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT(<span class="string">"SceneComponent"</span>));</span><br></pre></td></tr></table></figure></p>
<p>想用这招的话，看起来好像非这种构造函数不可了，但实际上：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USceneComponent* SceneComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT(<span class="string">"SceneComponent"</span>));</span><br></pre></td></tr></table></figure></p>
<p>这种写法也是对的，因为UObject为其提供了同名的包装方法(wrap function)。</p>
<p>所以只有这个<strong>CreateDefaultSubobject</strong>也不是一定要用第三种构造函数。</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CreateEditorOnlyDefaultSubobject</td>
<td>エディタのみで有効なコンポーネントを作成する</td>
</tr>
<tr>
<td>CreateOptionalDefaultSubobject</td>
<td>作られなくても良い（動作には必ずしも必要無い）コンポーネントを作成する※ これは後述する関数と組み合わせて利用します</td>
</tr>
<tr>
<td>CreateAbstractDefaultSubobject</td>
<td>Abstract 属性のクラスは CreateDefaultSubobject を使うと作成できないようになっているので、必要な場合は明示的にこの関数を利用する</td>
</tr>
</tbody>
</table>
<p>上面的函数的使用对于ObjectInitializer的需要都不是必须的，但是除了这些之外的，就要了。</p>
<blockquote>
<p>これらのみを利用する場合は ObjectInitializer を利用する必要性はありません。</p>
<p>逆に言えば、<strong>これら以外の ObjectInitializer が提供するAPIを利用したい時は引数に与える必要性がある</strong> ということです。</p>
<p>UObject でラップされていない、ObjectInitializer が提供する関数は以下のものがあります。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>SetDefaultSubobjectClass</td>
<td>親クラスがコンポーネントを作成する時、そのコンポーネントのクラスを名前指定で上書きする <br>※ 親クラスが作成するコンポーネントから派生したコンポーネントのみが指定できます</td>
</tr>
<tr>
<td>DoNotCreateDefaultSubobject</td>
<td>CreateOptionalDefaultSubobject でコンポーネントを作成する時、名前指定でコンポーネントの作成を無効化できる</td>
</tr>
</tbody>
</table>
<p>其中尤为重要的就是<strong>SetDefaultSubobjectClass</strong>,最常用的例子就是<code>UCharacterMovementComponent</code>是ACharacter默认提供的功能，如果我们想为其提供自定义的MovementComponent，那就使用这个函数，覆盖ACharacter提供的默认的移动组件。</p>
<p>至于怎么用，就像上面那么用。</p>
<blockquote>
<p>ちなみに SetDefaultSubobjectClass 及び DoNotCreateDefaultSubobject の戻り値は FObjectInitializer のコピーなので、メソッドチェーンで記述することが可能です。</p>
</blockquote>
<p>呃，这个意思不太懂。</p>
<h4 id="Camera组件"><a href="#Camera组件" class="headerlink" title="Camera组件"></a>Camera组件</h4><p>接下来是要为我们的Character添加摄像机，一个是<strong>CameraComponent</strong>，另一个是<strong>SpringArmComponent</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AGDHeroCharacter::AGDHeroCharacter(<span class="keyword">const</span> class FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">    CameraBoom = CreateDefaultSubobject&lt;USpringArmComponent&gt;(FName(<span class="string">"CameraBoom"</span>));</span><br><span class="line">    CameraBoom-&gt;SetupAttachment(RootComponent);</span><br><span class="line">    CameraBoom-&gt;bUsePawnControlRotation = <span class="literal">true</span>;</span><br><span class="line">    CameraBoom-&gt;SetRelativeLocation(FVector(<span class="number">0</span>, <span class="number">0</span>, <span class="number">68.492264</span>));</span><br><span class="line"></span><br><span class="line">    FollowCamera = CreateDefaultSubobject&lt;UCameraComponent&gt;(FName(<span class="string">"FollowCamera"</span>));</span><br><span class="line">    FollowCamera-&gt;SetupAttachment(CameraBoom);</span><br><span class="line">    FollowCamera-&gt;FieldOfView = <span class="number">80.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现就像上面那样，别问我为什么要那么实现，我也不知道。</p>
<h5 id="SpringArmComponent"><a href="#SpringArmComponent" class="headerlink" title="SpringArmComponent"></a>SpringArmComponent</h5><p>相机臂组件，是我之前一直忽略的组件，但是最近一点点觉得可能这个组件很重要。因为大多数的3D游戏对镜头的操纵极为重要，流畅华丽的镜头切换是会让人心情舒畅的。</p>
<p>但是我不知道那些游戏里镜头的移动是否是依赖于这个组件…</p>
<p>默认的情况下CameraBoom（上面的SpringArmComponent）是有碰撞判定的，即相机和Character之间有物体的话会缩短相机臂的距离，如果不想要这个功能的话</p>
<p>接上面的代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// これだけでカメラの当たり判定が無効になる</span></span><br><span class="line">  CameraBoom-&gt;bDoCollisionTest = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>
<p>貌似可以实现一些物体加速的相机追踪延迟的效果，但是要是想实现更丰富的镜头切换应该需要更多的自定义。</p>
<p>暂时先挖个坑。</p>
<h4 id="SetupPlayerInputComponent"><a href="#SetupPlayerInputComponent" class="headerlink" title="SetupPlayerInputComponent"></a>SetupPlayerInputComponent</h4><p>用来设置键位的组件，需要override这个函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line">    <span class="comment">// Called to bind functionality to input</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(class UInputComponent* PlayerInputComponent)</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="comment">// Called to bind functionality to input</span></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)</span><br><span class="line">&#123;</span><br><span class="line">    Super::SetupPlayerInputComponent(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">    PlayerInputComponent-&gt;BindAxis(<span class="string">"MoveForward"</span>, <span class="keyword">this</span>, &amp;AGDHeroCharacter::MoveForward);</span><br><span class="line">    PlayerInputComponent-&gt;BindAxis(<span class="string">"MoveRight"</span>, <span class="keyword">this</span>, &amp;AGDHeroCharacter::MoveRight);</span><br><span class="line"></span><br><span class="line">    PlayerInputComponent-&gt;BindAxis(<span class="string">"LookUp"</span>, <span class="keyword">this</span>, &amp;AGDHeroCharacter::LookUp);</span><br><span class="line">    PlayerInputComponent-&gt;BindAxis(<span class="string">"LookUpRate"</span>, <span class="keyword">this</span>, &amp;AGDHeroCharacter::LookUpRate);</span><br><span class="line">    PlayerInputComponent-&gt;BindAxis(<span class="string">"Turn"</span>, <span class="keyword">this</span>, &amp;AGDHeroCharacter::Turn);</span><br><span class="line">    PlayerInputComponent-&gt;BindAxis(<span class="string">"TurnRate"</span>, <span class="keyword">this</span>, &amp;AGDHeroCharacter::TurnRate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind player input to the AbilitySystemComponent. Also called in OnRep_PlayerState because of a potential race condition.</span></span><br><span class="line">    BindASCInput();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::LookUp(<span class="keyword">float</span> Value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsAlive())</span><br><span class="line">    &#123;</span><br><span class="line">        AddControllerPitchInput(Value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::LookUpRate(<span class="keyword">float</span> Value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsAlive())</span><br><span class="line">    &#123;</span><br><span class="line">        AddControllerPitchInput(Value * BaseLookUpRate * GetWorld()-&gt;DeltaTimeSeconds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::Turn(<span class="keyword">float</span> Value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsAlive())</span><br><span class="line">    &#123;</span><br><span class="line">        AddControllerYawInput(Value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::TurnRate(<span class="keyword">float</span> Value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsAlive())</span><br><span class="line">    &#123;</span><br><span class="line">        AddControllerYawInput(Value * BaseTurnRate * GetWorld()-&gt;DeltaTimeSeconds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::MoveForward(<span class="keyword">float</span> Value)</span><br><span class="line">&#123;</span><br><span class="line">    AddMovementInput(UKismetMathLibrary::GetForwardVector(FRotator(<span class="number">0</span>, GetControlRotation().Yaw, <span class="number">0</span>)), Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::MoveRight(<span class="keyword">float</span> Value)</span><br><span class="line">&#123;</span><br><span class="line">    AddMovementInput(UKismetMathLibrary::GetRightVector(FRotator(<span class="number">0</span>, GetControlRotation().Yaw, <span class="number">0</span>)), Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我就粘贴上大概的实现，反正要找的话都能找到。</p>

      
    </div>
    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文完-------------</div>
    
</div>

      
    </div>

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    stone
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://stonelzp.github.io/ue4-gameplay-ability-system/" title="UE4-GameplayAbilitySystem学习">http://stonelzp.github.io/ue4-gameplay-ability-system/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/stonelzp.github.io/tags/UE4/" rel="tag"><i class="fa fa-tag"></i> UE4</a>
          
            <a href="/stonelzp.github.io/tags/ActionRPG/" rel="tag"><i class="fa fa-tag"></i> ActionRPG</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/stonelzp.github.io/csharp-attribute/" rel="next" title="CSharp-Attribute的理解与使用">
                <i class="fa fa-chevron-left"></i> CSharp-Attribute的理解与使用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/stonelzp.github.io/ue4-multiplay-framework/" rel="prev" title="UE4-多人游戏框架理解">
                UE4-多人游戏框架理解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/stonelzp.github.io/uploads/avatar.gif" alt="stone">
            
              <p class="site-author-name" itemprop="name">stone</p>
              <p class="site-description motion-element" itemprop="description">爱自己，对爱你的人来说，是最大的安慰</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/stonelzp.github.io/archives/">
              
                  <span class="site-state-item-count">91</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/stonelzp.github.io/categories/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/stonelzp.github.io/tags/index.html">
                  <span class="site-state-item-count">43</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/stonelzp" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          
            <div class="cc-license motion-element" itemprop="license">
              <a href="https://creativecommons.org/licenses/by/4.0/" class="cc-opacity" target="_blank">
                <img src="/stonelzp.github.io/images/cc-by.svg" alt="Creative Commons">
              </a>
            </div>
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#GamePlay-Guide"><span class="nav-number">1.</span> <span class="nav-text">GamePlay Guide</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Gameplay-Ability-System"><span class="nav-number">1.1.</span> <span class="nav-text">Gameplay Ability System</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ActionRPG"><span class="nav-number">2.</span> <span class="nav-text">ActionRPG</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ActionRPG内容分析"><span class="nav-number">2.1.</span> <span class="nav-text">ActionRPG内容分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ActionRPG练习"><span class="nav-number">2.2.</span> <span class="nav-text">ActionRPG练习</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GameplayAbilities-and-you"><span class="nav-number">3.</span> <span class="nav-text">GameplayAbilities and you</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-number">3.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Getting-Started"><span class="nav-number">3.2.</span> <span class="nav-text">Getting Started</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Setting-up-the-Project"><span class="nav-number">3.2.1.</span> <span class="nav-text">Setting up the Project</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建第一个GamePlayAbility-blueprint"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">创建第一个GamePlayAbility blueprint</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Setting-up-our-Charactor"><span class="nav-number">3.2.2.</span> <span class="nav-text">Setting up our Charactor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Binding-to-Character-input"><span class="nav-number">3.2.3.</span> <span class="nav-text">Binding to Character input</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Giving-the-Character-an-Ability"><span class="nav-number">3.2.4.</span> <span class="nav-text">Giving the Character an Ability</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Essentials-要点"><span class="nav-number">3.3.</span> <span class="nav-text">The Essentials (要点)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GameplayAbilities"><span class="nav-number">3.3.1.</span> <span class="nav-text">GameplayAbilities</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GameplayTasks"><span class="nav-number">3.3.2.</span> <span class="nav-text">GameplayTasks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GameplayEffects"><span class="nav-number">3.3.3.</span> <span class="nav-text">GameplayEffects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AttributeSet"><span class="nav-number">3.3.4.</span> <span class="nav-text">AttributeSet</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GASDocumentation"><span class="nav-number">4.</span> <span class="nav-text">GASDocumentation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#GASDocumentation的个人翻译和理解"><span class="nav-number">4.1.</span> <span class="nav-text">GASDocumentation的个人翻译和理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Intro-to-the-GameplayAbilitySystem-Plugin"><span class="nav-number">4.1.1.</span> <span class="nav-text">Intro to the GameplayAbilitySystem Plugin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Setting-Up-a-Project-Using-GAS"><span class="nav-number">4.1.2.</span> <span class="nav-text">Setting Up a Project Using GAS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbilitySystemComponent"><span class="nav-number">4.1.3.</span> <span class="nav-text">AbilitySystemComponent</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Replication-Mode"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">Replication Mode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Setup-and-Initialization"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">Setup and Initialization</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gameplay-Tags"><span class="nav-number">4.1.4.</span> <span class="nav-text">Gameplay Tags</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GameplayTag有变动的函数回调"><span class="nav-number">4.1.4.1.</span> <span class="nav-text">GameplayTag有变动的函数回调</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Attributes"><span class="nav-number">4.1.5.</span> <span class="nav-text">Attributes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Attribute-定义"><span class="nav-number">4.1.5.1.</span> <span class="nav-text">Attribute 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BaseValue-vs-CurrentValue"><span class="nav-number">4.1.5.2.</span> <span class="nav-text">BaseValue vs CurrentValue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Meta-Attributes"><span class="nav-number">4.1.5.3.</span> <span class="nav-text">Meta Attributes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Responding-to-Attribute-Changes"><span class="nav-number">4.1.5.4.</span> <span class="nav-text">Responding to Attribute Changes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Derived-Attributes"><span class="nav-number">4.1.5.5.</span> <span class="nav-text">Derived Attributes</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Attribute-Set"><span class="nav-number">4.1.6.</span> <span class="nav-text">Attribute Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Attribute-Set定义"><span class="nav-number">4.1.6.1.</span> <span class="nav-text">Attribute Set定义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GameplayAbilitySystem中重要的类，结构体"><span class="nav-number">4.2.</span> <span class="nav-text">GameplayAbilitySystem中重要的类，结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GameplayAbilitySpec"><span class="nav-number">4.2.1.</span> <span class="nav-text">GameplayAbilitySpec</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GameplayEffect"><span class="nav-number">4.2.2.</span> <span class="nav-text">GameplayEffect</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FGameplayEffectContext"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">FGameplayEffectContext</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FGameplayEffectContextHandle"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">FGameplayEffectContextHandle</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InputBind"><span class="nav-number">4.2.3.</span> <span class="nav-text">InputBind</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一些小的知识点"><span class="nav-number">4.3.</span> <span class="nav-text">一些小的知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OnAvatarSet"><span class="nav-number">4.3.1.</span> <span class="nav-text">OnAvatarSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WaitDelay"><span class="nav-number">4.3.2.</span> <span class="nav-text">WaitDelay</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#从零开始搭建一个GAS工程"><span class="nav-number">5.</span> <span class="nav-text">从零开始搭建一个GAS工程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建一个空白的项目，准备导入GAS"><span class="nav-number">5.1.</span> <span class="nav-text">创建一个空白的项目，准备导入GAS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GameMode"><span class="nav-number">5.1.1.</span> <span class="nav-text">GameMode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pawn"><span class="nav-number">5.1.2.</span> <span class="nav-text">Pawn</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Constructor-with-or-without-FObjectInitializer"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">Constructor with or without FObjectInitializer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ObjectInitializer控制组件生成"><span class="nav-number">5.1.2.2.</span> <span class="nav-text">ObjectInitializer控制组件生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Camera组件"><span class="nav-number">5.1.2.3.</span> <span class="nav-text">Camera组件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SpringArmComponent"><span class="nav-number">5.1.2.3.1.</span> <span class="nav-text">SpringArmComponent</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SetupPlayerInputComponent"><span class="nav-number">5.1.2.4.</span> <span class="nav-text">SetupPlayerInputComponent</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">stone</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/stonelzp.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/stonelzp.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/stonelzp.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/stonelzp.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/stonelzp.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/stonelzp.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/stonelzp.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/stonelzp.github.io/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/stonelzp.github.io/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/stonelzp.github.io/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/stonelzp.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/stonelzp.github.io/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
