<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记录刚学UE的一些疑问]]></title>
    <url>%2F2018%2F07%2F18%2F%E8%AE%B0%E5%BD%95%E5%88%9A%E5%AD%A6UE%E7%9A%84%E4%B8%80%E4%BA%9B%E7%96%91%E9%97%AE%2F</url>
    <content type="text"><![CDATA[为了记录自己在学习UE引擎过程中遇到的一些疑问点 C++与C#的不同之处时隔多年见到C++的第一个违和感是头文件，为什么需要写头文件这个问题我找了一些别人写的代码发现了一下几个规则： 在C++的头文件中SampleCode.h中一般都会预先定义一些东西 需要包含的其他头文件 123#include "Engine.h"#include "MyAppUtilities.h"... 定义需要使用的宏 预处理（C++的预处理器需要了解一下） 123//一般常量居多？#define PI 3.1415926... 定义类，类中包含该有的成员， 123456789class SampleClass&#123; //Attributes or functions public: protected: private:&#125; UE4中的C++不同的地方1.UCLASS( )Sample Code:12345678910111213141516171819202122#include "Engine.h" //如果需要使用UE的library的话#include "MyAppUtilities.h"UCLASS()//class UMyClass : public UObject&#123; GENERATED_BODY() public: //构造函数(公有的？) UMyClass(); UPROPERTY(BlueprintReadWrite, Category = "MyApp") int32 IntProp; UFUNCTION(BlueprintCallable, Category = "MyApp") float LengthOfSomething(const int32 index); private: TArray&lt;int&gt; IntArrayWork; //标准c++中的数组声明 //std::vector&lt;int&gt; IntArrayWork;&#125; 对于UCLASS()，如果需要继承UE的类库，则都要加上这个。最好声明的类名也以U开头为好？ 但是我觉得这种声明不是跟UE的类库搞混了吗，辨识度低我觉得应该没有这么智障的规则。 2.GENERAED_BODY( )这一句话必须要写的原因需要调查 3.UPROPERTY( , ) UFUNCTION( , )貌似使用这个声明的属性跟方法UE的Blueprint可以使用。（好一个破坏封装的使用的方法） 4.TArray-UE4中的数组（重要）先上本家，官方文档TArray:Arrays in Unreal Engine。再上中文翻译虚幻引擎中的数组–TArry:Arrays #pragma once vs include guard打开UE工程看到一些.h头文件的源码的时候看到了#pragma once有些困惑，不知道是做什么用的。于是调查了一下。 总体来说这两个命令都是为了避免同一个头文件被include多次 方式1：1234#ifndef __SOMEFILE_H_#define __SOMEFILE_H_...#endif 方式2：12#pragma once... #ifndef方式这种方式受C/C++语言标准支持，可以保证同一个文件不会被同时包含，也能保证内容完全相同的两个文件（或者代码片段）不会被同时包含。缺点是不同头文件中的宏的名字如果相同，会导致编译器找不到声明的问题。另外由于编译器每次需要打开头文件来判定是否有重复的定义，会导致编译的时间要长。 #progma once方式这种方式是保证“物理存在上”同一个文件不会被包含多次。而不是内容相同的两个文件。而且无法对一个头文件中一段代码做pragma once声明，只能针对文件。当然也不会发生第一种方式的宏名碰撞引发的问题。 使用哪一种方式见仁见智，有好处有坏处。根据情况使用。 附上别人的博客链接#pragma once与#ifndef解析 时间线比较新的分析インクルードガードとpragma once stackoverflow上关于上述两种方式的争论#pragma once vs include guards? 道听途说1.关于C++中的资源释放一般在c++中应该是资源的获取与申请（new等等的操作）与资源的释放都是需要程序员手动操作的。但是如果使用了UE管理的资源，比如继承了UE中的类库等等的操作，那么释放这些资源的操作，在UE中会自动释放而不需要程序员的额外操作，反而要是操作了还会出问题。 当然这个问题只是道听途说，未能够验证。 当然需要仔细调查了啊 2.关于UE中UObject的派生对象的垃圾回收问题如果一个UObject的派生类对象中有一个UObject的派生类对象的指针变量，当这个指针变量经过NewObject&lt;&gt;()的操作实例化了之后，这个实例化对象就成为了GC对象（garbage collection）,不需要显式的delete垃圾回收了。 只是指针变量在声明的时候最好加上UPROPERTY()来让GC更好的回收12UPROPERTY()UObject* MyObjectReference; 总结来说，在C++中使用了new等等的方式来申请了一部分空间的话在使用结束的时候需要显式的释放掉，否则的话就会造成内存泄漏。然而上述的使用方式会使得得到的资源自动回收。 参考来源[Question]UObject Pointer References]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>UnralEngine4</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#中的单例模式-SingletonPattern]]></title>
    <url>%2F2018%2F07%2F15%2FC%23%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-SingletonPattern%2F</url>
    <content type="text"><![CDATA[这次来整理一下C的单例模式，参考的文章是Implementing the Singleton Pattern in C#。 曾经在做一个数据库管理类中经常多次使用了一个数据库管理的实例类对象，每次在新的不相关的类中需要使用数据库操作的时候都重新实例化一个数据库管理类对象，久而久之就觉得有些麻烦。便决定使用单例模式来管理，同时深究一下单例模式与C#中的使用。 算是这篇文章的汉化与总结吧。 –未完–]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Semaphore-信号量]]></title>
    <url>%2F2018%2F06%2F28%2FSemaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Semaphore,中文叫信号量，日语叫セマフォ（= .=）。经常会在多线程的编程中用到。信号量说简单点就是为了线程同步，或者说是为了限制线程能运行的数量。 仔细说明一下就是，信号量会在内部维护一个计数器，当一个线程调用了这个信号量，计数器就会减1，直到计数器减为0，调用这个信号量的线程将会被阻塞，直到有别的线程释放掉一个信号量使其计数器加1。 那么问题就来了，这个信号量维护的这个计数器应该是对线程的死锁有所防护的，也就是说同一时间只有一个线程能过获取这个信号量，而且当线程获取信号量的时候对信号量中的计数器进行减操作是具有原子性的操作。对于这个计数器的保存位置应该深入调查一下。 实例代码：12345678910111213141516171819202122232425262728293031323334353637383940414243using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading;namespace Semaphore1&#123; class Program &#123; //我设置一个最大允许5个线程允许的信号量 //并将它的计数器的初始值设为0 //这就是说除了调用该信号量的线程都将被阻塞 static Semaphore semaphore = new Semaphore(0, 5); static void Main(string[] args) &#123; for (int i = 1; i &lt;= 5; i++) &#123; Thread thread = new Thread(new ParameterizedThreadStart(work)); thread.Start(i); &#125; Thread.Sleep(1000); Console.WriteLine(&quot;Main thread over!&quot;); //释放信号量，将初始值设回5，你可以将 //将这个函数看成你给它传的是多少值，计数器 //就会加多少回去，Release()相当于是Release(1) semaphore.Release(5); &#125; static void work(object obj) &#123; semaphore.WaitOne(); Console.WriteLine(&quot;Thread &#123;0&#125; start!&quot;,obj); semaphore.Release(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS真机安装Build出错]]></title>
    <url>%2F2018%2F06%2F08%2FiOS%E7%9C%9F%E6%9C%BA%E5%AE%89%E8%A3%85Build%E5%87%BA%E9%94%99%2F</url>
    <content type="text"><![CDATA[为了面试，需要用尽一切手段了，把自己的毕业设计的时候做的2D游戏也拿出来了（捂脸）。找到了自己之前保存好的已经编译好的安装包，希望能够平安无事的安装到自己的系统高版本的iPhone7上。但是再次编译的时候果不其然还是要报错。1'__declspec' attributes are not enabled; use '-fdeclspec' or '-fms-extensions' to enable support for __declspec attributes 但是无论是Xcode还是Unity都已经升级的面目全非了，打开以前保存的Unity工程果不其然各种报错。想要解决出现的问题，第一个是NGUI的版本问题，代码中出现的一部分说是已经不支持Unity5.4+了…上网搜了一下，结果没有找到任何解答。 第一下就碰壁，只能再回去找已经编译好的文件的Build错误了。 问题解决继续搜关键词，看到了Unity社区中有一个这个提问：Error “unknown type name __declspec” after Xcode 7.3 upgrade 出问题的代码部分跟我的是一样的:1234567NORETURN static void il2cpp_codegen_raise_exception (Il2CppCodeGenException *ex)&#123; il2cpp::vm::Exception::Raise ((Il2CppException*)ex);#if __has_builtin(__builtin_unreachable) __builtin_unreachable();#endif&#125; 当然我是根本不知道这几行代码到底是干什么的。但是就是出错了…继续往下看，好像看到了一个解决方案: It has helped me: 1) Remove ‘NORETURN’2) Clean build3) Build it Like a hack:) XCode7.3, Unity5.2.2 UPD: XCode7.3, Unity5.3.4f1 - no issue 跟我的情况太像了，抱着试一试的态度，然后…Build通过了，游戏也成功的安装到了我的手机上了。 で？这个NORETURN到底是个什么？ 查了一下发现这个属性不光是Swift中的，C++中也有。所以说我已经厌倦了什么都学，什么都学对自己来说就是什么都学不会。自己之前一段时间看了Swift然后又去干别的，妥妥的全部忘光。 noreturn in Swiftnoreturn是一种属性，被这个属性修饰的函数表示没有任何返回值，函数可以被重写，但是重写之后也必须没有返回值。 具有代表性的函数有：exit(),abort()等等。 这里有一篇介绍Swift的Attributes的文章Swift - Attributes(@attribute) について 【編集中】介绍了Swift中的修饰属性。 noreturn in C++相比之下我更在意noreturn在C++中的作用。试着查了一下What is the point of noreturn? 字面意思看起来是:不返回函数的结果，没有返回值。但实际上跟void funtion还是有很大的区别。 void function运行会返回调用函数，只不过没有返回值。 被noreturn修饰的函数在运行结束之后并不会返回调用函数。 12345678910[[ noreturn ]] void f() &#123; throw "error"; // OK&#125;void g() &#123; f(); // unreachable: 在调用了`f()`之后，下面的代码永远不会执行 std::cout &lt;&lt; "No! That's impossible" &lt;&lt; std::endl;&#125; 别的事情不说，每次发现这种有关语言的语法的地方不明白的时候，就觉得特别打脸。]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>Bugs</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zsh找不到gulp工具包]]></title>
    <url>%2F2018%2F05%2F30%2Fzsh%E6%89%BE%E4%B8%8D%E5%88%B0gulp%E5%B7%A5%E5%85%B7%E5%8C%85%2F</url>
    <content type="text"><![CDATA[不能上网，一上网问题就接踵而来。今天突然看到了hexo博文压缩这个功能，就想着这个可以有，就按照教程安装了gult。安装完运行hexo g &amp;&amp; gulp之后准备舒舒服服的打包的时候，我一向视同己出的zsh弹出来了这个提示1zsh: command not found: gulp 刚装的你跟我说找不到？我信了你的邪。 自己解决应该是有点难度了，只能借用大家的智慧了。在网上搜到了这两篇博文COMMAND NOT FOUNDWITH A NODE MODULE (NPM) SOLUTION与【gulp】zsh: command not found: gulp!!!「急にgulpが壊れた!」と思ったら読む記事完美的解决了我的问题。 原因可以从下面的命令中看出来 1234➜ blog npm root/Users/stone/Documents/mynote/BLOG/blog/node_modules➜ blog npm root -g/Users/stone/node_modules gulp被安装到了个人文件夹中去而不是NPM命令的全局文件夹。 解决办法是运行下面的命令1npm config set prefix /usr/local 再运行一次npm root -g应该就会看到执行后的结果变化12➜ blog npm root -g/usr/local/lib/node_modules 然后再次安装gulp，应该是全局的安装1npm i -g gulp 确认gulp的版本123➜ blog gulp -v[23:25:50] CLI version 3.9.1[23:25:50] Local version 3.9.1 出现了一个CLI版本跟一个本地的版本。嘛，反正是好用了。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown文件转换为PDF文件]]></title>
    <url>%2F2018%2F05%2F29%2FMarkdown%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E4%B8%BAPDF%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近闲来无事(实际上由于跳槽面试的原因忙的要死)，在知乎上看到了一篇搭建博客的文章，看了一眼发现对于我这种WEB盲还挺友好，于是就自己搭建了这个博客。 就在ZH上捞鱼捞的正爽的时候，面试(未)公司发来了要看看我的作品的消息。我一看表现的时候到了，就掏出我刚学的Markdown来写了几篇我的作品的说明文。正当我想把刚build好的html文件打包压缩发送过去的时候，(自动脑补柯南的灵光一闪音效)我发觉事情并不是这么简单。 要是我作死直接发了一堆html过去，估计就别想见到人家了，就算见到了人家公司的HR，估计见面也有不小的概率会被锤。这个时候慌乱的我,手不由自主的打开了谷歌并输入了:How to convert markdown to pdf.然后发现正确的提问用法是:How to convert from markdown to pdf. (；´∀｀)嘛，英语不好这得批评，早晚得去考一次托福… 搜到的第一个是说用谷歌上的插件:Markdown Preview Plus - Chrome Webstore.ドラッグアンドドロップ就可以转换了。什么？ドラ…什么的，打开谷歌翻译:drag and drop.我… 但是利用网上的插件总感觉有些难受，还要上传文件什么的，万一上传到人家服务器上被人家看到了里面的内容就不好了(WEB盲)。于是看到了第二个方法：使用Node.js的工具markdown-pdf 1npm -g install markdown-pdf 安装好工具之后 1markdown-pdf 我的说明文.md 就能生成想要的PDF文件了。浏览生成的PDF文件的时候唯一在意的就是Markdown给隐藏起来的URL链接PDF文件也一并显示了出来。难不成是制作人有意这样，亦或者是机关在作祟，我就暂时不得而知了。因为现在的我得等人家的面试通知。 唉…寝よう]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Markdown</tag>
        <tag>碎碎念</tag>
      </tags>
  </entry>
</search>
