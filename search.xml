<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++中的各种文件操作]]></title>
    <url>%2F2019%2F03%2F15%2FC%2B%2B%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[说到LOG的制作那么文件读写就肯定有大费周折了，当然不是我大费周折，我用的人家现成的东西。但是读起来其实挺费劲的，谁让我这么菜呢。 打开文件_sopen_s, _wsopen_s打开文件以供共享。 参考官方文档： _sopen_s,_wsopen_s 操作文件_lseek将文件指针移动到指定位置 官方文档： _lseek, _lseeki64 _write将数据写入文件 官方文档： _write 关闭文件_close关闭文件。 关于这些函数的用法在我最近读的plog里面都有，有空再仔细整理一下吧。 还有一些其他的用法调查一下就知道了，想了想花时间写一下也好但是收益不大，暂时先记下吧。 errno]]></content>
      <categories>
        <category>C++</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么要用size_t]]></title>
    <url>%2F2019%2F03%2F12%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8size-t%2F</url>
    <content type="text"><![CDATA[总的来说就是为了提高代码的可移植性，有效性或者可读性。 Why size_t matters 之后整理一下这篇文章的内容。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[new与malloc的区别]]></title>
    <url>%2F2019%2F03%2F12%2Fnew%E4%B8%8Emalloc%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[new/delete与malloc/free显而易见的区别是，前者会调用对象的构造/析构函数，而后者不会。 再仔细说明就是new的操作是新建对象 ，而malloc只是分配一块内存而已。 在Stack Overflow上有更为详尽的说明，有时间的话好好整理一下。 What is the difference between new/delete and malloc/free?]]></content>
      <categories>
        <category>C++</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的运算符重载]]></title>
    <url>%2F2019%2F03%2F05%2FC%2B%2B%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[运算符重载(operator overloading)只是一种”语法上的方便“（syntactic sugar).也就是说它只是另一种函数调用的方式。 运算符重载有成员与算符和非成员运算符之分，那么这个之间有什么区别呢，应该选择哪一种呢？ 总的来说，如果没有什么差异，它们应该是成员运算符。这样做强调了运算符和类的结合。当左操作数是当前类的对象时，运算符会工作的很好。 但有的时候左侧操作数是别的类对象。这种情况通常出现在输入输出流重载operator&lt;&lt;和&gt;&gt; 时。因为输入输出流是一个基本C++库。 这里就说到了关键了。为了应付各种数据类型的输出，输入输出流的重载就很重要了。 1// 代码之后贴 这里我先暂停一下，说一说为什么要认识运算符重载这个问题。 举例来说，cout这个类是我学C++最早接触的对象了之一了，但是却很不是理解。其实即就是cout对&lt;&lt;运算符进行了重载。 我自己创建了一个Record类，希望这个类能对接在&lt;&lt;后面的数据进行一些操作，比如说接收数据什么的。12Record &lt;&lt; 2;Record &lt;&lt; "str string"; 想这样把后面的数据接收保存在类内变量中。就这样我遇见了下面的代码:12345678// 在Record类内template&lt;typename T&gt;Record&amp; operator&lt;&lt;(const T&amp; data)&#123; m_message &lt;&lt; data; return *this;&#125; 代表着混沌势力的模板登场了（对我来说)。这里就涉及到了函数模板的问题。我看到上面的代码的时候第一反应是，这段代码能直接用？ 答案是肯定的，像类模板的使用那样，指定明确的模板参数类型来特化函数模板使用是可行的，也就是我觉得应该这样做的，但是让编译器从函数的参数中推断出它们的类型将会更方便。 后面的内容就更多了，在别的模板章节中展开更好。 回到上面的代码，m_message &lt;&lt; data 的m_message是什么类型合适呢？是ostringstream。是C++标准库的东西，这样就省得自己一个一个重载数据类型了。方法是个好方法，但是最后我没用上。因为要处理宽字符的问题，涉及到宽窄字符互相转换的问题，试来试去总是出问题，我就Pass掉了，全部交给UE4里的FString类型和TEXT（）来处理了。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++-制作一个静态的单一实例]]></title>
    <url>%2F2019%2F03%2F01%2FC%2B%2B-%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E7%9A%84%E5%8D%95%E4%B8%80%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[制作单一实例，就会想到Singleton，单例模式。在C++里面如何制作一个唯一的一个实例，我只是有一个想法，然后付诸实践。也许这个想法或许是错的。但是重要的是我将这个想法付诸实践的过程，这个过程中我明白了许多知识点，只是不想忘记而已。 指定需要单例化的类首先要选一个适合的类进行单一实例化。举例来说我现在正在制作一个日志系统，故而我希望有一个唯一的实例Logger来管理关于日志的一切。所以我声明了以下： 12345678910111213// Logger.hclass Logger&#123; Logger(); ~Logger();&#125;// Logger.cpp#include "Logger.h"Logger::Logger()&#123;&#125;Logger::~Logger()&#123;&#125; 像这样子。 制作一个单例模板关于这个单例模板其实我也不太清楚具体是为什么而制作的，只是我在学习plog这个日志库的时候看到就学了。首先它是一个模板，怎么用为什么要这么用，需要我理解模板的使用。 12345678910111213141516171819202122232425262728293031template&lt;class T&gt;class Singleton :NonCopyable&#123;public: Singleton() &#123; if(m_instance == NULL) &#123; m_instance = static_cast&lt;T*&gt;(this); &#125; &#125; ~Singleton() &#123; if(m_instance != NULL) &#123; m_instance = 0; &#125; &#125; static T* getInstance() &#123; return m_instance; &#125;private: static T* m_instance;&#125;template&lt;class T&gt;T* Singleton&lt;T&gt;::m_instance = NULL; 先把出现的NonCopyable类的出现放在一边，讨论一下这个模板。 这个模板有一个私有静态属性，类型为T，而且在构造函数里面进行了像下类型转换，使用`static_cast，这个算是骚操作么，我也不太清楚。还有注意取得这个属性的指针函数是静态的，也就是有准备把这个单一实例声明为静态的。 总结一句话来说就是我们得到使用了这个模板并实例化成功的静态实例的指针引用。 引用这里让我有些不舒服的是引用这个词，按照我所理解的，引用和指针并不是一样的： 引用（reference）（&amp;）就像能自动的被编译器间接引用的常量型指针。 关于这一部分我应该是需要用大量的时间去理解的。在C++编程思想第一卷第十一章的-引用和拷贝构造函数里面有较为详细的说明。之后也会有提到。 静态类成员关于静态类成员，Static Members of a C++ Class 里面的说明应该很详细了。 要点在于: 静态类成员只有一份拷贝，无论类被实例化了多少次。 静态类函数只能调用静态类成员。 可以使用类公开的静态成员和静态函数，甚至类没有被实例化。 类静态成员没有this指针，可以用&lt;类名&gt;::&lt;静态成员&gt;来获取。 静态类成员必须在类外初始化 这个是我制作的单例模式的关键理解部分。 关于NonCopyable类这个类可谓是突然出现在我的面前，一查却发现大有来历。就是一个防止类被复制的类。123456789class NonCopyable&#123;protected: NonCopyable()&#123;&#125;private: NonCopyable(const NonCopyable&amp;); NonCopyable&amp; operator=(const NonCopyable&amp;);&#125; 这个地方涉及了许多拷贝构造函数相关的东西，C++编程思想第一卷第十一章-引用和拷贝构造函数的内容，之后需要好好理解。 静态实例实装经过上面的洗礼，我试着写成下面这样：123456789101112class Logger : public Singleton&lt;Logger&gt;&#123;private: static Logger logger;private: Logger(); Logger(const Logger&amp;); ~Logger();&#125;Logger Logger::logger = Logger(); 我在类里面声明了一个自身类的静态实例。加上继承来的静态方法可以取到这个静态实例。然后定义了它。 这里有一个问题就是，当我在类外面定义logger的时候，Logger Logger::logger = Logger();,编译报错了，因为当时我没有加上Logger(const Logger&amp;);这句话。 这句话是什么呢，貌似就是所谓的拷贝构造函数。并且被设置成了私有的。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++编程思想-第16章-模板介绍]]></title>
    <url>%2F2019%2F02%2F22%2FC%2B%2B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC16%E7%AB%A0-%E6%A8%A1%E6%9D%BF%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[记下关于模板的知识与理解。 继承和组合提供了重用对象代码的方法，而C++的模板特征提供了重用源代码的方法。 截止到最近为止我对模板的理解也就之停留在表面:作为一种类型的容器。比如说实现一个可以存储任类型的Stack，有一些共同的操作，当你想使用的时候放入具体的类型进行实例化(instanation)。容器，貌似很好理解的样子。 这也是文章开头所提的到的部分，最最简单且易为理解的部分。 小tips： staic int a[100];这样的写法，编译器会将这个static数组初始化为0. 模板介绍(第十六章)16.3模板语法template这个关键字会告诉编译器，随后的类定义将操作一个或更多未指明的类型。当由这个模板产生实际类代码的时，必须指定这些类型以使编译器能够替换他们。123456789101112131415161718192021using namespace std;template&lt;class T&gt;class Array&#123; enum &#123; size = 100; &#125;; T A[size];public: T&amp; operator[]（int index)&#123; require（index &gt;= 0 &amp;&amp; index &lt; size, "Index out of range"); return A[index]; &#125;&#125;int main()&#123; Array&lt;int&gt; ia; Array&lt;float&gt; fa; // ......&#125; 这时，编译器两次扩展了Array模板【这被称为实例化(instantiation)】，创建两个新的生成类（generated class），可以把它们看做Arrray_int和Array_float（不同的编译器对名称有不同的修饰方法）。这些类就像是手工创建的一样，只是这里是当定义了对象ia和fa后由编译器来创建这些类。我们还会注意到，编译器避免了或者连接器合并了类的重复定义。 16.3.1非内联函数定义希望有非内联函数定义的时候，这时编译器需要在成员函数定义之前看到template声明。 1234567891011121314template&lt;class T&gt;class Array &#123; enum &#123; size = 100; &#125; T A[size];public： T &amp;operator(int index);&#125;;template&lt;class T&gt;T&amp; Array&lt;T&gt; ::operator[](int index)&#123; require（index &gt;=0 &amp;&amp; index &lt; size), "Index out of range"; return A[index];&#125; 关于内联函数和非内联函数的定义在别的章节会有提到。在此不赘述。 在引用模板的类名的地方，必须伴有该模板的参数列表，这样在按照模板生成实例的时候，因为模板参数中的参数修饰类名，以便为每一个模板实例产生唯一的类名标识符。 因此模板的参数列表在引用模板类名的时候，也要有一席之地。 模板的非内联函数定义之前一定要加上template声明。 16.3.1.1头文件 即使是在创建非内联函数定义时，我们还是把模板的所有声明和定义都放入一个头文件中。这似乎违背了通常的头文件规则：“不要放置分配存储空间的任何东西”（这条规则是为了防止在连接期间的多重定义错误），但模板定义很特殊。在template&lt;…&gt; 之后的任何东西都意味着编译器在当时不为他分配存储空间，而是一直处于等待状态直到被一个模板示例告知。在编译器和连接器中有机制能去掉统一模板的多重定义。所以为了使用方便，几乎总是在头文件中防止全部的模板声明和定义。 16.3.3模板中的常量 模板参数并不局限于类定义的类型，可以使用编译器内置类型。这些参数值在编译期间变成模板的特定示例的常量。我们甚至可以对这些参数使用默认值。 12345678910111213141516171819202122232425262728293031323334353637383940414243template&lt;class T, int size = 100&gt;class Array&#123; T array[size];public： T&amp; operator[](int index)&#123; require(index &gt;=0 &amp;&amp; index &lt; size, "Index out of rande"); return array[index]; &#125; int length() const &#123; return size; &#125;&#125;;class Number &#123; float f;public: Number(float ff = 0.0f) : f（ff) &#123;&#125; Number&amp; operator=（const Number&amp; n)&#123; f = n.f; return *this; &#125; operator float() const &#123; return f; &#125; // ???? friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Number&amp; x)&#123; return os &lt;&lt; x.f; &#125;&#125;;template&lt;class T, int size = 20&gt;class Holder&#123; Array&lt;T, size&gt;* np;public： Holder() : np(0) &#123;&#125; T&amp; operator[](int i) &#123; require(0 &lt;=i &amp;&amp; i &lt; size); if(!np) np = new Array&lt;T, size&gt;; return np-&gt;operator[](i）； &#125; intlength() const&#123; returnsize； &#125; ~Holder() &#123;delete np;&#125;&#125;;int main()&#123; Holder&lt;Number&gt; h; // ......&#125; 上面的例子中的size的值没有房放在类中，但是对他的使用就如同是成员函数中的数据成员。 我记录下来上面这段代码的原因还有一个就是懒惰初始化(lazy initialization).上面的Holder中有一个指向Array的指针，而不是指向类型Array的嵌入对象。该指针在构造函数中不被初始化，而是被推迟到了第一次访问的时候。还有等等的稀有的用法。 这个章节还有许多其他内容，但是貌似跟我现在急需要理解的内容相差甚远，暂时保留。 第二卷第五章 深入理解模板关于模板的使用问题，在真正的使用模板之前一定要先让编译器看到模板的声明和定义，比如说在同一个文件里写一个类继承一个模板的时候，模板的声明和定义不能在类的下方，应该先写模板再用。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的强制类型转换-cast]]></title>
    <url>%2F2019%2F02%2F18%2FC%2B%2B%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-cast%2F</url>
    <content type="text"><![CDATA[实在是遇见太多次了，遇见了还看不懂，再不整理就过分了。关于C++中的强制类型转换问题。这次的主角是:stati_cast,dynamic_cast,const_cast,reinterpret_cast。 static_cast提笔要写，先看别人的总结 When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used? 这里我遇见的情况就是static_cast的重要的用法。继承类型的向下类型转换。下面来看看我遇见的神仙代码：123456789101112131415161718192021222324252627template&lt;class T&gt;class Singleton : NonCopyable&#123;public: Singleton() &#123; assert(!m_instance); m_instance = static_cast&lt;T*&gt;(this); &#125; ~Singleton() &#123; assert(m_instance); m_instance = 0; &#125; static T* getInstance() &#123; return m_instance; &#125;private: static T* m_instance;&#125;;template&lt;class T&gt;T* Singleton&lt;T&gt;::m_instance = NULL; 一个单例模板类，读代码的时候，按照这个模板被实例化的是他的子类，顺便这个子类所具有的instance的引用就变成它自己了。我什么时候也能写出这么优秀的代码。 还有其他的强制类型转换，遇见的时候具体分析吧。 const_cast在做各种数据类型匹配的时候，遇到了这样的问题：123// UE4 C++FString text = "111";TCHAR* t_text = *text; 上面是想把FString类型转化为TCHAR*类型的数据。 但是上面的会报错，原因是无法将const THCAR*转化为TCHAR*。那就直接加上关键字const就解决了。但是问题是这个t_text是我设置的即将要传入另外一个函数的参数，它要是设置为常量类型的话就没法传参了。 把常量指针变成普通的指针，就是我接触到const_cast的起因。但是关于它的使用，可不是一句话就能总结的。 const_cast实现的原因在于C++对于指针的转换是任意的，它不会检查类型，任何指针之间都可以进行互相转换。 去const限定12const TCHAR* t_text = "1234";TCHAR* text = const_cast&lt;TCHAR*&gt;(t_text); 将常量指针转化为了正常指针，但是正常情况下不会做这种弱智操作。正常声明就行了，但是有的时候要传参的情况传的不是常量怎么办，那只好强制转换了。 去const限定的操作绝对不是为了修改它的内容，既然声明了常量还要修改那为什么还要声明为常量。既然声明了常量就要贯彻到底。绝对不对const数据进行重新赋值。 根据别人的文章内容，强行修改常量的值会产生未定义行为（Undefined Behavior）,这种行为由编译器决定如何处理。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的文字编码与文字存储类型]]></title>
    <url>%2F2019%2F02%2F14%2FC%2B%2B%E4%B8%AD%E7%9A%84%E6%96%87%E5%AD%97%E7%BC%96%E7%A0%81%E4%B8%8E%E6%96%87%E5%AD%97%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[在准备把函数名字输出的时候遇到了输出乱码的问题。12TCHAR* text = "DLL内容テスト。";UE_LOG(LogTemp, Log, TEXT("TEXT: %s"), text); 在我写这段代码之前我连TCHAR是什么类型都不知道，经过一番的调查，关于文字编码和文字的数据存储类型，了解到了很多。 源码的存储格式关于源码的存储格式，在我现在的地方，使用的大多是日语系统因此在什么都不动的情况下使用的是日语的默认 Japanese(Shift-JIS) 格式。至于怎么确认存储格式的话，在一些编辑器中应该就可以查看。 在Visual Studio 2017中改变文件存储格式 File -&gt; Save as -&gt; 下面Save旁边的箭头 -&gt; save with encoding -&gt; replace -&gt; Encoding 一般比较喜欢的就是Unicode(UTF-8) 就是了，毕竟兼容了英文字母之外的字符。 比如最前面把函数名字输出却遇到了乱码的的方，如果将源码存储为UTF-8格式，就不会出现乱码了。 C++中的字符存储类型关于字符的存储问题，首先要分清楚各种字符的存储类型。 char普通的8位字节类型。 wchar_t宽字符类型，表示范围要远大于char类型，表示类型有16位与32位，具体环境具体判断。Unicode编码字符一般以wchar_t类型存储。 为了让编译器识别Unicode字符串，必须在前面加一个L :1wchar_t * text = L"这是中文字符"; 看到这个L，让我想起了现在看的一个日志开源库里的一段糟心的代码：12345678910#ifdef _WIN32# define _PLOG_NSTR(x) L##x# define PLOG_NSTR(x) _PLOG_NSTR(x)#else# define PLOG_NSTR(x) x#endif// UsagePLOG_NSTR("context"); 简单来说就是一个把字符串添加L的宏，刚开始看到的时候糟心的不行。这段内容使用Unicode编码的意思，但是这里有一个问题： 添加了L也就是说是使用Unicode编码，使用wchar_t数据类型存储。接着上述例子，PLOG_NSTR宏接收的如果不是简单的英文字母而是汉字或者日语，简单地输出会正确的输出吗？ 此时源码的存储格式是否支持Unicode编码会产生影响吗？ Shift-JIS格式的源码配合英文字母是能够正确输出的(源码是DLL) 1234PLOG_NSTR("line@");// outputline@ Shift-JIS格式的源码配合日文内容也是能够正确输出的(源码是DLL) 1234PLOG_NSTR("line内容テスト@");// outputline内容テスト@ 当在UEEditor中实验的时候，Shift-JIS的格式源码没有正确输出。 结论：源码的存储格式应该存储为Unicode格式。在字符编码想要支持Unicode和ANSI两种格式的时候应该添加类似以下的宏123456#ifdef _UNICODE#define __T(x) L##x#define _T(x) __T(x)#else#define _T(x) x#endif 关于为什么不直接使用添加L的宏的原因是：防止数据变量声明和定义时的类型冲突。使用宏避免char与L的宽字符存储类型冲突。 在tchar.h文件中可以找到关于__T(x)宏的定义，貌似不包含这个文件的时候，自己定义也可以。 TCHARTHAR是对上述两种字符存储类型的统一，参考以下：12345#ifdef UNICODEtypedef wchar_t TCHAR;#elsetypedef char TCHAR;#endif 当程序定义了UNICODE的时候TCHAR就是宽字符存储类型即wchar_t，当未定义的时候就是普通的char数据类型。 UE4中的字符类型转换当对字符的存储类型有了一些了解，就来看看他们之间的转换吧。先列出一些参考文章： Charactor Encoding C++宽字符当我觉得我能理解并分别和使用C++中的宽字符的时候，现实告诉我还是太天真了。 先看看这篇文章： 彻底解密C++宽字符 写了很多我看不懂的，就是很复杂。我有照着别的示例程序试着写了一下宽窄字符转换，但是英文还好，没看出来什么变化，但是把日语从const char* 变成const wchar_t*的时候乱码还是乱码。 我使用的是mbstowcs函数来实现的，微软的官网文档也有介绍。官方推荐的是使用mbstowcs_s这个函数。有机会的话可以再试试。 应该有更深层次的原因，只不过我放弃了。借用4的FString和TEXT()宏来解决了。 我在plog中看到的宽窄字符转换跟下面的很像说不定好用：12345678910111213// Unicode字符集下可用//--------------------------------------------------------宽字符串转换到窄字符串char* pC = NULL; wchar_t wStr[20] = L"宽字符串"; int iLen = WideCharToMultiByte( CP_ACP,0,wStr,-1,NULL,0,NULL,NULL); if( iLen &gt; 0 )&#123; pC = ( char* )HeapAlloc( GetProcessHeap() ,0 ,iLen ); if( !pC ) return; WideCharToMultiByte( CP_ACP ,0 ,wStr ,-1 ,pC ,iLen ,NULL ,NULL ); printf( "%s \n", pC ); HeapFree( GetProcessHeap() ,0 ,pC );&#125; 123456789101112//--------------------------------------------------------窄字符串转换到宽字符串char cStr[20] = "这是窄字符串";wchar_t* pWideString = NULL;int iLenWide = MultiByteToWideChar( CP_ACP ,0 ,cStr ,-1 ,NULL ,0 ); if ( iLenWide &gt; 0 )&#123; pWideString = ( wchar_t* )malloc( iLenWide * sizeof(wchar_t) ); if( !pWideString ) return 0; MultiByteToWideChar( CP_ACP ,0 ,cStr ,-1 ,pWideString ,iLenWide ); MessageBox( NULL, pWideString , 0 , 0 ); free( pWideString ); &#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识DLL-在UE4与Unity中使用DLL]]></title>
    <url>%2F2019%2F01%2F28%2F%E5%88%9D%E8%AF%86DLL-%E5%9C%A8UE4%E4%B8%8EUnity%E4%B8%AD%E4%BD%BF%E7%94%A8DLL%2F</url>
    <content type="text"><![CDATA[记录自己逐步认识和掌握DLL的过程。包含了创建DLL，在UE4中使用DLL，在Unity中使用DLL。 新建DLL工程先新建一个简单的DLL工程，然后在里面添加内容，方法可以参照： Linking Dlls 导出函数添加了具体的库的功能之后，需要将函数导出供外部使用。1234567891011121314#pragma once#define DLL_EXPORT __declspec(dllexport)#ifdef __cplusplusextern "C"&#123;#endif int DLL_EXPORT ExportFuncName()&#123; return 0;&#125; // ......#ifdef __cplusplus&#125;#endif 像这样，上述的函数就被导出，能够被外部调用了。 导出函数的时候遇到的问题当我在UE4中使用inline这个关键字的时候，给我报错了。 我在DLL导出函数的时候，导出的函数前面加了inline关键字，所以把导出函数的定义跟声明都写在了头文件里。发生了什么呢？ 在UE4中我获取到了DLL Plugin中的dll库，得到了DLL的Handle，但是准备使用这个Handel取出里面的函数的时候，取出来的是空。函数名什么的都是正确的情况下。 发生上述的情况下我试着去掉DLL中的导出函数的inline声明，声明和定义分开在头文件和cpp文件，就解决了。 回归第一句的事实，貌似UE4C++中对于inline关键字是不支持的。哪怕是动态库中导出来的函数。 UE4Editor中调用DLL在文章最开始的地方提到的链接已经说明的很清楚了。 要点在于: 把制作好的DLL放到特定的文件夹中，一般是Plugin文件夹里面建立一个Plugin。 创建一个类继承BlueprintFunctionLibrary这样蓝图也能使用 声明的函数要是静态的（static） 调用DLL中的函数的步骤是: 定义一个函数指针用来接收DLL中导出的函数(Use typedef to declare a method to store the DLL method) 声明一个Handle来保持与DLL的连接（void* v_dllHandle) 都不为空的时候调用导出来的函数。 123456789101112131415161718192021222324typedef int(*_getFunc)(int a, int b);_getFunc m_getFuncFromDll;void * v_dllHandle;void ULOGBlueprintFunctionLibrary::DLLFunc(int a, int b）&#123; FString dllfilepath = FPaths::Combine(*FPaths::ProjectPluginsDir(), TEXT("DLLLibrary"), TEXT("DLLName.dll")); if(FPaths::FileExists(dllfilepath)) &#123; v_dllHandle = FPlatformProcess::GetDllHandle(*dllfilepath); if(v_dllHandle != NULL) &#123; FString procName = "FunctionName"; m_getFuncFromDll = (_getFunc)FPlatformProcess::GetDllExport(v_dllHandle, *procName); if(m_getFuncFromDll != NULL) &#123; m_getFuncFromDll(a,b); &#125; &#125; &#125;&#125; 使用的方法就像述。 DEBUG DLL关于DLL的DEBUG的问题，直接在工程里面DEBUG的方法我没有头绪。目前的方法是： 选中Build的模式为Release，x64然后编译。在工程文件夹中找到编译完毕的dll文件导入到调用的工程里面进行调用测试。 其他DLL中头文件的引入在使用plog 源码的时候尝试引入头文件的地方：12// for example#include &lt;plog/Util.h&gt; 上面的引入会出错，而把尖括号换成双引号后就好了。 关于这两者的区别： 用尖括号来指定文件时，预处理器是以特定的方式来寻找文件，一般是环境中或编译器命令行指定的某种寻找路径。这种设置寻找路径的机制随机器，操作系统，C++实现的不同而不同，要视具体的情况而定。 用双引号来指定文件时，预处理器是以“由实现定义的的方式”来寻找文件。它通常是从当前的目录开始寻找，如果没有找到，那么include命令就按与尖括号同样的方式开始寻找。 要说DLL不支持尖括号的查找也不是，内置的一些库还是可以使用尖括号来include的，难不成自己添加的文件就要使用双引号吗？ 另外关于头文件返回上一级路径的写法：1#include "../Util.h" 函数名字前面加上&amp; In C++, when the ref-sign(&amp;) is used before the function name in the declaration of a function it is associated with the return value of the function and means that the function will return by reference. Use of ‘&amp;’ operator before a function name in C++ C++类构造函数初始化列表 Constructor member initializer lists 可以参照以上的文章，主要是可以在声明的同时初始化，在构造函数里面的知只是赋值操作，不是所谓的初始化。 比如说类中想要拥有const类型的变量的话，可以利用构造函数的初始化函数列表来给类中常量赋初值。 C++中的函数指针C++运算符重载C++中的流要把流与字符串分开来看，流是对象，可以用来处理字符串。 stringstreamst(), c_str()函数深入理解char*与char[]的差别关于类中静态成员的理解这里需要强调理解的是，类中静态成员的存储位置是静态存储区，只有一个拷贝，无论类被实例化了多少个，静态成员只有一个，还有一些其他的重要的使用方式，之后整理。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中得到函数名字]]></title>
    <url>%2F2019%2F01%2F28%2FC%2B%2B%E4%B8%AD%E5%BE%97%E5%88%B0%E5%87%BD%E6%95%B0%E5%90%8D%E5%AD%97%2F</url>
    <content type="text"><![CDATA[应某个要求，需要在运行过程中打印出运行的信息，即所谓的LOG收集，此时希望一起打印出来的内容包含调用的函数信息。 在Python中就有这种库，直接能得到函数的调信息名字全部打印出来。但是在C++中就没有现成的库。 自己创建一个库？对我来说还是太早了。 在C++中得到函数名字 __func__可以得到函数名字。在函数里面调用输出就好。 123FString fun_name = FString(UTF8_TO_CHAR(__func__));UE_LOG(LogTemp, Log, TEXT("Function name is : %s), *fun_name); __FUNCTION__可以得到类名加函数名。 123FString func_name = FString(UTF8_TO_CHAR(__FUNCTION__));UE_LOG(LogTemp, Log, TEXT("Function name is : %s), *func_name); 以上是在UE4引擎中输出的结果，也有试过__PRETTY_FUNCTION__来输出但是出现了编译错误。 参考文章： 6.49 Function Name as Strings How to get function name in C++]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EffectiveC++-Chapter01-Accustoming-Yourself-to-C++]]></title>
    <url>%2F2019%2F01%2F10%2FEffectiveC%2B%2B-Chapter01-Accustoming-Yourself-to-C%2B%2B%2F</url>
    <content type="text"><![CDATA[Effective C++的第一章内容总结。 条款01：View C++ as a federation of languages.(视C++为一个语言联邦) C Object-Oriented C++ Templete C++ STL 例如对内置（也就是C-like）类型而言pass-by-value通常比pass-by-reference高效，但当你从C part of C++移往Object-Oriented C++，由于用户自定义的（user-defined)构造函数和析构函数的存在，pass-by-reference-to-const往往更好。运用Template C++时尤其如此，因为彼时你甚至不知道所处理的对象的类型。然而一旦跨入STL你就会了解，迭代器和函数对象都是在C指针之上塑造出来的，所以对STL的迭代器和函数对象而言，旧式的C pass-by-value守则再次适用（参数传递方式的选择细节请见条款20）。 条款02：Prefer consts,enums,and inlines to #define.(尽量以const,enum,inline替换#define)123456class GamePlayer &#123;private: enum &#123; NumTurns = 5&#125;; // "the enum hack"补偿作法。以保证NumTurns在编译期间有正确的值 int scores[NumTurns]; // 本是定义的地方，NumTurns未必会有初值，编译器也许会报错&#125; 基于数个理由enum hack值得我们认识。第一，enum hack的行为某方面说较像#define而不像const，有时候这正是你想要的。例如取一个const的地址是合法的，但取一个enum的地址就不合法而取一个#define的地址通常也不合法。 认识enum hack的第二个理由纯粹是为了实用主义。许多代码用了它，所以看到它是你必须认识它。事实上，“enum hack”是template metaprogramming(模板元编程)的基础技术。 12345678#define CALL_WITH_MAX(a, b) f((a) &gt; f(b) ? (a) : (b))// 推荐的写法template&lt;typename T&gt;inline void callwithmax(const T&amp; a, const T&amp; b)&#123; f(a &gt; b ? a : b);&#125; 使用template inline函数（见条款30）也可以获得类似宏带来的效率以及一般函数所有可预料行为和类型安全性（type safety）。 请记住： 对于单纯常量，最好以const对象或enums替换#define 对于形似函数的宏（macs），最好改用inline函数替换#define 条款03：Use const whenever possible(尽可能使用const)]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EffectC++-导读]]></title>
    <url>%2F2019%2F01%2F07%2FEffectiveC%2B%2B-%E5%AF%BC%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[Effective C++ 的导读章节的内容整理，知识点备忘吧。应该会将以后的章节归档到一起。 术语（Terminology)关于声明与定义应该有了初步的认识，在其他的C++学习章节有提到过这之间的区分。 定义式(definition)的任务是提供编译器一些声明式所遗漏的细节。对对象而言，定义式是编译器为此编译器拨内存的起点。 这里有一个对于初始化(initialization)的default构造函数的认知误区： default构造函数是一个可被调用而不带任何实参 这样的构造函数要不没有参数，要不就是每个参数都有缺省值 不是说构造函数就是没有参数的。 explicit关键字应用场景：123456789class B&#123;public: explicit B(int x = 0, bool b = true);&#125;;class C&#123;public: explicit C(inx x);&#125;; 在构造函数的前面加上explicit关键字可以防止被用来执行隐式类型转换(implicit type conversions)，但是仍可以被用来进行显式类型转换(explicit type cnversions). 比如说传参的时候，参数应该是一个类型B的对象1234567void doSomething(B bObject);B bObj1;doSomething(28); // 错误，int跟B之间没有隐式类型转换doSomething(B(28)); // 正确，有显式转型，即cast 虽然上述的使用是我之前知道的但是不知道为什么是正确的。为了防止构造函数被隐式类型转换，把构造函数声明为explicit是一个好的选择。 copy构造函数和copy assignment操作符 copy构造函数被用来“以同型对象初始化自我对象” copy assignment操作符被用来“从另一个同型对象中拷贝其值到自我对象” 1234567891011class Widget &#123;public: Widget(); // 默认构造函数 Widget(const Widget&amp; rhs); // copy构造函数 Widget&amp; operator=(const Widget&amp; rhs); // copy assignment操作符 ...&#125;;Widget w1; // 调用默认构造函数Widget w2 = w1; // 调用copy构造函数w1 = w2; // 调用copy assignment操作符 上述的代码应该足够说明用法，但是需要注意的是看见=的时候要注意：1Widget w3 = w2; // 调用copy构造函数 幸运的是“copy构造函数”很容易个“copy赋值”有所区别。如果一个对象被定义（例如以上语句中的w3)，一定会有一个构造函数被调用，不可能调用赋值操作。如果没有新对象被定义（例如前述的“w1=w2”语句），就不会有构造函数被调用，那么当然是赋值操作被调用。 STLTR1和BoostBoost]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++编程思想手抄]]></title>
    <url>%2F2018%2F11%2F01%2FC%2B%2B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E6%89%8B%E6%8A%84%2F</url>
    <content type="text"><![CDATA[好久没有看书了，最近重拾看书的习惯，放着一大本的全局光照技术不看，想看看C++的内容。因为最近在调查一个工具，看那个人写的源码，深入看下去发现这个人写的代码是真的很好，跟我之前所在现场的时候看见的那个架构十分相似，但是一个是C#，一个是C++。 想要把那份源码记在脑子里似的，希望能够多过几遍，之后肯定会用的上的。 所以言归正传，聊聊现在看的书，C++编程思想。我会记下来我觉得非常有意义的话语，多看多读，能够印在脑子里面是最好，因为有些东西知道了就想会在代码中潜移默化的表现出来。 第一章 对象导言 在面向对象的程序设计中，答案是非常新奇的：编译器不做传统意义上的函数调用。由非OOP编译器产生的函数调用会导致与被调用代码的早捆绑(early binding)，对于这一术语，读者可能还没有听说过，因为从来没有想到过它。早捆绑的意思是，编译器会对特定的函数名产生调用，而连接器将这个调用解析为要执行代码的绝对地址。在OOP中直到程序运行时，编译器才能确定执行代码的地。所以，当消息被发送给一般对象时，需要采用其他的方案。 为了解决这一问题，面向对象语言采用晚捆绑(late binding) 的思想。当给对象发送消息时，在程序运行的时候才去确定调用的代码。编译器保证这个被调用的函数存在，并执行参数和返回类型的检查【其中不采用这种处理方式的语言称为弱类型(weakly typed) 语言】，但是它并不知道将执行的确切代码。 为了执行晚捆绑，C++编译器在真正调用的地方插入一段特殊的代码。通过使用存放在对象自身中的信息，这段代码在运行时计算被调用函数函数体的地址（这一过程将在15章中详细介绍）。这样每个对象就能根据这段二进制的内容有不同的行为。当一个对象接收到消息时，它根据这个消息判断应该做什么。 我们可以用关键字virtual声明他希望某个函数有晚捆绑的灵活性。我们并不需要懂得virtual的使用机制，但是没有它，我们就不能用C++进行面向对象的程序设计。在C++中，必须记住添加virtual关键字，因为根据规定，默认情况下成员函数不能动态捆绑。virtual函数（虚函数）可用来表示出现在相同家族中的类具有不同的行为。这些不同是产生多态行为的原因。 上面的话对我从新理解C++的面向对象的程序的理解是有帮助的。 比如说这段话对于virtual的理解，不是说遇到这种情况的话需要使用virtual关键字，而是清楚地描述了这种情况下，virtual关键字可以帮助我们来实现。以前只是知道这个关键字是用来声明虚函数，但是为什么要声明虚函数呢，什么情况下声明虚函数却不清楚。 第二章 对象的创建与使用这一章虽然都是大白话，但是对于底层的描述说到底还是不是完全理解的，所以需要细致的去理解。 2.1 语言的翻译过程计算机语言转化为机器指令需要翻译器 通常，翻译器分为两类：解释器（interpreter）和编译器（compiler）。 为什么要录下这段话是因为我以为翻译器只有编译器一种呢。Python使用的就是解释器。而C++使用的就是编译器。虽然解释器与编译器之间的界限也很模糊（听说的）。 但是C++的重点在与编译器的理解上。我也有一个独立写一个编译器的梦想…… 2.1.3 编译过程关于编译的过程我看的是云里雾，所以详细了调查了一些文章。 Building C Projects - Alex Smith关于编译过程的详细说明 1.Configuration（配置） 用户系统环境配置的详细参数信息。以便编译器适应不同的用户环境配置。 2.Standard dircetor detection（确定标准库位置） 3.Source file dependency calculation（确定依赖关系） 4.Header file location（确定头文件位置） 5.Header precompilation（头文件的预编译） 6.Preprocessing（预处理） 7.Compilation and assembly（编译） 8.Object file dependency calculation 9.Linking（连接） 编译器把外部函数的代码添加到可执行文件中。静态连接 与 动态连接。 10.Installing（安装） 11.Resource linking 12.Package generation（生成安装包） 13.Dynamic linking（动态连接） 时间关系就直接把编译过程的大概列出来吧。 某些语言（特别是C/C++）编译时，首先要对源代码进行预处理，预处理器（preprocesser） 是一个简单的程序，它用程序员（利用预处理器指令）定义好的模式代替源代码中的模式。预处理指令用来节省输入，增加代码的可读性。（C++程序设计并不鼓励多使用预处理指令，因为他可能引起一些不易发现的错误，这些将在本书的后面分析。）预处理过的代码通常放在一个中间文件中。 编译一般分两遍进行。首先，对预处理过的代码进行语法分析。编译器把源代码分解成小的单元，并把它们按树形结构组织起来。表达式“A+B”中的“A”，“+”和“B”就是语法分析树的叶子节点。 有时会在编译的第一遍和第二遍之间使用全局优化器（global optimizer） 来生成更短，更快的代码。 编译的第二遍，由代码生成器（code generator） 遍历语法分析树，把树的每个节点转化成汇编语言或机器代码。如果代码生成器生成的是汇编语言，那么还必须用汇编器对其汇编。两种情况的最终结果都是生成目标模块（通常是一个以.o或.obj为扩展名的文件）。有时也会在第二遍中使用窥孔优化器（peephole optimizer） 从相邻一段代码中查找冗余语句。 上述内容大致描述了编译过程，应该还涉及到了许多之前尚未完全理解的内容吧。 2.2 分段编译工具 程序可由多个文件构成，一个文件中的函数可能要访问另一个文件中的函数和数据。编译一个文件时，C或C++编译器需要知道在另一个文件中的函数和数据，特别是它的名字和基本用法，编译器就是要确保函数和数据被正确的使用。”告知编译器“外部函数和数据的名称及它们的模样，这一过程就是声明（declaration） 。一旦声明了一个函数或变量，编译器知道怎样检查对它们的引用，以确保引用正确。 这一段话告知了声明这一概念，为什么需要声明，声明用来做什么的。声明就是像编译器告知外部自己的存在以及如何使用自己。 2.2.1 声明与定义之前从未对这两个概念进行细致的区分，或者说根本没有去注意。理解这两个概念会发现，这两个概念，还蛮重要的… 声明（declaration） 是向编译器介绍名字-标识符。它告诉编译器“这个函数或这个变量在某处可以找到，它的模样像什么”。而定义（definition） 是说：“在这里建立变量”或“在这里建立函数”。它为名字分配存储空间。无论定义的函数还是变量，编译器都要为它们在定义点分配存储空间。对于变量，编译器确定变量的大小。，然后在内存中开辟空间来保存量的数据。对于函数，编译器会产生代码，这些代码最终也要占用一些内存。 上面的内容说明了声明跟定义的区别。声明就好比开店之前的宣传，编译器拿着传单知道了这家店的信息，使用情报，而定义就是真正的开店开业，是在上述传单的描述中真实存在的一家店。 在C/C++中，可以在不同的地方声明相同的变量和函数，但是只能有一个定义【有时这称为ODR（one-defifition rule,单一定义规则）】。当连接器连接所有的目标模块时，如果发现一个函数或变量有多个定义，连接器将报告出错。 相同的变量或函数可以多次声明，但是定义只能有一次。 定义也可以是声明。如果定义int x;之前，编译器没有发现标识X，编译器则把这一标识符看成是声明并立即为它分配存储空间。 2.2.1.4变量声明的语法关于变量的声明，由于文章的说明有些多，直接写下自己的理解： 1int a; 这只是一个非常常见的变量声明，这是声明？还是定义？ 这段代码有足够的信息让编译器为整数a分配空间，而且编译器也确实给整数a分配了空间。要解决这个矛盾，对于C/C++需要一个关键字来说明“这只是一个声明，它的定义在别的地方”。这个关键字就是extern，它表示变量是在文件以外定义的，或在文件后面部分才定义。 1extern int a; //声明一个变量但是不定义它 结果就是，对于变量来说简单的声明所提供的情报足以让编译器为其定义。想要停止这种编译器自动的行为就需要使用extern关键字来告诉编译器说我要晚一点再定义这个变量，你先知道有这么个变量就行了。 对于函数来说又是什么样子的呢？1int func1(int length, int width); 1extern int func1(int length, int width); 这两种声明方式有区别吗？ 因为没有函数体，编译器必定把它作为声明而不是函数定义。extern关键字对函数来说是多余的，可选的。C语言的程序设计者并不要求函数声明使用extern，这可能有些令人遗憾； 无论加还是不加，编译器都认为这种定义方式都没有足够的信息去定义一个函数，因此都会被视为声明。通过理解声明与定义的区别，应该可以灵活运用函数与变量的出现位置。 关于extern关键字使用的拓展，目的是加深理解这个关键字的作用。参看文章 C/C++中的extern关键字详解 extern除了告诉编译器这只是一个声明之外，还有一个作用是跟&quot;C&quot;一起连用的时候，是告诉编译器按照C的规则来办事。比如说下面的例子: 1extern "C" void fun(int a, int b); //出于上述的文章中的描述 按照C的规则来翻译这个声明的函数，貌似按照C++的翻译规则，编译器会将函数名变得跟fun不一样，要看编译器的”脾气”。这个跟C++的函数重载特性有关。下面的内容全是选自上面的文章： extern变量 在一个源文件里定义了一个数组:char a[6];在另一个文件里声明extern char *a; 这种声明可以吗？ 答案是不可以。程序运行会告诉你非法访问。原因是类型不同，指向类型T的指针并不等价于类型T的数组，不难发现，这是指针与数组使用中经常出现的盲区知识，若是对于指针的理解只有半吊子的水平还喜欢炫耀的话就会在此栽跟头。正确的声明应该是: 1extern char a[]; 在使用extern的时候应该严格对应声明的格式。 extern常常被用作全局变量来使用，利用其这种特性，在.h文件中使用extern来声明。 extern “C” C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用`extern “C进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。 这应该是在C++环境中使用C函数的时候应该注意的问题。 extern函数声明 原文中举了一个例子，总的来说就是extern对于函数来说就像上文提到的可加可不加，没有明显的区别，仅仅就是一个暗示，可能这个函数会在别的源文件里面定义。 当把全局变量的声明跟定义放在一起的时候，会因为#include的存在而产生重复定义的链接错误。所以：只在头文件中做声明，真理就是这么简单。当然不使用#include语句，将想要提供给外部接口的函数和变量全部使用extern来修饰也是一种方法。你用么，反正我不用。 extern和static （1）extern表明该变量在别的地方已经定义过了，这里要使用那个变量。 （2）static表示静态的变量，分配内存的时候，存储在静态区，不存储在栈上面。 stati作用范围是内部连接的关系，跟extern一样，修饰的部分是跟对象分开存储的，但是却不能被其他对象引用，而extern可以。static修饰的变量只允许对象本身使用。具体差别首先：static跟extern是一对”水火不容”的家伙，也就是说，extern和static不能同时修饰一个变量；其次，static修饰的全局变量声明与定义同时进行，也就是说你在头文件中使用static声明了全局变量之后，它同时被定义了；最后，static修饰的全局变量的作用域只能是本事的编译单元，也就是说它的全局只对本编译单元有效，其他编译单元则看不到它。如： 1234567891011// test1.hstatic char g_str[] = "123456";void fun();// test1.cpp#include "test1.h"void func1()&#123; cout&lt;&lt;g_str&lt;&lt;endl; &#125;// test2.cpp#include "test1.h"void func2()&#123; cout&lt;&lt;g_str&lt;&lt;endl; &#125; 以上的两个编译单元可以连接成功，你可以在各自的.obj文件中找到字符串&quot;123456&quot;的存在。虽然它们有相同的内容，但是存储的物理地址并不一样，就像是两个不同的变量赋了相同的值一样，而这两个变量分别作用于它们各自的编译单元。 一般定义static全局变量的时候，都把它放在原文件中而不是头文件，这样就不会给其他模块造成不必要的信息污染。 extern和const C++中的const修饰的全局常量有跟static相同的特性，即它只能作用于本编译模块中，但是const可以和extern连用来声明该常量可以作用于其他编译模块中，如extern const char g_str[];,然后在原文件中别忘了定义：const char g_str[] = &quot;123456&quot;; 所以当单独使用的时候它就与static相同，而当与extern一起合作的时候，它的特性就跟extern一样了。最后是该作者的提醒：123456const char* g_str = "123456"; // const修饰的是char*而不是g_str// 与下面的写法const char g_str[] = "123456";// const char* const g_str = "123456";` 上面算是对extern关联的一些拓展内容吧。 2.2.1.5包含头文件 #include预处理指令有两种方式来指定文件：尖括号（&lt; &gt;）或双引号。 #include &lt;header&gt;用尖括号来指定文件时，预处理器是以特定的方式来寻找文件，一般是环境中或编译器命令行指定的某种寻找路径。这种设置寻找路径的机制随机器，操作系统，C++实现的不同而不同，视具体的情况而定。 #include &quot;local.h&quot;用双引号时，预处理器以”由实现定义的方式“来寻找文件。它通常是从当前目录开始寻找，如果文件没有找到，那么include命令就按与尖括号同样的方式重新开始寻找。 包含iostream头文件要用如下语句 #include &lt;iostream&gt; 包含头文件的两种方式的区别。 2.2.2 连接 连接器把由编译器生成的目标模块（一般是带.o或.obj扩展名的文件）连接成为操作系统可以加载和执行的程序。它是编译过程的最后阶段。 2.2.3 使用库文件2.2.3.1连接器如何查找库当C或者C++要对函数或变量进行外部引用时，根据引用的情况会选择两种处理方式。 一是如果未遇到过这个函数或者这个变量的定义，就把它的标识符加到未解析的引用列表中，如果连接器遇到过他们的定义，就是已解决的引用。 二是如果连接器没有在目标模块中找到它们的定义，就去查找库。 库有某种索引方式，连接器不会去浏览库中的所有目标模块，而是浏览索引。如果找到了就把函数或变量定义所在的目标模块连接到可执行程序。 这里需要注意的是连接的是目标模块而不是整个库，因此在构造自己的库的时候，一个源码文件只有一个函数，可以减少程序包的大小。 2.2.3.2秘密的附加模块 当创建一个C/C++的可执行程序的时候，连接器会秘密连接某些模块。其中之一是启动模块，它包含了对程序的初始化例程。初始化例程是开始执行C/C++程序时必须首先执行一段程序。初始化例程建立堆栈，并初始化程序中的某变量。 连接器总是从标准库中查找程序中调用的经过编译的标准函数。由于标准库总可以被找到，所以只要在程序中包含所需的头文件，就可以使用库中的任何模块，并且不必告诉连接器去找标准库。 如果使用附加的库，必须把该库文件名添加到由连接器处理的文件列表中。 上面的内容给我揭示了一个盲区，貌似我之前的水平都没有接触到，标准库以外的内容。如果有一天我发现标准库的内容满足不了，我需要别的库的实现，除了在代码中引用之外，我还应该修改连接器维护的一个文件列表，把库的名字加进去。至于应该怎么做，不太清楚了。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的Casting]]></title>
    <url>%2F2018%2F10%2F09%2FUE4%E4%B8%AD%E7%9A%84Casting%2F</url>
    <content type="text"><![CDATA[关于Cast To节点在Blueprint中能够做什么的问题。下面是官方文档中的说明。 Casting in Blueprint 其中的一句话： By using the Get Player Charactor node, then using a Cast To MyCharactor node(the special Charactor Blueprint), you can say if the Player Charactor is MyCharactor, let me access the Variables, Functions, Events or any other special functionality contained within that Blueprint.]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Blueprint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-rebases使用方法]]></title>
    <url>%2F2018%2F08%2F30%2Fgit-rebases%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[git rebase的使用简介]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4:Error_Message整理]]></title>
    <url>%2F2018%2F08%2F16%2FUE4-Error-Message%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[整理在学习UE4的过程中遇到的一些BUG。 syntax error:missing ‘;’ before ‘*’参考链接： syntax error: missing ‘;’ before ‘*’ (First Person Shooter C++ Tutorial) 加了一个关键字class就解决了。虽然不知道是为什么。 LogMaterial: Warning: Material /Game/MagicCircle/Materials/MT_Smoke.MT_Smoke missing bUsedWithInstancedStaticMeshes=True! Default Material will be used in game.#]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>UE4Error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为Actor添加Input事件]]></title>
    <url>%2F2018%2F08%2F16%2F%E4%B8%BAActor%E6%B7%BB%E5%8A%A0Input%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在自己编写Actor的Component的时候想要加上input的事件，但是在UE4中加入这种事件不是那么简单的。这需要对Actor的层级关系有一些了解。 参考链接： C++Is there a way to get input from actor that isn a pawn/character ? Check Keyboard Event in code UE4-学习笔记之二 这篇文章感觉好厉害 &lt;&gt;GamePlay架构(四)Pawn 知乎文章，可以一看]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4-ConstructorHelpers::FObjectFinder]]></title>
    <url>%2F2018%2F08%2F10%2FUE4-ConstructorHelpers-FObjectFinder%2F</url>
    <content type="text"><![CDATA[先来说一说这个问题的起源吧。最近想做一个类似于火焰的特效，是由大量的烟雾粒子组成的那种类似于烟雾的火焰。在制作大量烟雾粒子之前首先要制作出第一个粒子。 制作一个粒子表现的话首先要先实例化一个Instance，这个实例首先依附在一个Acor上。当然，像Unity的脚本函数一样，在Scene中制作一个Actor然后把脚本当做一个ActorComponent的方案是可行的。然后在脚本中使用this-&gt;GetOwner()即可以获取到这个Actor。可以使用this-&gt;GetOwner()-&gt;GetName()来获取到Actor的名字。 参考链接： Get actor from component in c++? 在这里遇见了一个问题。就是在使用UE的UE_LOG打印输出的时候发生了类型错误。 在UE_LOG中使用的都是基础类型，%d,%s等等。 GetName()函数返回的变量类型则是UE的FString类型 解决例子：12// Actor component .cpp fileUE_LOG(LogTemp, Log, TEXT("show value: : %s", *(this-&gt;GetOwner()-&gt;GetName())); 解决案参考： Log issue (passing a FString) Logs, Printing Messages To Yourself During Runtime 能够获取到Parent的Actor就可以根据自身的Actor来制作InstanceStaticMeshComponent了。 InstanceStaticMeshComponent使用方法参照： Using Instanced Static Meshes in C++? 下一步就是发生问题的地方，为制作好的InstanceStaticMeshComponent添加StaticMesh。 上网查查资料就有，这篇文章就行 QUESTION Apply Static Mesh to StaticMesh component 照着做本来不会出错的但是我一运行，UE4肯定Crash。 原因就在于题目所提到的关于ContructorHelpers::FObjectFinder的使用上。总结来说就是这个函数只能运行在类的构造函数中，或者构造函数里调用的函数中。 解决文章： How to use ConstructorHelpers::FObjectFinder? 这个回答中有提到。之后再整理。]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH原理知识普及]]></title>
    <url>%2F2018%2F08%2F06%2FSSH%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A%2F</url>
    <content type="text"><![CDATA[SSH的原理与运用。 参考链接： SSH原理与运用（一）：远程登录 数字签名是什么？ What is a Digital Signature?]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中读取Texture2D的像素值]]></title>
    <url>%2F2018%2F08%2F03%2FUE4%E4%B8%AD%E8%AF%BB%E5%8F%96Texture2D%E7%9A%84%E5%83%8F%E7%B4%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[目的是在UE中获取到一张Texture2D图片的所有像素值，并将这些像素值进行某些处理并保存到另外一个Texture中。 第一步：获取到Texture2D资源Unreal Engine 4 Documentation Referencing Assets 对于高速化来说异步加载资源也是好的解决方案 Ureal Engine 4 Documentation Asynchronous Asset Loading 参考的文章 Accessing pixel values of Texture2D First you need to understand that a texture is normally, a sum of multiple images called MipMaps. MipMaps are down-scaled versions of your images, always in steps of power of 2, so the original image, is, say, 512x512 - this would be the MipMap “0”, then the engine generates the MipMap “1” which is 256x256 and then MipMap “2” which is 128x128, this continues on down to 16x16 I think. The farther away the texture is rendered, the smaller version of the image is used. This means that you need to access the mipmap 0 of your texture. 对上面的答案进行了非常好的总结的文章 UE4 – Reading the pixels from a UTexture2D Reading data from UTexture2D 之后附上完整的代码UE4中的资源管理 Asset Management 拓展知识在代码中看到了static_cast这个语句，竟然不知道是做什么的。查了一下 C++中static_cast, dynamic_cast, const_cast用法/使用情况及区别解析 之后要好好整理一下。]]></content>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4的函数库]]></title>
    <url>%2F2018%2F08%2F02%2FUE4%E7%9A%84%E5%87%BD%E6%95%B0%E5%BA%93%2F</url>
    <content type="text"><![CDATA[在UE4中总会遇见一些不知道是做什么的函数，这篇文章的目的是整理自己遇到的UE4的函数和类，和弄清函数和类的时候遇到的一些问题的解决。 UE4中的类UTexture2DTextureCompressionSettingsTextureMipGenSettingsUpdateResource() Functio作用UTextureRenderTaget2DUreal Engine 4 Documentation: UTextureRenderTarget2D 可以用来存储一个2DTexture数据的类，拥有着许多的成员，文件的位置： C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Classes\Engine\TextureRenderTarget2D.h C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Private\TextureRenderTarget2D.cpp 关于如何实例化这个类，我在网上并没有找到类似的实现，但是在UE4的Blueprint中可以找到一个名为Create Rendr Target 2D的node函数。试着找了一下这个节点的实现函数 C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Private\KismetRendngLibrary.cpp 其中有如下的实现代码：1234567891011121314151617UTextureRenderTarget3D* UKismetRenderingLibrary::CreateRenderTarget2D(UObject* WorldContextObject, int32 Width, int32 Height, ETextureRenderTargetFormat Format)&#123; UWorld* World = GEngine-&gt;GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull); if (Width &gt; 0 &amp;&amp; Height &gt; 0 &amp;&amp; World &amp;&amp; FApp::CanEverRender()) &#123; UTextureRenderTarget2D* NewRenderTarget2D = NewObject&lt;UTextureRenderTarget2D&gt;(WorldContextObject); check(NewRenderTarget2D); NewRenderTarget2D-&gt;RenderTargetFormat = Format; NewRenderTarget2D-&gt;InitAutoFormat(Width, Height); NewRenderTarget2D-&gt;UpdateResourceImmediate(true); return NewRenderTarget2D; &#125; return nullptr;&#125; 或许可以给与一些参照。 UMaterialInstanceDynamicUreal Engine 4 Documentation: UMaterialInstanceDynamic 这个类的作用按照字面意思来推测是用来创建一个动态的材质实例，在UE4的Blueprint中也有相应的节点函数：CreateDynamicMaterialInstance。函数位置 C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Private\KismetMaterialLibrary.cpp 其中的实现代码：1234567891011121314151617181920class UMaterialInstanceDynamic* UKismetMaterialLibrary::CreateDynamicMaterialInstance(UObject* WorldContextObject, class UMaterialInterface* Parent)&#123; UMaterialInstanceDynamic* NewMID = nullptr; if (Parent) &#123; // MIDs need to be created within a persistent object if in the construction script (or blutility) or else they will not be saved. // If this MID is created at runtime then put it in the transient package UWorld* World = GEngine-&gt;GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::ReturnNull); UObject* MIDOuter = (World &amp;&amp; (World-&gt;bIsRunningConstructionScript || !World-&gt;IsGameWorld()) ? WorldContextObject : nullptr); NewMID = UMaterialInstanceDynamic::Create(Parent, MIDOuter); if (MIDOuter == nullptr) &#123; NewMID-&gt;SetFlags(RF_Transient); &#125; &#125; return NewMID;&#125; 可以为该材质添加值的函数实现：1234567891011121314151617181920212223void UKismetMaterialLibrary::SetScalarParameterValue(UObject* WorldContextObject, UMaterialParameterCollection* Collection, FName ParameterName, float ParameterValue)&#123; if (Collection) &#123; if (UWorld* World = GEngine-&gt;GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull)) &#123; UMaterialParameterCollectionInstance* Instance = World-&gt;GetParameterCollectionInstance(Collection); const bool bFoundParameter = Instance-&gt;SetScalarParameterValue(ParameterName, ParameterValue); if (!bFoundParameter &amp;&amp; !Instance-&gt;bLoggedMissingParameterWarning) &#123; FFormatNamedArguments Arguments; Arguments.Add(TEXT("ParamName"), FText::FromName(ParameterName)); FMessageLog("PIE").Warning() -&gt;AddToken(FTextToken::Create(LOCTEXT("SetScalarParamOn", "SetScalarParameterValue called on"))) -&gt;AddToken(FUObjectToken::Create(Collection)) -&gt;AddToken(FTextToken::Create(FText::Format(LOCTEXT("WithInvalidParam", "with invalid ParameterName '&#123;ParamName&#125;'. This is likely due to a Blueprint error."), Arguments))); Instance-&gt;bLoggedMissingParameterWarning = true; &#125; &#125; &#125;&#125; 使用方法是在C++中声明一个材质1234567UMaterialInstanceDynamic* mMaterial;//将mMaterial的材质实例通过Blueprint传递过来mMaterial-&gt;SetScalarParamaterValue("TextureWidth",512);//这样便可以将换递过来的Blueprint中的名为`TextureWidth`(if exist)的Parameter赋值为512了 但还是有许多疑问。 UE4中的函数check()参考链接： When should I use Check()? AddInstance()UE4中的一些类型TextureAddress在Texture.h中看到了这个属性，不太清楚是什么属性，就查了一下。貌似是一种纹理寻址模式。因为有赋值为T_Clamp,Clamp让我有些回想起来在Unity中设置UV的时候有repeat跟clamp等等选项来着，需要调查一下。 D3D11_TEXTURE_ADDRESS_MODE(纹理寻址模式) TextureFilterSRGB是什么参考链接： sRGB - how to be? 【图形学】我理解的伽马校正（Gamma Correction）]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的static关键字]]></title>
    <url>%2F2018%2F08%2F02%2FC%2B%2B%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[static 关键字可用于声明变量、函数、类数据成员和类函数。 之后需要好好整理一下，static关键字的用法。 参考链接： C/C++ 中的static关键字 The static keyword and its various uses in C++]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4的Plugin使用]]></title>
    <url>%2F2018%2F08%2F02%2FUE4%E7%9A%84Plugin%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[制作UE4的插件相当于给UE4引擎添加新的功能模块。UE4的功能模块组成是由Module组成的，关于Module具体是什么，中文翻译就是模块，自己的理解中可以说是文件的单位了。 新建的插件代表着跟UE4本来的功能模块不是从属于一个Module，所以需要为自己制作的插件制作一个属性为Public的公开接口以供UE4引擎调用。 Plugin的Public公开权限一般一个Module中不想公开的源文件都会设置为Private权限，不允许外界的Module访问。要把权限公开，使得其他的模块能够访问的话需要以下两步。 头文件的位置 头文件(.h)放到[\Source\Public]文件夹中去 cpp实现文件放到[\Source\Private]文件夹中去 添加Export用的宏在类的声明中添加一个宏：&lt;大写字母的Module名字&gt;_API 例如：1234UCLASS()class SAYHELLO_API USayHelloFunction : public UBlueprintFunctionLibrary&#123; GENERATED_BODY()&#125; 这样一个名为SayHello的Module的class的权限就变成公开的了。 Tips： 上述的SAYHELLO_API的定义文件位置在Intermediate/Build/Win64/UE4Editor/Development/SayHello/Definitions.SayHello.h。里面定义了DLLEXPORT,DLLIMPORT。 UE会按照Module的单位生成DLL，&lt;ModuleName&gt;_API在自身的Module中会指定DLLEXPORT，在其他的Module中会指定DLLIMPORT。（啥意思？书上就写了这么多。。。） 参考资料： Unreal Engine 4 Documentation - Plugins Unreal Engine 4 C++ 插件介绍 ue4插件开发]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的const修饰符]]></title>
    <url>%2F2018%2F08%2F01%2FC%2B%2B%E4%B8%AD%E7%9A%84const%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[C++中经常会看到const关键字来修饰很多东西，在这里把自己遇到的一些情况收集并整理一下。 参考链接 C++ Const Usage Explanation 关于C++ const 的全面总结]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的静态库与动态库]]></title>
    <url>%2F2018%2F08%2F01%2FUE4%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[库(Library)是什么,库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。 本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种：静态库（.a、.lib）和动态库（.so、.dll）。所谓静态、动态是指链接。 需要知道的除了制作动态库与静态库，还要知道这两种库之间的区别。为什么要制作库。 参考链接： C++静态库与动态库]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的异步处理]]></title>
    <url>%2F2018%2F08%2F01%2FUE4%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[能够熟练的使用UE4中的异步处理应该能够很好的利用程序运行的资源，和计算。除此之外还有并行的处理。目的是要理清UE4中的线程的同步异步，并行操作和标准C++中的线程同步异步，并行操作。 时间有限，暂时记录下关键字： UE C++ ThreadPool 异步处理相关函数： Async Lambda记法 AsyncTask ParallelFor123//函数的位置Engine/Source/Runtme/Cre/Pblic/Async/Async.hEngine/Source/Runtme/Cre/Pblic/Async/ParallelFor.h 异步辅助API FScopeLock]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的C++]]></title>
    <url>%2F2018%2F08%2F01%2FUE4%E4%B8%AD%E7%9A%84C%2B%2B%2F</url>
    <content type="text"><![CDATA[UE C++拥有着自己的库，当然也可以使用C++的标准库(STL)，但是不同的地方还应该好好记载下来，同时也是对C++的一种复习。 值类型？指针？在标准C++中，类的声明可以12345ClassExample ObjName;/或者是ClassExample* ObjPtr; 而在UE4中为了统一值类型与指针的规则，想这种类的声明全部使用指针类型，不使用值类型。1UObject* o; UE4生成类对象实例(Instance)直接上例子：12345678//声明UMyClass* MyClass;//生成实例MyClass = NewObject&lt;UMyClass&gt;();//或者MyClass = NewObject&lt;UMyClass&gt;(Owner); Tips: 在构造函数中不能使用NewObject&lt;T&gt;生成其他的对实例。会使程序Crash。如果想生成其他的Object的话使用FObjectInitializer::CreateDefaultSubobject&lt;T&gt;函数 123ASomeActor::ASomeActor(const FObjectInitializer &amp; ObjectInitializer) : Super(ObjectInitializer)&#123; SampleActor = ObjectInitialize.CreateDefaultSubobject&lt;ASampleActor&gt;(this, TEXT("SampleActor"));&#125; Actor的实例化Actor的Component实例化从Content(Asset)中加载Object对象数据UE4中的容器]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的智能指针]]></title>
    <url>%2F2018%2F07%2F31%2FUE4%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[对于内存使用的了解，就不得不了解指针。UE4拥有跟C++类似的智能指针，在这里对虚幻4的智能指针库的内容进行一些总结跟提炼，同时也需要对C++的智能指针进行深入的了解。 UE4的智能指针智能指针并不能使用UPROPERTY()，TSharedRef,TSharedPtr,TWeakPtr等等。 参考链接： Unreal Smart Pointer Library C++的智能指针指针的使用伴随着内存泄漏(memory leak)的问题，可能会发生内存泄漏的情况有： new或者malloc出来的内存因为程序员的疏忽忘记释放 程序运行发生错误(throw)，未能执行内存释放程序 所以不是说只要程序员足够谨慎就能够避免指针造成的内存泄漏的问题。 C++11中的智能指针主要在用的智能指针有：unique_ptr, shared_ptr, weak_ptr。 这3种指针组件就是采用了boost里的智能指针方案。很多有用过boost智能指针的朋友，很容易地就能发现它们之间的关间：|std|boost|功能说明||—-|—-|—-||unique_ptr|scoped_ptr|独占指针对象，并保证指针所指对象生命周期与其一致||shared_ptr|shared_ptr|可共享指针对象，可以赋值给shared_ptr或weak_ptr。指针所指对象在所有的相关联的shared_ptr生命周期结束时结束，是强引用。||weak_ptr|weak_ptr|它不能决定所指对象的生命周期，引用所指对象时，需要lock()成shared_ptr才能使用。| 参考链接： C++11中的智能指针 三种智能指针的特性用法参考链接： C++11及C++14标准的智能指针 weak_ptrstd::weak_ptr是一个很好的解决悬空指针问题的方式。使用原生指针（raw pointers）的话不知道现在所引用的资源是否已经被释放。而使用std::shared_ptr来管理的话，std::weak_ptr只管使用，而不关心资源的使用情况，反正也不管理指向的资源。 因为本身std::weak_ptr并不能直接引用到对象，不会影响对象的自动释放，不会影响对象的引用计数，需要使用lock()来升级到std::shared_ptr来进行操作。 参考资料： C++ weak pointer When is std::weak_ptr useful? 比起直接使用new优先使用std::make_unique和std::make_shared参考链接： Item 21: 比起直接使用new优先使用std::make_unique和std::make_shared]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的函数回调实现]]></title>
    <url>%2F2018%2F07%2F31%2FUE4%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%9B%9E%E8%B0%83%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[回调函数的含义，实际上我也不太清楚，搜回调函数得到的关键字有很多：闭包，代理，委托，Wrapper，等等。但有一点我很清楚，这些我都不太懂。 说是在不同的语言中有不同的叫法。其本质上就是一个函数指针，而在汇编层面，就是子程序代码的首地址。每一段编译器先放一个占位符，最后放入实际的值。 上面的话是Unreal用到一些编程技巧里的内容。 UE4中的函数回调(CallBack)C++中应该有许多种方式的回调，UE C++(UnrealEngine中的C++)则是使用的DELEGATE和EVENT来实现。 关于UE C++的代理，存在着以下的几种方式： 静态的Single-cast Delegates Dynamic Single-cast Delegates 静态的Multi-cast Delegates Dynamic Multi-cast Delegates 这几种代理的实现有什么不同需要后续整理，可以参考： What difference betweens delegates? 有的时候需要很好的利用一下UE4的官方论坛，像是Stack Overflow一样。 Dynamic Multi-cast DelegatesDynamic Multi-cast Delegates是唯一的一种可以和UE4的Blueprint联动的代理实现方式。 Dynamic Multi-cast Delegates的UE C++中的声明12345678910//File: CallbackExample.h//Class: ACallbackExampleDECLARE_DYNAMIC_MULTICAST_DELEGATE(FZeroInputDelegate); //没有参数的声明方法UPROPERTY(BlueprintAssignable, Category="UE C++ Book") //BlueprintAssignable属性使得这个代理在Blueprint中也取得到。 -&gt;此处在真正的工程中不应该写注释，会出编译问题FZeroInputDelegate TheZeroInputDelegate;DECLEAR_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FTwoInputsDelegate, float, FloatVal, int32, IntVal); //两个参数的声明方法UPROPERTY(BlueprintAssignable, Category="UE C++ Book")FTwoInputsDelegate TheTwoInputsDelegate; Tips: 参数最大允许有8个。参数的声明类似上述两个参数的声明，先是类型后是参数名。 参数不同的代理声明只需要将上述的数字换成相应参数的英文就可以，比如说八个参数的情况声明代理的语句就会变成：DELEAR_DYNAMIC_MULTICAST_DELEGATE_EightParams 这样制作的代理，可以在UE的Blueprint中获得到这个代理（似乎是作为Event）并进行实现了。别忘了指定Event与Target。即把这个代理委托给一个类的实例(Instance)。在Blueprint中似乎是以Event而存在的，Blueprint中实现的操作是把这个调用的Event登录到这个代理上去。这样在UE C++中调用这个代理，也会调用Blueprint中的事件，执行这个事件的实现部分。 调用Blueprint中的代理实现1234567// File: CallbackExample.cpp// Class: ACallbackExampleauto ACallbackExample::ExecuteDelegate(const float FloatVal, const int32 IntVal) -&gt; void &#123; TheZeroInputDelegate.Broadcast(); TheTwoInputsDelegate.Broadcast(FloatVal, IntVal);&#125; 官方参考链接： Dynamic Delegates EventsBlueprint Event与Blueprint Function关于事件与函数的区别，没有返回值的被叫做事件，有返回值的叫做函数。是否真实需要验证。在UE C++中可以登录Blueprint的事件，通过给UPROPERTY宏添加属性来完成。话说回来这个是函数，应该使用UFUNCTION宏才对，不知道为什么书上这么说。 用于事件声明的属性有两种，区别的方式是是否在UE C++中有默认的实现。 BlueprintImplementableEvent:没有默认实现 BlueprintNativeEvent:拥有默认实现 Blueprint Event,Blueprint Function在UE C++中的声明12345678910111213141516// File: CallbackExample.h// Class: ACallbackExample// BP EventUFUNCTION(BlueprintImplementableEvent, Category="UE C++ Book")void FloatInputEvent(const float FloatVal);UFUNCTION(BlueprintNativeEvent, Category="UE C++ Book")void VectorInputEvent(const FVector&amp; VecValue);// BP FunctionUFUNCTION(BlueprintImplementableEvent, Category="UE C++ Book")float IntInputFunction(const int32 IntInput);UFUNCTION(BlueprintNativeEvent, Category="UE C++ Book")TArray&lt;float&gt; VecArrayInputFuncion(const TArray&lt;FVector&gt;&amp; VecValues); Event的默认实现12345678910111213141516// File: CallbackExample.cpp// Class: ACallbackExample//static FVector TheVector事先声明的属性auto ACallbackExample::VectorInputEvent_Implementation(const FVector&amp; VecValue)-&gt;void&#123; TheVector = VecValue;&#125;auto ACallbackExample::VecArrayInputFuncion_Implementation(const TArray&lt;FVector&gt;&amp; VecValues)-&gt; TArray&lt;float&gt;&#123; TArray&lt;float&gt; Result; for (const auto&amp; Val : VecValue) Result.Emplace(FVector::Dist(TheVector, Val)); return Result;&#125; 以上的代码实装完成之后，继承了上面的CallbackExample类的Blueprint就可以在Blueprint Editor中对上述UE C++中的事件与函数进行重写了。 以上，是对UE中的代理与事件，在可用范围内的总结与实现。但是对于在什么情况下使用这一点上仍然有许多疑问。 为什么要使用Delegate和Event？关于代理的实现，就算明白了也需要知道需要在什么情况下使用代理，否则没有意义。 关于Event在UE4中的Blueprint中应没有委托这一说，全部是以Event的名字来称呼的。 Delegate的使用情况推测1面向对象的说法只是一种理想的情况，总会有想要实现别人功能的情况。比如说ClassA想要实现一个功能，但是明显这个功能是由ClassB负责的部分，要是自己来实现的话不好，所以自己的话，声明一个Delegate，想用的时候就把这个广播出去(Broadcast)，实现了这接口的内容会被调用。 只言片语： 现在我要对一系列数据进行排序，而排序算法可能比较复杂，我不会自己写，我想调用Array.Sort方法，微软为我们提供了快速排序算法。但是这里有一个问题——我要实现自定义排序规则，比如对于字符串，默认的是按字母顺序，但现在我想这样排序： 按字符串长度排序，只有当长度不同时，再按字母排序。 显然，微软不可能提供这样“个性”的排序方法，那是不是说，就必须让我们自己去写快速排序算法呢？不需要！我们只需要使用委托，就能实现这个要求：string[]strs=”I like C# very much”.Split();Array.Sort(strs,Rule);int void Rule(string first,string second){return first.Length==second.Length?first.CompareTo(second):first.Length.CompareTo(second.Length);} 显然，我并不需要知道快速排序算法的逻辑，我只需要告之排序规则，就实现了我的个性排序。 试问：如果没有委托，你如何解决这个问题？ C++中的代理实现代理应该涉及了许多知识，完全理解需要后续的更新整理。 参考链接： C++中实现委托（Delegate） C++实现Delegate Event实例(例子、example、sample) C++委托实现(函数指针，function+bind，委托模式) 高效C++委托的原理]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGl学习内容整理]]></title>
    <url>%2F2018%2F07%2F25%2FOpenGl%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[主要是记录自己学习OpenGl内容。 OpenGL学习网站参考： Learn OpenGL Learn OpenGL中文翻译]]></content>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UnrealEngine着色器开发整理]]></title>
    <url>%2F2018%2F07%2F25%2FUnrealEngine%E7%9D%80%E8%89%B2%E5%99%A8%E5%BC%80%E5%8F%91%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[整理自己在学习Unreal Engine 4着色器过程中遇到的问题和知识点。 Unreal Engine 4设定1. UE4的内置材质Shader函数库位置UE4Shader的编写入门反而相对比较容易，使用自带的各种函数库拉拉线竟然就可以完成。函数库的位置都在: 位置： C:\Program Files\Epic Games\UE_4.19\Engine\Shaders\Private UE4的安装文件夹中 2. Material.cpp文件位置 C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Private\Materials]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的粒子特效]]></title>
    <url>%2F2018%2F07%2F24%2FUE4%E4%B8%AD%E7%9A%84%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[主要是用来记录学习虚幻引擎4的粒子的过程 Particles with Unreal Engine 4先是在UE4提供的官方教程中整理基础的知识点。官方Youtube视频。 Particle Particle Particle System Emitter Actor Particle System Component Cascade Emitter Emitter Module tips: 在Emitter(粒子发射器)的各个Module中，按住alt键拖动可以复制Module 按住shift可以共享Module，即只需要修改一个其他的都会被修改 Type Data Distributions]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Particles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于学习UE4的粒子系统过程中遇到的疑问]]></title>
    <url>%2F2018%2F07%2F20%2F%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0UE4%E7%9A%84%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E7%96%91%E9%97%AE%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[记录刚学UE的一些疑问]]></title>
    <url>%2F2018%2F07%2F18%2F%E8%AE%B0%E5%BD%95%E5%88%9A%E5%AD%A6UE%E7%9A%84%E4%B8%80%E4%BA%9B%E7%96%91%E9%97%AE%2F</url>
    <content type="text"><![CDATA[为了记录自己在学习UE引擎过程中遇到的一些疑问点。时间长了之后就会习惯，这是真的。但是为了避免忘记，记在某个位置是最好的。每个小的知识点写成一篇文章的话总觉得很乱。 C++与C#的不同之处时隔多年见到C++的第一个违和感是头文件，为什么需要写头文件这个问题我找了一些别人写的代码发现了一下几个规则： 在C++的头文件中SampleCode.h中一般都会预先定义一些东西 需要包含的其他头文件 123#include "Engine.h"#include "MyAppUtilities.h"... 定义需要使用的宏 预处理（C++的预处理器需要了解一下） 123//一般常量居多？#define PI 3.1415926... 定义类，类中包含该有的成员， 123456789class SampleClass&#123; //Attributes or functions public: protected: private:&#125; UE4中的C++不同的地方1.UCLASS()宏想要让类与UE4的类库联动的话，就需要这个宏。 UCLASS()大概的使用方法Sample Code:12345678910111213141516171819202122#include "Engine.h" //如果需要使用UE的library的话#include "MyAppUtilities.h"UCLASS()class UMyClass : public UObject&#123; GENERATED_BODY() public: //构造函数(公有的？) UMyClass(); UPROPERTY(BlueprintReadWrite, Category = "MyApp") int32 IntProp; UFUNCTION(BlueprintCallable, Category = "MyApp") float LengthOfSomething(const int32 index); private: TArray&lt;int&gt; IntArrayWork; //标准c++中的数组声明 //std::vector&lt;int&gt; IntArrayWork;&#125; 对于UCLASS()，如果需要继承UE的类库，则都要加上这个。最好声明的类名也以U开头为好？ 但是我觉得这种声明不是跟UE的类库搞混了吗，辨识度低我觉得应该没有这么智障的规则。好的，有这种规则好像。类似的其他的以E,F,I,T,S等等的字母作为变量名的开始。 关于在头文件中添加注释的问题，在UE4的执行中倘若添加了日语(应该中文也一样)的注释，有可能会发生问题。所以在头文件中尽可能的使用英文注释。还有应该避免在各种宏的后面直接追加注释。 就目前的问题来说在UFUNCTION宏的后面直接加入日文注释(UTF-8)的话，会有编译无法通过的问题。所以为了避免上述问题应该尽量： 头文件中使用英文注释 不要直接在各种UE4的宏后面(例如UFUNCTION后)直接添加注释。 UCLASS() 参数的含义CPPExampleActor.h123456789101112131415161718192021#pragma once#include "GameFramework/Actor.h"#include "CppExampleStruct.h"#include "CppExampleEnum.h"#include "CpExampleActor.generated.h"UCLASS(BlueprintType)class ACppExampleActor : public AActor&#123; GENERATED_BODY()public: UPROPERTY(BlueprintReadWrite, EdtAnywhere, Category="UE C++ Book") FCppExampleStruct MyStructProp; UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="UE C++ Book") ECppExampleEnum Type; UFUNCTION(BlueprintCallable, Category="UE C++ Book") float MyActorFunc(const float Input);&#125;; 通过指定UNCLASS()的参数，可以指定类的类型。 BlueprintType表示这个类可以作为Blueprint的变量来使用。 UPROPERTY()的声明，在这个Actor的Detail面板上可以看到该Category下有声明的MyStructProp和Type属性。 具体的BlueprintType的使用例子则仍需要调查。BlueprintType类型能做到的事情。 多个参数 1UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) ) 这个的使用含义现在还不清楚各自代表着什么意思。 USTRUCT()结构体CppExampleStruct.h1234567891011121314#pragma once#include "CppExampleStruct.generated.h"USTRUCT(BlueprintType)struct FCppExampleStruct &#123; GENERATED_BODY() UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="UE C++ Book") float Value; UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="UE C++ Book") int32 Index;&#125;; 构造体的声明名字最好以F开始。其他的基本上使用方法与类相同。 UENUM()枚举类型CppExampleEnum.h12345678#pragma onceUENUM(BlueprintType)enum class ECppExampleEnum : uint8 &#123; None = 0, Foo, Bar&#125;; 对于enum class ECppExampleEnum : uint8这种写法有些迷惑。 class是为了使枚举类型更安全。为什么安全，参考下面的链接。之后整理。 uint8是为了指定枚举器的基础类型。 参考链接: C++11的enum class &amp; enum struct和enum C\C++中的整形提升 C++标准文档-n2347 2.GENERAED_BODY()这一句话必须要写的原因需要调查 3.UPROPERTY() UFUNCTION()使用这个声明的属性跟方法UE的Blueprint可以使用。 UPROPERTY()宏UPROPERTY()的参数的含义 UPROPERTY()没有参数的情况，UE4的Blueprint和Level Editor都不能读取或者修改，但是却可以将这个变量纳入到UE4的GC对象中。比如： 12UPROPERTY()AActor* OwningActor; 这种情况，如果OwningActor拥有了实例化对象，不手动释放也是没有问题的。或者说注意别手动释放了，会出问题的。 UPROPERTY(EditAnywhere, Category=&quot;UE C++ Book&quot;,EditAnywhere属性表示在Level Editor中也可以操作这个属性。 那么Blueprint与Level Editor的差别在哪里，需要调查。 猜测的结果，Blueprint就是那个连来连去的蓝图，可以在那个蓝图的编辑器中取到属性。 Level Editor指的是操作的画面，在Level Editor中可以取到的意思应该是在Detail panel中直接设定或者读取值那样。 UPROPERTY(BlueprintReadWrite, Category=&quot;UE C++ Book&quot;),BlueprintReadWrite表示Blueprint可以读写。 其他的属性，还有meta属性可以查找下面的链接： Property Specifiers Metadata SpecifiersUFUNCTION宏12UFUNCTION(BlueprintCallable,Category = "UE C++")static float FunctionName(const float Variable); 像上面的使用方法，在函数的前面添加UNFUNCTION macro宏可以制作UE4的Blueprint编辑器的函数节点以供调用。在虚幻4的Blueprint编辑器中使用此函数。 4.TArray-UE4中的数组（重要）先上本家，官方文档TArray:Arrays in Unreal Engine。 再上中文翻译虚幻引擎中的数组–TArry:Arrays 5.C++中的静态函数static与UE C++(Unreal Engine C++)的静态函数在C++中的静态函数与非静态函数的执行确实是有差别的。 复习一下C++中的静态函数： static修饰变量 static修饰函数参考文章： C/C++ 中的static关键字 存储类 (C++) C++静态成员函数 C++ static静态成员变量 UE C++中关于静态函数的使用应该大同小异，但是也不排除有差别的可能性。 将来可能会派上用场的文章 クラスにスタティック変数を持たせたい 6.Blueprint函数node(节点)的输入与输出在UE C++中函数的参数对应Blueprint的node的输入pin，函数的返回值则对应着node的输出pin12UFUNCTION(BlueprintCallable,Category="classcategory")bool MyFunc(const int a,int b,const int&amp; c,int&amp; d) 上述的情况下a,b,c三个变量对应着node的三个输入pin，但是return value,d对应着node的输出pin。也就是说：没有const修饰的引用型参数会被分配到输出pin的阵营中。 这里便引申出几个问题 UE C++的函数参数为什么要使用const修饰，使用常量的必要性是什么 万一想要使用const修饰的引用型参数作为node的输入pin怎么办 想要增加node的输出pin的话，除此之外还有别的写法么 Blueprint支持的数据类型很有限 bool uint8 int32 float 7.UE4的Head FileUE4中的头文件有许多中，为了能够分清使用方法把遇到的头文件整理一下 Actor.h一般的写法是1#include "GameFramework/Actor.h" 一般是继承了UE4中的Actor类的话都需要包含这个头文件。 xxx.generated.h比如说1#include "CppGate.generated.h" 这个头文件是有UE4的UnrealHeaderTool自动生成的文件。如果类继承了UObject类并且想要在Blueprint中使用这个类的话，就需要include这个头文件。而且需要把这个头文件放到所有的头文件的最后才行。 8.UE4中的特殊容器1.FVector一个表示3D空间的向量。可以用来表示空间的一个点或者方向。 参考链接： FVector 9.类的初始值设定基础类型变量的初始化可以在声明的同时进行，以外的数据类型(FVector等)初始化需要在构造函数中进行。静态变量的初始化则需要在类外进行。123int ClassExample::static_var; //equle 0//or lik thisint ClassExample::static_var = 4; #pragma once vs include guard打开UE工程看到一些.h头文件的源码的时候看到了#pragma once有些困惑，不知道是做什么用的。于是调查了一下。 总体来说这两个命令都是为了避免同一个头文件被include多次 方式1：1234#ifndef __SOMEFILE_H_#define __SOMEFILE_H_...#endif 方式2：12#pragma once... #ifndef方式这种方式受C/C++语言标准支持，可以保证同一个文件不会被同时包含，也能保证内容完全相同的两个文件（或者代码片段）不会被同时包含。缺点是不同头文件中的宏的名字如果相同，会导致编译器找不到声明的问题。另外由于编译器每次需要打开头文件来判定是否有重复的定义，会导致编译的时间要长。 #progma once方式这种方式是保证“物理存在上”同一个文件不会被包含多次。而不是内容相同的两个文件。而且无法对一个头文件中一段代码做pragma once声明，只能针对文件。当然也不会发生第一种方式的宏名碰撞引发的问题。 使用哪一种方式见仁见智，有好处有坏处。根据情况使用。 附上别人的博客链接: #pragma once与#ifndef解析 时间线比较新的分析: インクルードガードとpragma once stackoverflow上关于上述两种方式的争论: #pragma once vs include guards? C++中的类与结构体参考链接： 详解C结构体、C++结构体 和 C++类的区别 开启HSLS语法高亮HLSL Tools for Visual Studio应该是HLSL的语法编辑器插件，有自动补全的功能，附上下载链接。但是并没有解语法高亮的问题。 下载链接： HLSL Tools for Visual Studio 在VS2017中开启语法高亮（syntax high lighting）虽然不是针对VS2017的解决方案，但是设定之后的确解决的这个问题： 设定顺序： 在VS2017中 Go to Tools -&gt; Options -&gt; Text Editor -&gt; Fie Extension 在这里选择编辑文件的扩展名与文法编辑器，然后添加保存。 这样设定应该里面有效果了。 参考链接： How to get syntax highlighting for alternate file extension for Visual Studio 2010 or 2013? UE4中使用的一些Tip1. 快速制作封闭空间快速挖空一个几何体的制作顺序： Modes panel -&gt; Geometry -&gt; Box -&gt; 设置尺寸 Details panel -&gt; Brush settings -&gt; Hollow 属性check 2.调整模型的模型坐标的原点根据模型的大小来调整模型坐标的原点，顺序： 双击UE4中导入的模型，打开材质编辑器(static mesh editor也叫Material Editor) 点击Show Pivot显示模型坐标，同时在左上角看见，模型的大小 在Detail panel中找到Transform，调整Import Tansiation的数值，移动坐标系 Tool bar -&gt; Asset -&gt; Reimport Model 之后就会发现模型坐标按照指示移动了 3.制作天空球(与雾)感觉要制作出天空的感觉同时还有雾的模糊的时候使用，可以看见太阳就是不知道能否模拟太阳的移动 顺序: 选定平行光源，开启Light -&gt; Atmosphere/Sun light 将Visual Effects -&gt; Atmospheric Fog 拖拽至场景中 Content Browser panel右下的View Options中开启Show Engine Content 在Engine Content中找到BP_Sky_Sphere并将其拖拽至场景中 在BP_Sky_Sphere的Details面板中的Directional Light Actor选定上面的平行光 4.UE4中的Volume应用在UE中使用Volume执行不同的任务可以解决很多问题，比如说： 给玩施加伤害 改变物理定律，在Volume中允许玩家悬浮等等 作为碰撞表面，不允许玩家进入 改变计算关卡光照和可见性方式 等等，出了直接使用Modes panel中的Volume工具之外，也可以直接将几何体笔刷(brush)转化为相应的Volume。Details -&gt; Actor -&gt; Convert Actor -&gt; Volume(that you want) 参考资料： Volume Reference 5.Z-FightingZ-Fighting又Depth Fighting，深冲突。就是贴图会出现闪烁的情况，与实际模型产生交叉融合 z-fighting的出现是的不同面上的像素在z-buffer中的值相近，导致前台取像素的时候一会去这个面的，一会取那个面的。改变照相机的near、far属性会涉及到z-buffer中的值的精度。因为在各个平台上z-buffer位数不同，因此改变near和far能给z-buffer中的值的浮点数部分尽量留出空间，消除z-fighting。 参考： z-fighting在unity中的解决方式 6.将选定的Actor合并为组使用Ctrl+G的快捷键可以快速把选定的Actor(场景的素材)合并为一组，下次选定的时候会选定为一组。便于移动或者复制。 使用Shift+G的快捷键会解除分组。当然这些操作都可以在选中Actor之后: Right Click -&gt; Group进行分组和分解 7.UE4中的Material和Material Function在UE4中偶然看到了这两个材质的声明，发现名字不太一样，需要调查一下。 UE C++中的需要注意的问题1.ConstructorHelpers类的使用就我的理解这个类可以在其他类的构造函数中实例化对象。自己的情况中多为获取在工程中的资源，并不是level中的Actor资源而是单纯的Content文件夹中的某个资源。123456789// 使用实例// SampleActorComponent.cpp中的构造函数USampleActorComponent::USampleActorComponent()&#123; PrimaryComponnetTick.bCanEverTick = true; static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; SampleAsset(TEXT("StaticMesh'/Game/StartrContent/Shapes/Shape_Plane.Shape_Plane'")); sample_mesh = SampleAsset.Object;&#125; 这样就能成功取到Content中的资源，当然不限于StaticMesh其他的类型UMaterial等等的类型都可以取到。需要注意的是 ConstructorHelpers类的使用必须是要在类的构造函数中进行（吃了不少苦头） SampleAsset的资源链接可以直接在UE4的Content文件夹右键资源copy reference中直接取到 关于更多的使用应该在另一篇博文中有拓展。 2.在C++类中为类添加用户输入响应在网上搜了一下如何给一个脚本添加键盘输入事件，也不是那么全，有价值的一个提问是这个 Check Keyboard Event in code 但是试了一下并不好用，就自己的理解来说，基本上想要键盘的输入的事件响应的基本上都应该去继承UE4的PawnActor类去了，而我自己就是想用键盘来调试而已。继承的类是ActorComponent，并不能实现他们的代码。后来找了一找还是有实现方法的。 首先要去UE4的Editor中的Project Settings中的input选项中将自己想要绑定的键位命名并登录。我起的名字就是PressedF等等。 然后就是在c++中实现绑定了：12345678910111213141516171819202122232425262728293031323334// SampleActorComponent.cppvoid USampleActorComponent::BeginPlay()&#123; // 因为要绑定一下键位的事件，所以需要在这里写 this-&gt;GetOwner()-&gt;EnableInput(this-&gt;GetWorld()-&gt;GetFirstPlayerController()); UInputComponent * myInputComp = this-&gt;GetOwner()-&gt;InputComponent; if(myInputComp) // check(myInputComp) &#123; SetupMyPlayerInput(myInputComponent); &#125;&#125;void USampeActorComponent::SetupMyPlayerInput(UInputComponent * myInputComponent)&#123; myInputComponent-&gt;BindAction("PressedF", IE_Pressed, this, &amp;USampleActorComponent::PressedMethod);&#125;void USampleActorComponent::PressedMethod()&#123; // 这里是按下键盘键位之后的动作内容&#125;// SampleActorCompoennt.hclass USampleActorComponent : public UActorComponent&#123; GENERATED_BODY()public: UFUNCTINN(BlueprintCallable, Category = "MyUE4Class") void PressedMethod(); // 这个在头文件的声明一定要使用UFUNCTION宏来修饰否则没有作用 void SetupMyPlayerInput(UInputComponent * myInputComponent);&#125; 完整的使用方法大概就是这样，应该有一篇文章介绍的很详细的但是关掉了页面不太好找了。 3.像Unity一样保存场景中的参照在Unity中把scene中的参照直接拖进脚本的声明公共变量以达到快速参照的目的，在UE4中也有类似的用法。123456789class USampleClass : public UActorComponent&#123; GENERATED_BODY()public: USampleClass(); UPROPERTY(EditAnywhere, Category = "Edit") AActor * targrtActor;&#125; 为属性添加UPROPERTY()宏让变量暴露给编辑器，然后在该脚本的Detail面板上wei该变量找到场景中的Actor参照。虽然不能拖拽了。 4.获取Actor上的Component不知道是不是UE4中获取Actor上的组件就这么麻烦还是我没找到，组件的获取并不是那么单纯的事情。12345// 获取名为targetActor身上的脚本组件（TArray&lt;USampleActorComponent*&gt; Comps;targetActor_p-&gt;GetComponents&lt;USampleActorComponent&gt;(Comps);// 这样Comps[0]的内容应该就是想要的组件的参照了 5.在UEC++中实现代理我在现实中都没怎么用到过得代理，我竟然一次用了这么多。在UE4中代理的制作感觉好简单好方便。之前有一个是在C++中声明代理，但是实现是在蓝图中的，叫Multi-Cast-Delegate好像。这次完全是在C++中声明在C++中实现代理。 再来复述一下代理的情况：一个类想要做一件事儿，但是这件事跟这个类的关系是只想知道这件事做了而已，具体做的内容完全不关心，这件事情的实现是另一个类的分工。这个时候只要在自己的类里面声明一个代理，当想要执行的时候通知那个类就行。就像是事件一样。 1.定义代理类型在UE4中引擎为我们做了大部分，而我们只要用就可以了。首先定义代理的类型。1234567891011#include "CoreMinimal.h"#include "SampleDelegateComponent.h" // 我们需要委托的类头文件声明#include "SampleActoomponent.generated.h" // 这个头文件是自动生成的，没有的话要手动补上去就是自己的文件名加上.generated.h，而且这个声明必须要在所有的声明的最后。原因不清楚DECLARE_DELEGATE(SampleDelegate)UCLASS()class USampleActorComponnet : UActorComponent&#123; // Class Contents&#125; 这样我们便声明了一个类型为SampleDelegate的代理了。 2.声明代理12// 在USampleActorComponent中的声明这个该类型的代理变量SampleDelegate sample_delegate; 3.绑定代理用上一条的方法获取到level中的Actor的参照，然后将代理绑定到这个想要代为我们执行的实例上去。123456789// 取得需要绑定的实例参照if(targetActor)&#123; // 获取到实例身上的脚本组件 TArray&lt;USampleDelegateComponent*&gt; Comps; targetActor-&gt;GetComponents&lt;USampleDelegateComponent&gt;(Comps); // 绑定代理 sample_delegate.BindUObject(Comp[0], &amp;USampleDelegateComponent::MethodWanted);&#125; 4.代理执行剩下的就是在想要的时候执行代理就好了。1sample_delegate.Execute(); 6.动态加载资源关于动态加载资源又是能说一箩筐的话题，这次只记录自己用到的。1UTexture2D * sampleTex = LoadObject&lt;UTexture2D&gt;(NULL, TEXT("Texture2D'/Game/Path..'"), NULL, LOAD_None, NULL); 参数啥的也不太清楚，用的时候按照这个方向查吧。之后的关于如何从零开始制作烟雾特效的教程里应该会出现。 7.动态改变物体材质参数关于UE4的材质，有好多的话要说，关于如何动态的改变一个物体材质的问题要是不是自己非要用C++写蓝图，估计也不会钻研的那么深。 首先是要动态的改变一个材质里面的参数需要我们创建一个动态的材质。也就是说我们需要得到场景中的物体的材质的实例参照，然后以这个参照为模板创建一个动态材质，再把这个修改了的动态材质赋给物体。 老规矩，上代码： .h文件1234// Class内，省略大部分框架代码// 头文件中声明材质UMaterial * target_material;UMaterialInstanceDynamic * target_material_dynamic; .cpp文件12345678910111213141516171819202122232425262728// 构造函数中使用ConstructorHelpers获取到物体的材质static ConstructorHelpers::FObjectFinder&lt;UMaterial&gt; targetMT(TEXT("PATH"));target_material = targetMT.Object;// 随后可以在BeginPlay函数中对动态材质进行初始化target_material_dynamic = UMaterialInstanceDynamic::Create(target_material, this-&gt;GetWorld());// 可以为材质中的变量赋值target_material_dynamic-&gt;SetScalarParameterValue("MaterialParaName",10);// 拓展复习~// 获取一个UStaticMesh上的组件的材质TArray&lt;UStaticMeshComponent*&gt;comps;this-&gt;GetOwner()-&gt;GetComponnets&lt;UStaticMeshComponent&gt;(comps);target_material = (UMaterial*)comps[0]-&gt;GetMaterial(0) // 指针类型强制转换这一步很重要// 更新材质结束之后要赋给物体mesh_comp = comps[0]mesh_comp-&gt;SetMaterial(0, target_material_dynamic);// 下面的是比较重要的一步// 在BeginPlay中实例化动态材质之后需要target_material_dynamic-&gt;AddToRoot();// 完后再EndPlay中将动态材质移除target_material_dynamic-&gt;RemoveFromRoot(); 这个也是吃了苦头的，因为自己非要用C++写，不用蓝图，这东西谁都不会告诉我啊。AddToRoot这个操作让UE的GC不会把我们创建的动态材质给回收掉。而使用的AddToRoot的东西在结束或者不想用的时候RemoveFromRoot，以便回收。哎呀没加的时候UE4崩的不要不要的。 8.UE_LOG输出奇奇怪怪的数据类型总是想输出些什么。使用UE_LOG可以在UE4的Editor输出运行的信息。但是C++嘛，你让它输出FString类型的东西，他不认识就不输出这个时候就像下面这样：1UE_LOG(LogTemp, Log, TEXT("output message %s"), *(FDateTime::Now().ToString())); 使用指针强制转换，我也不知道是个什么原理。 9.FTimerManager定时器定时器是个好东西。但是要怎么用呢？ 首先要获取到这个定时器，在世界中有这么一个定时器：12// 为什么要加 &amp; ，引用的作用应该就是我不知道，不加就报错。我也不知道我是怎么灵机一动加上就好用的。FTimeManager &amp;timer = this-&gt;GetOwner()-&gt;GetWorldTimerManager(); 然后声明一个Handle12// 在.h文件中声明一个Timer Handle供我们使用，一个Handle就是一个定时的名字应该FTimerHandle timer_handle; 最后开始定时：1timer.SetTimer(timer_handle, this, &amp;USampleActorComponent::TimerMethodWnted, 1.0, false); 参数的意思应该一目了然了。 道听途说1.关于C++中的资源释放一般在c++中应该是资源的获取与申请（new等等的操作）与资源的释放都是需要程序员手动操作的。但是如果使用了UE管理的资源，比如继承了UE中的类库等等的操作，那么释放这些资源的操作，在UE中会自动释放而不需要程序员的额外操作，反而要是操作了还会出问题。 当然这个问题只是道听途说，未能够验证。 当然需要仔细调查了啊 2.关于UE中UObject的派生对象的垃圾回收问题如果一个UObject的派生类对象中有一个UObject的派生类对象的指针变量，当这个指针变量经过NewObject&lt;&gt;()的操作实例化了之后，这个实例化对象就成为了GC对象（garbage collection）,但是仅仅如此还不足以达到自动回收的目的，像下面这样在声明之前加上UPROPERTY()宏，就不需要显式的delete垃圾回收了。12UPROPERTY()UObject* MyObjectReference; 总结来说，在C++中使用了new等等的方式来申请了一部分空间的话在使用结束的时候需要显式的释放掉，否则的话就会造成内存泄漏。然而上述的使用方式会使得这样声明的实例对象能够得到的资源自动回收。 参考来源: [Question]UObject Pointer References 关于C++好像发现了一个不得了的链接貌似可以在这个链接中找到C++的标准文档，英文文档。 Open Standards]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#中的单例模式-SingletonPattern]]></title>
    <url>%2F2018%2F07%2F15%2FC%23%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-SingletonPattern%2F</url>
    <content type="text"><![CDATA[这次来整理一下C的单例模式，参考的文章是Implementing the Singleton Pattern in C#。 曾经在做一个数据库管理类中经常多次使用了一个数据库管理的实例类对象，每次在新的不相关的类中需要使用数据库操作的时候都重新实例化一个数据库管理类对象，久而久之就觉得有些麻烦。便决定使用单例模式来管理，同时深究一下单例模式与C#中的使用。 算是这篇文章的汉化与总结吧。 –未完–]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Semaphore-信号量]]></title>
    <url>%2F2018%2F06%2F28%2FSemaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Semaphore,中文叫信号量，日语叫セマフォ（= .=）。经常会在多线程的编程中用到。信号量说简单点就是为了线程同步，或者说是为了限制线程能运行的数量。 仔细说明一下就是，信号量会在内部维护一个计数器，当一个线程调用了这个信号量，计数器就会减1，直到计数器减为0，调用这个信号量的线程将会被阻塞，直到有别的线程释放掉一个信号量使其计数器加1。 那么问题就来了，这个信号量维护的这个计数器应该是对线程的死锁有所防护的，也就是说同一时间只有一个线程能过获取这个信号量，而且当线程获取信号量的时候对信号量中的计数器进行减操作是具有原子性的操作。对于这个计数器的保存位置应该深入调查一下。 实例代码：12345678910111213141516171819202122232425262728293031323334353637383940414243using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading;namespace Semaphore1&#123; class Program &#123; //我设置一个最大允许5个线程允许的信号量 //并将它的计数器的初始值设为0 //这就是说除了调用该信号量的线程都将被阻塞 static Semaphore semaphore = new Semaphore(0, 5); static void Main(string[] args) &#123; for (int i = 1; i &lt;= 5; i++) &#123; Thread thread = new Thread(new ParameterizedThreadStart(work)); thread.Start(i); &#125; Thread.Sleep(1000); Console.WriteLine(&quot;Main thread over!&quot;); //释放信号量，将初始值设回5，你可以将 //将这个函数看成你给它传的是多少值，计数器 //就会加多少回去，Release()相当于是Release(1) semaphore.Release(5); &#125; static void work(object obj) &#123; semaphore.WaitOne(); Console.WriteLine(&quot;Thread &#123;0&#125; start!&quot;,obj); semaphore.Release(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS真机安装Build出错]]></title>
    <url>%2F2018%2F06%2F08%2FiOS%E7%9C%9F%E6%9C%BA%E5%AE%89%E8%A3%85Build%E5%87%BA%E9%94%99%2F</url>
    <content type="text"><![CDATA[为了面试，需要用尽一切手段了，把自己的毕业设计的时候做的2D游戏也拿出来了（捂脸）。找到了自己之前保存好的已经编译好的安装包，希望能够平安无事的安装到自己的系统高版本的iPhone7上。但是再次编译的时候果不其然还是要报错。1'__declspec' attributes are not enabled; use '-fdeclspec' or '-fms-extensions' to enable support for __declspec attributes 但是无论是Xcode还是Unity都已经升级的面目全非了，打开以前保存的Unity工程果不其然各种报错。想要解决出现的问题，第一个是NGUI的版本问题，代码中出现的一部分说是已经不支持Unity5.4+了…上网搜了一下，结果没有找到任何解答。 第一下就碰壁，只能再回去找已经编译好的文件的Build错误了。 问题解决继续搜关键词，看到了Unity社区中有一个这个提问：Error “unknown type name __declspec” after Xcode 7.3 upgrade 出问题的代码部分跟我的是一样的:1234567NORETURN static void il2cpp_codegen_raise_exception (Il2CppCodeGenException *ex)&#123; il2cpp::vm::Exception::Raise ((Il2CppException*)ex);#if __has_builtin(__builtin_unreachable) __builtin_unreachable();#endif&#125; 当然我是根本不知道这几行代码到底是干什么的。但是就是出错了…继续往下看，好像看到了一个解决方案: It has helped me: 1) Remove ‘NORETURN’2) Clean build3) Build it Like a hack:) XCode7.3, Unity5.2.2 UPD: XCode7.3, Unity5.3.4f1 - no issue 跟我的情况太像了，抱着试一试的态度，然后…Build通过了，游戏也成功的安装到了我的手机上了。 で？这个NORETURN到底是个什么？ 查了一下发现这个属性不光是Swift中的，C++中也有。所以说我已经厌倦了什么都学，什么都学对自己来说就是什么都学不会。自己之前一段时间看了Swift然后又去干别的，妥妥的全部忘光。 noreturn in Swiftnoreturn是一种属性，被这个属性修饰的函数表示没有任何返回值，函数可以被重写，但是重写之后也必须没有返回值。 具有代表性的函数有：exit(),abort()等等。 这里有一篇介绍Swift的Attributes的文章Swift - Attributes(@attribute) について 【編集中】介绍了Swift中的修饰属性。 noreturn in C++相比之下我更在意noreturn在C++中的作用。试着查了一下What is the point of noreturn? 字面意思看起来是:不返回函数的结果，没有返回值。但实际上跟void funtion还是有很大的区别。 void function运行会返回调用函数，只不过没有返回值。 被noreturn修饰的函数在运行结束之后并不会返回调用函数。 12345678910[[ noreturn ]] void f() &#123; throw "error"; // OK&#125;void g() &#123; f(); // unreachable: 在调用了`f()`之后，下面的代码永远不会执行 std::cout &lt;&lt; "No! That's impossible" &lt;&lt; std::endl;&#125; 别的事情不说，每次发现这种有关语言的语法的地方不明白的时候，就觉得特别打脸。]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>Bugs</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zsh找不到gulp工具包]]></title>
    <url>%2F2018%2F05%2F30%2Fzsh%E6%89%BE%E4%B8%8D%E5%88%B0gulp%E5%B7%A5%E5%85%B7%E5%8C%85%2F</url>
    <content type="text"><![CDATA[不能上网，一上网问题就接踵而来。今天突然看到了hexo博文压缩这个功能，就想着这个可以有，就按照教程安装了gult。安装完运行hexo g &amp;&amp; gulp之后准备舒舒服服的打包的时候，我一向视同己出的zsh弹出来了这个提示1zsh: command not found: gulp 刚装的你跟我说找不到？我信了你的邪。 自己解决应该是有点难度了，只能借用大家的智慧了。在网上搜到了这两篇博文COMMAND NOT FOUNDWITH A NODE MODULE (NPM) SOLUTION与【gulp】zsh: command not found: gulp!!!「急にgulpが壊れた!」と思ったら読む記事完美的解决了我的问题。 原因可以从下面的命令中看出来 1234➜ blog npm root/Users/stone/Documents/mynote/BLOG/blog/node_modules➜ blog npm root -g/Users/stone/node_modules gulp被安装到了个人文件夹中去而不是NPM命令的全局文件夹。 解决办法是运行下面的命令1npm config set prefix /usr/local 再运行一次npm root -g应该就会看到执行后的结果变化12➜ blog npm root -g/usr/local/lib/node_modules 然后再次安装gulp，应该是全局的安装1npm i -g gulp 确认gulp的版本123➜ blog gulp -v[23:25:50] CLI version 3.9.1[23:25:50] Local version 3.9.1 出现了一个CLI版本跟一个本地的版本。嘛，反正是好用了。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown文件转换为PDF文件]]></title>
    <url>%2F2018%2F05%2F29%2FMarkdown%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E4%B8%BAPDF%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近闲来无事(实际上由于跳槽面试的原因忙的要死)，在知乎上看到了一篇搭建博客的文章，看了一眼发现对于我这种WEB盲还挺友好，于是就自己搭建了这个博客。 就在ZH上捞鱼捞的正爽的时候，面试(未)公司发来了要看看我的作品的消息。我一看表现的时候到了，就掏出我刚学的Markdown来写了几篇我的作品的说明文。正当我想把刚build好的html文件打包压缩发送过去的时候，(自动脑补柯南的灵光一闪音效)我发觉事情并不是这么简单。 要是我作死直接发了一堆html过去，估计就别想见到人家了，就算见到了人家公司的HR，估计见面也有不小的概率会被锤。这个时候慌乱的我,手不由自主的打开了谷歌并输入了:How to convert markdown to pdf.然后发现正确的提问用法是:How to convert from markdown to pdf. (；´∀｀)嘛，英语不好这得批评，早晚得去考一次托福… 搜到的第一个是说用谷歌上的插件:Markdown Preview Plus - Chrome Webstore.ドラッグアンドドロップ就可以转换了。什么？ドラ…什么的，打开谷歌翻译:drag and drop.我… 但是利用网上的插件总感觉有些难受，还要上传文件什么的，万一上传到人家服务器上被人家看到了里面的内容就不好了(WEB盲)。于是看到了第二个方法：使用Node.js的工具markdown-pdf 1npm -g install markdown-pdf 安装好工具之后 1markdown-pdf 我的说明文.md 就能生成想要的PDF文件了。浏览生成的PDF文件的时候唯一在意的就是Markdown给隐藏起来的URL链接PDF文件也一并显示了出来。难不成是制作人有意这样，亦或者是机关在作祟，我就暂时不得而知了。因为现在的我得等人家的面试通知。 唉…寝よう]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Markdown</tag>
        <tag>碎碎念</tag>
      </tags>
  </entry>
</search>
