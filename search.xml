<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[UE4中的异步处理]]></title>
    <url>%2F2018%2F08%2F01%2FUE4%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[能够熟练的使用UE4中的异步处理应该能够很好的利用程序运行的资源，和计算。除此之外还有并行的处理。目的是要理清UE4中的线程的同步异步，并行操作和标准C++中的线程同步异步，并行操作。 时间有限，暂时记录下关键字： UE C++ ThreadPool 异步处理相关函数： Async Lambda记法 AsyncTask ParallelFor123//函数的位置Engine/Source/Runtme/Cre/Pblic/Async/Async.hEngine/Source/Runtme/Cre/Pblic/Async/ParallelFor.h 异步辅助API FScopeLock]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的C++]]></title>
    <url>%2F2018%2F08%2F01%2FUE4%E4%B8%AD%E7%9A%84C%2F</url>
    <content type="text"><![CDATA[UE C++拥有着自己的库，当然也可以使用C++的标准库(STL)，但是不同的地方还应该好好记载下来，同时也是对C++的一种复习。 值类型？指针？在标准C++中，类的声明可以12345ClassExample ObjName;/或者是ClassExample* ObjPtr; 而在UE4中为了统一值类型与指针的规则，想这种类的声明全部使用指针类型，不使用值类型。1UObject* o; UE4生成类对象实例(Instance)直接上例子：12345678//声明UMyClass* MyClass;//生成实例MyClass = NewObject&lt;UMyClass&gt;();//或者MyClass = NewObject&lt;UMyClass&gt;(Owner); Tips: 在构造函数中不能使用NewObject&lt;T&gt;生成其他的对实例。会使程序Crash。如果想生成其他的Object的话使用FObjectInitializer::CreateDefaultSubobject&lt;T&gt;函数 123ASomeActor::ASomeActor(const FObjectInitializer &amp; ObjectInitializer) : Super(ObjectInitializer)&#123; SampleActor = ObjectInitialize.CreateDefaultSubobject&lt;ASampleActor&gt;(this, TEXT("SampleActor"));&#125; Actor的实例化Actor的Component实例化从Content(Asset)中加载Object对象数据UE4中的容器]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的智能指针]]></title>
    <url>%2F2018%2F07%2F31%2FUE4%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[对于内存使用的了解，就不得不了解指针。UE4拥有跟C++类似的智能指针，在这里对虚幻4的智能指针库的内容进行一些总结跟提炼，同时也需要对C++的智能指针进行深入的了解。 UE4的智能指针智能指针并不能使用UPROPERTY()，TSharedRef,TSharedPtr,TWeakPtr等等。 参考链接： Unreal Smart Pointer Library C++的指针]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的函数回调实现]]></title>
    <url>%2F2018%2F07%2F31%2FUE4%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%9B%9E%E8%B0%83%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[回调函数的含义，实际上我也不太清楚，搜回调函数得到的关键字有很多：闭包，代理，委托，Wrapper，等等。但有一点我很清楚，这些我都不太懂。 说是在不同的语言中有不同的叫法。其本质上就是一个函数指针，而在汇编层面，就是子程序代码的首地址。每一段编译器先放一个占位符，最后放入实际的值。 上面的话是Unreal用到一些编程技巧里的内容。 UE4中的函数回调(CallBack)C++中应该有许多种方式的回调，UE C++(UnrealEngine中的C++)则是使用的DELEGATE和EVENT来实现。 关于UE C++的代理，存在着以下的几种方式： 静态的Single-cast Delegates Dynamic Single-cast Delegates 静态的Multi-cast Delegates Dynamic Multi-cast Delegates 这几种代理的实现有什么不同需要后续整理，可以参考： What difference betweens delegates? 有的时候需要很好的利用一下UE4的官方论坛，像是Stack Overflow一样。 Dynamic Multi-cast DelegatesDynamic Multi-cast Delegates是唯一的一种可以和UE4的Blueprint联动的代理实现方式。 Dynamic Multi-cast Delegates的UE C++中的声明12345678910//File: CallbackExample.h//Class: ACallbackExampleDECLARE_DYNAMIC_MULTICAST_DELEGATE(FZeroInputDelegate); //没有参数的声明方法UPROPERTY(BlueprintAssignable, Category="UE C++ Book") //BlueprintAssignable属性使得这个代理在Blueprint中也取得到。 -&gt;此处在真正的工程中不应该写注释，会出编译问题FZeroInputDelegate TheZeroInputDelegate;DECLEAR_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FTwoInputsDelegate, float, FloatVal, int32, IntVal); //两个参数的声明方法UPROPERTY(BlueprintAssignable, Category="UE C++ Book")FTwoInputsDelegate TheTwoInputsDelegate; Tips: 参数最大允许有8个。参数的声明类似上述两个参数的声明，先是类型后是参数名。 参数不同的代理声明只需要将上述的数字换成相应参数的英文就可以，比如说八个参数的情况声明代理的语句就会变成：DELEAR_DYNAMIC_MULTICAST_DELEGATE_EightParams 这样制作的代理，可以在UE的Blueprint中获得到这个代理（似乎是作为Event）并进行实现了。别忘了指定Event与Target。即把这个代理委托给一个类的实例(Instance)。在Blueprint中似乎是以Event而存在的，Blueprint中实现的操作是把这个调用的Event登录到这个代理上去。这样在UE C++中调用这个代理，也会调用Blueprint中的事件，执行这个事件的实现部分。 调用Blueprint中的代理实现1234567// File: CallbackExample.cpp// Class: ACallbackExampleauto ACallbackExample::ExecuteDelegate(const float FloatVal, const int32 IntVal) -&gt; void &#123; TheZeroInputDelegate.Broadcast(); TheTwoInputsDelegate.Broadcast(FloatVal, IntVal);&#125; 官方参考链接： Dynamic Delegates EventsBlueprint Event与Blueprint Function关于事件与函数的区别，没有返回值的被叫做事件，有返回值的叫做函数。是否真实需要验证。在UE C++中可以登录Blueprint的事件，通过给UPROPERTY宏添加属性来完成。话说回来这个是函数，应该使用UFUNCTION宏才对，不知道为什么书上这么说。 用于事件声明的属性有两种，区别的方式是是否在UE C++中有默认的实现。 BlueprintImplementableEvent:没有默认实现 BlueprintNativeEvent:拥有默认实现 Blueprint Event,Blueprint Function在UE C++中的声明12345678910111213141516// File: CallbackExample.h// Class: ACallbackExample// BP EventUFUNCTION(BlueprintImplementableEvent, Category="UE C++ Book")void FloatInputEvent(const float FloatVal);UFUNCTION(BlueprintNativeEvent, Category="UE C++ Book")void VectorInputEvent(const FVector&amp; VecValue);// BP FunctionUFUNCTION(BlueprintImplementableEvent, Category="UE C++ Book")float IntInputFunction(const int32 IntInput);UFUNCTION(BlueprintNativeEvent, Category="UE C++ Book")TArray&lt;float&gt; VecArrayInputFuncion(const TArray&lt;FVector&gt;&amp; VecValues); Event的默认实现12345678910111213141516// File: CallbackExample.cpp// Class: ACallbackExample//static FVector TheVector事先声明的属性auto ACallbackExample::VectorInputEvent_Implementation(const FVector&amp; VecValue)-&gt;void&#123; TheVector = VecValue;&#125;auto ACallbackExample::VecArrayInputFuncion_Implementation(const TArray&lt;FVector&gt;&amp; VecValues)-&gt; TArray&lt;float&gt;&#123; TArray&lt;float&gt; Result; for (const auto&amp; Val : VecValue) Result.Emplace(FVector::Dist(TheVector, Val)); return Result;&#125; 以上的代码实装完成之后，继承了上面的CallbackExample类的Blueprint就可以在Blueprint Editor中对上述UE C++中的事件与函数进行重写了。 以上，是对UE中的代理与事件，在可用范围内的总结与实现。但是对于在什么情况下使用这一点上仍然有许多疑问。 为什么要使用Delegate和Event？关于代理的实现，就算明白了也需要知道需要在什么情况下使用代理，否则没有意义。 关于Event在UE4中的Blueprint中应没有委托这一说，全部是以Event的名字来称呼的。 Delegate的使用情况推测1面向对象的说法只是一种理想的情况，总会有想要实现别人功能的情况。比如说ClassA想要实现一个功能，但是明显这个功能是由ClassB负责的部分，要是自己来实现的话不好，所以自己的话，声明一个Delegate，想用的时候就把这个广播出去(Broadcast)，实现了这接口的内容会被调用。 只言片语： 现在我要对一系列数据进行排序，而排序算法可能比较复杂，我不会自己写，我想调用Array.Sort方法，微软为我们提供了快速排序算法。但是这里有一个问题——我要实现自定义排序规则，比如对于字符串，默认的是按字母顺序，但现在我想这样排序： 按字符串长度排序，只有当长度不同时，再按字母排序。 显然，微软不可能提供这样“个性”的排序方法，那是不是说，就必须让我们自己去写快速排序算法呢？不需要！我们只需要使用委托，就能实现这个要求：string[]strs=”I like C# very much”.Split();Array.Sort(strs,Rule);int void Rule(string first,string second){return first.Length==second.Length?first.CompareTo(second):first.Length.CompareTo(second.Length);} 显然，我并不需要知道快速排序算法的逻辑，我只需要告之排序规则，就实现了我的个性排序。 试问：如果没有委托，你如何解决这个问题？ C++中的代理实现代理应该涉及了许多知识，完全理解需要后续的更新整理。 参考链接： C++中实现委托（Delegate） C++实现Delegate Event实例(例子、example、sample) C++委托实现(函数指针，function+bind，委托模式) 高效C++委托的原理]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGl学习内容整理]]></title>
    <url>%2F2018%2F07%2F25%2FOpenGl%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[主要是记录自己学习OpenGl内容。 OpenGL学习网站参考： Learn OpenGL Learn OpenGL中文翻译]]></content>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UnrealEngine着色器开发整理]]></title>
    <url>%2F2018%2F07%2F25%2FUnrealEngine%E7%9D%80%E8%89%B2%E5%99%A8%E5%BC%80%E5%8F%91%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[整理自己在学习Unreal Engine 4着色器过程中遇到的问题和知识点。 Unreal Engine 4设定1. UE4的内置材质Shader函数库位置UE4Shader的编写入门反而相对比较容易，使用自带的各种函数库拉拉线竟然就可以完成。函数库的位置都在: 位置： C:\Program Files\Epic Games\UE_4.19\Engine\Shaders\Private UE4的安装文件夹中 2. Material.cpp文件位置 C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Private\Materials]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4中的粒子特效]]></title>
    <url>%2F2018%2F07%2F24%2FUE4%E4%B8%AD%E7%9A%84%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[主要是用来记录学习虚幻引擎4的粒子的过程 Particles with Unreal Engine 4先是在UE4提供的官方教程中整理基础的知识点。官方Youtube视频。 Particle Particle Particle System Emitter Actor Particle System Component Cascade Emitter Emitter Module tips: 在Emitter(粒子发射器)的各个Module中，按住alt键拖动可以复制Module 按住shift可以共享Module，即只需要修改一个其他的都会被修改 Type Data Distributions]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Particles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于学习UE4的粒子系统过程中遇到的疑问]]></title>
    <url>%2F2018%2F07%2F20%2F%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0UE4%E7%9A%84%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E7%96%91%E9%97%AE%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[记录刚学UE的一些疑问]]></title>
    <url>%2F2018%2F07%2F18%2F%E8%AE%B0%E5%BD%95%E5%88%9A%E5%AD%A6UE%E7%9A%84%E4%B8%80%E4%BA%9B%E7%96%91%E9%97%AE%2F</url>
    <content type="text"><![CDATA[为了记录自己在学习UE引擎过程中遇到的一些疑问点 C++与C#的不同之处时隔多年见到C++的第一个违和感是头文件，为什么需要写头文件这个问题我找了一些别人写的代码发现了一下几个规则： 在C++的头文件中SampleCode.h中一般都会预先定义一些东西 需要包含的其他头文件 123#include "Engine.h"#include "MyAppUtilities.h"... 定义需要使用的宏 预处理（C++的预处理器需要了解一下） 123//一般常量居多？#define PI 3.1415926... 定义类，类中包含该有的成员， 123456789class SampleClass&#123; //Attributes or functions public: protected: private:&#125; UE4中的C++不同的地方1.UCLASS()宏想要让类与UE4的类库联动的话，就需要这个宏。 UCLASS()大概的使用方法Sample Code:12345678910111213141516171819202122#include "Engine.h" //如果需要使用UE的library的话#include "MyAppUtilities.h"UCLASS()class UMyClass : public UObject&#123; GENERATED_BODY() public: //构造函数(公有的？) UMyClass(); UPROPERTY(BlueprintReadWrite, Category = "MyApp") int32 IntProp; UFUNCTION(BlueprintCallable, Category = "MyApp") float LengthOfSomething(const int32 index); private: TArray&lt;int&gt; IntArrayWork; //标准c++中的数组声明 //std::vector&lt;int&gt; IntArrayWork;&#125; 对于UCLASS()，如果需要继承UE的类库，则都要加上这个。最好声明的类名也以U开头为好？ 但是我觉得这种声明不是跟UE的类库搞混了吗，辨识度低我觉得应该没有这么智障的规则。好的，有这种规则好像。类似的其他的以E,F,I,T,S等等的字母作为变量名的开始。 关于在头文件中添加注释的问题，在UE4的执行中倘若添加了日语(应该中文也一样)的注释，有可能会发生问题。所以在头文件中尽可能的使用英文注释。还有应该避免在各种宏的后面直接追加注释。 就目前的问题来说在UFUNCTION宏的后面直接加入日文注释(UTF-8)的话，会有编译无法通过的问题。所以为了避免上述问题应该尽量： 头文件中使用英文注释 不要直接在各种UE4的宏后面(例如UFUNCTION后)直接添加注释。 UCLASS() 参数的含义CPPExampleActor.h123456789101112131415161718192021#pragma once#include "GameFramework/Actor.h"#include "CppExampleStruct.h"#include "CppExampleEnum.h"#include "CpExampleActor.generated.h"UCLASS(BlueprintType)class ACppExampleActor : public AActor&#123; GENERATED_BODY()public: UPROPERTY(BlueprintReadWrite, EdtAnywhere, Category="UE C++ Book") FCppExampleStruct MyStructProp; UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="UE C++ Book") ECppExampleEnum Type; UFUNCTION(BlueprintCallable, Category="UE C++ Book") float MyActorFunc(const float Input);&#125;; 通过指定UNCLASS()的参数，可以指定类的类型。 BlueprintType表示这个类可以作为Blueprint的变量来使用。 UPROPERTY()的声明，在这个Actor的Detail面板上可以看到该Category下有声明的MyStructProp和Type属性。 具体的BlueprintType的使用例子则仍需要调查。BlueprintType类型能做到的事情。 多个参数 1UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) ) 这个的使用含义现在还不清楚各自代表着什么意思。 USTRUCT()结构体CppExampleStruct.h1234567891011121314#pragma once#include "CppExampleStruct.generated.h"USTRUCT(BlueprintType)struct FCppExampleStruct &#123; GENERATED_BODY() UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="UE C++ Book") float Value; UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="UE C++ Book") int32 Index;&#125;; 构造体的声明名字最好以F开始。其他的基本上使用方法与类相同。 UENUM()枚举类型CppExampleEnum.h12345678#pragma onceUENUM(BlueprintType)enum class ECppExampleEnum : uint8 &#123; None = 0, Foo, Bar&#125;; 对于enum class ECppExampleEnum : uint8这种写法有些迷惑。 class是为了使枚举类型更安全。为什么安全，参考下面的链接。之后整理。 uint8是为了指定枚举器的基础类型。 参考链接: C++11的enum class &amp; enum struct和enum C\C++中的整形提升 C++标准文档-n2347 2.GENERAED_BODY()这一句话必须要写的原因需要调查 3.UPROPERTY() UFUNCTION()使用这个声明的属性跟方法UE的Blueprint可以使用。 UPROPERTY()宏UPROPERTY()的参数的含义 UPROPERTY()没有参数的情况，UE4的Blueprint和Level Editor都不能读取或者修改，但是却可以将这个变量纳入到UE4的GC对象中。比如： 12UPROPERTY()AActor* OwningActor; 这种情况，如果OwningActor拥有了实例化对象，不手动释放也是没有问题的。或者说注意别手动释放了，会出问题的。 UPROPERTY(EditAnywhere, Category=&quot;UE C++ Book&quot;,EditAnywhere属性表示在Level Editor中也可以操作这个属性。 那么Blueprint与Level Editor的差别在哪里，需要调查。 猜测的结果，Blueprint就是那个连来连去的蓝图，可以在那个蓝图的编辑器中取到属性。 Level Editor指的是操作的画面，在Level Editor中可以取到的意思应该是在Detail panel中直接设定或者读取值那样。 UPROPERTY(BlueprintReadWrite, Category=&quot;UE C++ Book&quot;),BlueprintReadWrite表示Blueprint可以读写。 其他的属性，还有meta属性可以查找下面的链接： Property Specifiers Metadata SpecifiersUFUNCTION宏12UFUNCTION(BlueprintCallable,Category = "UE C++")static float FunctionName(const float Variable); 像上面的使用方法，在函数的前面添加UNFUNCTION macro宏可以制作UE4的Blueprint编辑器的函数节点以供调用。在虚幻4的Blueprint编辑器中使用此函数。 4.TArray-UE4中的数组（重要）先上本家，官方文档TArray:Arrays in Unreal Engine。 再上中文翻译虚幻引擎中的数组–TArry:Arrays 5.C++中的静态函数static与UE C++(Unreal Engine C++)的静态函数在C++中的静态函数与非静态函数的执行确实是有差别的。 复习一下C++中的静态函数： static修饰变量 static修饰函数参考文章： C/C++ 中的static关键字 存储类 (C++) C++静态成员函数 C++ static静态成员变量 UE C++中关于静态函数的使用应该大同小异，但是也不排除有差别的可能性。 将来可能会派上用场的文章 クラスにスタティック変数を持たせたい 6.Blueprint函数node(节点)的输入与输出在UE C++中函数的参数对应Blueprint的node的输入pin，函数的返回值则对应着node的输出pin12UFUNCTION(BlueprintCallable,Category="classcategory")bool MyFunc(const int a,int b,const int&amp; c,int&amp; d) 上述的情况下a,b,c三个变量对应着node的三个输入pin，但是return value,d对应着node的输出pin。也就是说：没有const修饰的引用型参数会被分配到输出pin的阵营中。 这里便引申出几个问题 UE C++的函数参数为什么要使用const修饰，使用常量的必要性是什么 万一想要使用const修饰的引用型参数作为node的输入pin怎么办 想要增加node的输出pin的话，除此之外还有别的写法么 Blueprint支持的数据类型很有限 bool uint8 int32 float 7.UE4的Head FileUE4中的头文件有许多中，为了能够分清使用方法把遇到的头文件整理一下 Actor.h一般的写法是1#include "GameFramework/Actor.h" 一般是继承了UE4中的Actor类的话都需要包含这个头文件。 xxx.generated.h比如说1#include "CppGate.generated.h" 这个头文件是有UE4的UnrealHeaderTool自动生成的文件。如果类继承了UObject类并且想要在Blueprint中使用这个类的话，就需要include这个头文件。 8.UE4中的特殊容器1.FVector一个表示3D空间的向量。可以用来表示空间的一个点或者方向。 参考链接： FVector 9.类的初始值设定基础类型变量的初始化可以在声明的同时进行，以外的数据类型(FVector等)初始化需要在构造函数中进行。静态变量的初始化则需要在类外进行。123int ClassExample::static_var; //equle 0//or lik thisint ClassExample::static_var = 4; #pragma once vs include guard打开UE工程看到一些.h头文件的源码的时候看到了#pragma once有些困惑，不知道是做什么用的。于是调查了一下。 总体来说这两个命令都是为了避免同一个头文件被include多次 方式1：1234#ifndef __SOMEFILE_H_#define __SOMEFILE_H_...#endif 方式2：12#pragma once... #ifndef方式这种方式受C/C++语言标准支持，可以保证同一个文件不会被同时包含，也能保证内容完全相同的两个文件（或者代码片段）不会被同时包含。缺点是不同头文件中的宏的名字如果相同，会导致编译器找不到声明的问题。另外由于编译器每次需要打开头文件来判定是否有重复的定义，会导致编译的时间要长。 #progma once方式这种方式是保证“物理存在上”同一个文件不会被包含多次。而不是内容相同的两个文件。而且无法对一个头文件中一段代码做pragma once声明，只能针对文件。当然也不会发生第一种方式的宏名碰撞引发的问题。 使用哪一种方式见仁见智，有好处有坏处。根据情况使用。 附上别人的博客链接: #pragma once与#ifndef解析 时间线比较新的分析: インクルードガードとpragma once stackoverflow上关于上述两种方式的争论: #pragma once vs include guards? C++中的类与结构体参考链接： 详解C结构体、C++结构体 和 C++类的区别 C++中的weak pointerstd::weak_ptr是一个很好的解决悬空指针问题的方式。使用原生指针（raw pointers）的话不知道现在所引用的资源是否已经被释放。而使用std::shared_ptr来管理的话，std::weak_ptr只管使用，而不关心资源的使用情况，反正也不管理指向的资源。 因为本身std::weak_ptr并不能直接引用到对象，不会影响对象的自动释放，不会影响对象的引用计数，需要使用lock()来升级到std::shared_ptr来进行操作。 参考资料： C++ weak pointer When is std::weak_ptr useful? 开启HSLS语法高亮HLSL Tools for Visual Studio应该是HLSL的语法编辑器插件，有自动补全的功能，附上下载链接。但是并没有解语法高亮的问题。 下载链接： HLSL Tools for Visual Studio 在VS2017中开启语法高亮（syntax high lighting）虽然不是针对VS2017的解决方案，但是设定之后的确解决的这个问题： 设定顺序： 在VS2017中 Go to Tools -&gt; Options -&gt; Text Editor -&gt; Fie Extension 在这里选择编辑文件的扩展名与文法编辑器，然后添加保存。 这样设定应该里面有效果了。 参考链接： How to get syntax highlighting for alternate file extension for Visual Studio 2010 or 2013? UE4中使用的一些Tip1. 快速制作封闭空间快速挖空一个几何体的制作顺序： Modes panel -&gt; Geometry -&gt; Box -&gt; 设置尺寸 Details panel -&gt; Brush settings -&gt; Hollow 属性check 2.调整模型的模型坐标的原点根据模型的大小来调整模型坐标的原点，顺序： 双击UE4中导入的模型，打开材质编辑器(static mesh editor也叫Material Editor) 点击Show Pivot显示模型坐标，同时在左上角看见，模型的大小 在Detail panel中找到Transform，调整Import Tansiation的数值，移动坐标系 Tool bar -&gt; Asset -&gt; Reimport Model 之后就会发现模型坐标按照指示移动了 3.制作天空球(与雾)感觉要制作出天空的感觉同时还有雾的模糊的时候使用，可以看见太阳就是不知道能否模拟太阳的移动 顺序: 选定平行光源，开启Light -&gt; Atmosphere/Sun light 将Visual Effects -&gt; Atmospheric Fog 拖拽至场景中 Content Browser panel右下的View Options中开启Show Engine Content 在Engine Content中找到BP_Sky_Sphere并将其拖拽至场景中 在BP_Sky_Sphere的Details面板中的Directional Light Actor选定上面的平行光 4.UE4中的Volume应用在UE中使用Volume执行不同的任务可以解决很多问题，比如说： 给玩施加伤害 改变物理定律，在Volume中允许玩家悬浮等等 作为碰撞表面，不允许玩家进入 改变计算关卡光照和可见性方式 等等，出了直接使用Modes panel中的Volume工具之外，也可以直接将几何体笔刷(brush)转化为相应的Volume。Details -&gt; Actor -&gt; Convert Actor -&gt; Volume(that you want) 参考资料： Volume Reference 5.Z-FightingZ-Fighting又Depth Fighting，深冲突。就是贴图会出现闪烁的情况，与实际模型产生交叉融合 z-fighting的出现是的不同面上的像素在z-buffer中的值相近，导致前台取像素的时候一会去这个面的，一会取那个面的。改变照相机的near、far属性会涉及到z-buffer中的值的精度。因为在各个平台上z-buffer位数不同，因此改变near和far能给z-buffer中的值的浮点数部分尽量留出空间，消除z-fighting。 参考： z-fighting在unity中的解决方式 6.将选定的Actor合并为组使用Ctrl+G的快捷键可以快速把选定的Actor(场景的素材)合并为一组，下次选定的时候会选定为一组。便于移动或者复制。 使用Shift+G的快捷键会解除分组。当然这些操作都可以在选中Actor之后: Right Click -&gt; Group进行分组和分解 7.UE4中的Material和Material Function在UE4中偶然看到了这两个材质的声明，发现名字不太一样，需要调查一下。 道听途说1.关于C++中的资源释放一般在c++中应该是资源的获取与申请（new等等的操作）与资源的释放都是需要程序员手动操作的。但是如果使用了UE管理的资源，比如继承了UE中的类库等等的操作，那么释放这些资源的操作，在UE中会自动释放而不需要程序员的额外操作，反而要是操作了还会出问题。 当然这个问题只是道听途说，未能够验证。 当然需要仔细调查了啊 2.关于UE中UObject的派生对象的垃圾回收问题如果一个UObject的派生类对象中有一个UObject的派生类对象的指针变量，当这个指针变量经过NewObject&lt;&gt;()的操作实例化了之后，这个实例化对象就成为了GC对象（garbage collection）,但是仅仅如此还不足以达到自动回收的目的，像下面这样在声明之前加上UPROPERTY()宏，就不需要显式的delete垃圾回收了。12UPROPERTY()UObject* MyObjectReference; 总结来说，在C++中使用了new等等的方式来申请了一部分空间的话在使用结束的时候需要显式的释放掉，否则的话就会造成内存泄漏。然而上述的使用方式会使得这样声明的实例对象能够得到的资源自动回收。 参考来源: [Question]UObject Pointer References 关于C++好像发现了一个不得了的链接貌似可以在这个链接中找到C++的标准文档，英文文档。 Open Standards]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#中的单例模式-SingletonPattern]]></title>
    <url>%2F2018%2F07%2F15%2FC%23%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-SingletonPattern%2F</url>
    <content type="text"><![CDATA[这次来整理一下C的单例模式，参考的文章是Implementing the Singleton Pattern in C#。 曾经在做一个数据库管理类中经常多次使用了一个数据库管理的实例类对象，每次在新的不相关的类中需要使用数据库操作的时候都重新实例化一个数据库管理类对象，久而久之就觉得有些麻烦。便决定使用单例模式来管理，同时深究一下单例模式与C#中的使用。 算是这篇文章的汉化与总结吧。 –未完–]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Semaphore-信号量]]></title>
    <url>%2F2018%2F06%2F28%2FSemaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Semaphore,中文叫信号量，日语叫セマフォ（= .=）。经常会在多线程的编程中用到。信号量说简单点就是为了线程同步，或者说是为了限制线程能运行的数量。 仔细说明一下就是，信号量会在内部维护一个计数器，当一个线程调用了这个信号量，计数器就会减1，直到计数器减为0，调用这个信号量的线程将会被阻塞，直到有别的线程释放掉一个信号量使其计数器加1。 那么问题就来了，这个信号量维护的这个计数器应该是对线程的死锁有所防护的，也就是说同一时间只有一个线程能过获取这个信号量，而且当线程获取信号量的时候对信号量中的计数器进行减操作是具有原子性的操作。对于这个计数器的保存位置应该深入调查一下。 实例代码：12345678910111213141516171819202122232425262728293031323334353637383940414243using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading;namespace Semaphore1&#123; class Program &#123; //我设置一个最大允许5个线程允许的信号量 //并将它的计数器的初始值设为0 //这就是说除了调用该信号量的线程都将被阻塞 static Semaphore semaphore = new Semaphore(0, 5); static void Main(string[] args) &#123; for (int i = 1; i &lt;= 5; i++) &#123; Thread thread = new Thread(new ParameterizedThreadStart(work)); thread.Start(i); &#125; Thread.Sleep(1000); Console.WriteLine(&quot;Main thread over!&quot;); //释放信号量，将初始值设回5，你可以将 //将这个函数看成你给它传的是多少值，计数器 //就会加多少回去，Release()相当于是Release(1) semaphore.Release(5); &#125; static void work(object obj) &#123; semaphore.WaitOne(); Console.WriteLine(&quot;Thread &#123;0&#125; start!&quot;,obj); semaphore.Release(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS真机安装Build出错]]></title>
    <url>%2F2018%2F06%2F08%2FiOS%E7%9C%9F%E6%9C%BA%E5%AE%89%E8%A3%85Build%E5%87%BA%E9%94%99%2F</url>
    <content type="text"><![CDATA[为了面试，需要用尽一切手段了，把自己的毕业设计的时候做的2D游戏也拿出来了（捂脸）。找到了自己之前保存好的已经编译好的安装包，希望能够平安无事的安装到自己的系统高版本的iPhone7上。但是再次编译的时候果不其然还是要报错。1'__declspec' attributes are not enabled; use '-fdeclspec' or '-fms-extensions' to enable support for __declspec attributes 但是无论是Xcode还是Unity都已经升级的面目全非了，打开以前保存的Unity工程果不其然各种报错。想要解决出现的问题，第一个是NGUI的版本问题，代码中出现的一部分说是已经不支持Unity5.4+了…上网搜了一下，结果没有找到任何解答。 第一下就碰壁，只能再回去找已经编译好的文件的Build错误了。 问题解决继续搜关键词，看到了Unity社区中有一个这个提问：Error “unknown type name __declspec” after Xcode 7.3 upgrade 出问题的代码部分跟我的是一样的:1234567NORETURN static void il2cpp_codegen_raise_exception (Il2CppCodeGenException *ex)&#123; il2cpp::vm::Exception::Raise ((Il2CppException*)ex);#if __has_builtin(__builtin_unreachable) __builtin_unreachable();#endif&#125; 当然我是根本不知道这几行代码到底是干什么的。但是就是出错了…继续往下看，好像看到了一个解决方案: It has helped me: 1) Remove ‘NORETURN’2) Clean build3) Build it Like a hack:) XCode7.3, Unity5.2.2 UPD: XCode7.3, Unity5.3.4f1 - no issue 跟我的情况太像了，抱着试一试的态度，然后…Build通过了，游戏也成功的安装到了我的手机上了。 で？这个NORETURN到底是个什么？ 查了一下发现这个属性不光是Swift中的，C++中也有。所以说我已经厌倦了什么都学，什么都学对自己来说就是什么都学不会。自己之前一段时间看了Swift然后又去干别的，妥妥的全部忘光。 noreturn in Swiftnoreturn是一种属性，被这个属性修饰的函数表示没有任何返回值，函数可以被重写，但是重写之后也必须没有返回值。 具有代表性的函数有：exit(),abort()等等。 这里有一篇介绍Swift的Attributes的文章Swift - Attributes(@attribute) について 【編集中】介绍了Swift中的修饰属性。 noreturn in C++相比之下我更在意noreturn在C++中的作用。试着查了一下What is the point of noreturn? 字面意思看起来是:不返回函数的结果，没有返回值。但实际上跟void funtion还是有很大的区别。 void function运行会返回调用函数，只不过没有返回值。 被noreturn修饰的函数在运行结束之后并不会返回调用函数。 12345678910[[ noreturn ]] void f() &#123; throw "error"; // OK&#125;void g() &#123; f(); // unreachable: 在调用了`f()`之后，下面的代码永远不会执行 std::cout &lt;&lt; "No! That's impossible" &lt;&lt; std::endl;&#125; 别的事情不说，每次发现这种有关语言的语法的地方不明白的时候，就觉得特别打脸。]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>Bugs</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zsh找不到gulp工具包]]></title>
    <url>%2F2018%2F05%2F30%2Fzsh%E6%89%BE%E4%B8%8D%E5%88%B0gulp%E5%B7%A5%E5%85%B7%E5%8C%85%2F</url>
    <content type="text"><![CDATA[不能上网，一上网问题就接踵而来。今天突然看到了hexo博文压缩这个功能，就想着这个可以有，就按照教程安装了gult。安装完运行hexo g &amp;&amp; gulp之后准备舒舒服服的打包的时候，我一向视同己出的zsh弹出来了这个提示1zsh: command not found: gulp 刚装的你跟我说找不到？我信了你的邪。 自己解决应该是有点难度了，只能借用大家的智慧了。在网上搜到了这两篇博文COMMAND NOT FOUNDWITH A NODE MODULE (NPM) SOLUTION与【gulp】zsh: command not found: gulp!!!「急にgulpが壊れた!」と思ったら読む記事完美的解决了我的问题。 原因可以从下面的命令中看出来 1234➜ blog npm root/Users/stone/Documents/mynote/BLOG/blog/node_modules➜ blog npm root -g/Users/stone/node_modules gulp被安装到了个人文件夹中去而不是NPM命令的全局文件夹。 解决办法是运行下面的命令1npm config set prefix /usr/local 再运行一次npm root -g应该就会看到执行后的结果变化12➜ blog npm root -g/usr/local/lib/node_modules 然后再次安装gulp，应该是全局的安装1npm i -g gulp 确认gulp的版本123➜ blog gulp -v[23:25:50] CLI version 3.9.1[23:25:50] Local version 3.9.1 出现了一个CLI版本跟一个本地的版本。嘛，反正是好用了。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown文件转换为PDF文件]]></title>
    <url>%2F2018%2F05%2F29%2FMarkdown%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E4%B8%BAPDF%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近闲来无事(实际上由于跳槽面试的原因忙的要死)，在知乎上看到了一篇搭建博客的文章，看了一眼发现对于我这种WEB盲还挺友好，于是就自己搭建了这个博客。 就在ZH上捞鱼捞的正爽的时候，面试(未)公司发来了要看看我的作品的消息。我一看表现的时候到了，就掏出我刚学的Markdown来写了几篇我的作品的说明文。正当我想把刚build好的html文件打包压缩发送过去的时候，(自动脑补柯南的灵光一闪音效)我发觉事情并不是这么简单。 要是我作死直接发了一堆html过去，估计就别想见到人家了，就算见到了人家公司的HR，估计见面也有不小的概率会被锤。这个时候慌乱的我,手不由自主的打开了谷歌并输入了:How to convert markdown to pdf.然后发现正确的提问用法是:How to convert from markdown to pdf. (；´∀｀)嘛，英语不好这得批评，早晚得去考一次托福… 搜到的第一个是说用谷歌上的插件:Markdown Preview Plus - Chrome Webstore.ドラッグアンドドロップ就可以转换了。什么？ドラ…什么的，打开谷歌翻译:drag and drop.我… 但是利用网上的插件总感觉有些难受，还要上传文件什么的，万一上传到人家服务器上被人家看到了里面的内容就不好了(WEB盲)。于是看到了第二个方法：使用Node.js的工具markdown-pdf 1npm -g install markdown-pdf 安装好工具之后 1markdown-pdf 我的说明文.md 就能生成想要的PDF文件了。浏览生成的PDF文件的时候唯一在意的就是Markdown给隐藏起来的URL链接PDF文件也一并显示了出来。难不成是制作人有意这样，亦或者是机关在作祟，我就暂时不得而知了。因为现在的我得等人家的面试通知。 唉…寝よう]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Markdown</tag>
        <tag>碎碎念</tag>
      </tags>
  </entry>
</search>
